<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="HandheldFriendly" content="true"/> 
	<meta name="MobileOptimized" content="320"/>
	<meta charset="utf-8">
	<title>C1541 ROM disassembly with comments</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<h1>CBM DOS ROM disassembly and memory variables for Commodore 1541 drive</h1>
	<p>Memory variables, IO mapping and ROM analysys are from "Inside Commodore DOS" book by 
	Richard Immers, Ph.D. and Gerald G. Neufeld, Ph.D. published in 1984. The book is available
	on <a href="https://archive.org/details/Inside_Commodore_Dos">Internet Archive</a>. Tables
	below have only minor typo corrections.   
	</p>

	<p>ROM table uses following DOS version for ROM disassembly:
	<ul>
		<li><a href="http://www.zimmers.net/anonftp/pub/cbm/firmware/drives/new/1541/1540-c000.325302-01.bin">325302-01</a> 0xC000-0xDFFF</li>
		<li><a href="http://www.zimmers.net/anonftp/pub/cbm/firmware/drives/new/1541/1541-e000.901229-01.bin">901229-01</a> 0xE000-0xFFFF</li>
	</ul>
	
	Binaries of other versions of DOS ROM are <a href="http://www.zimmers.net/anonftp/pub/cbm/firmware/drives/new/1541/">also available on zimmers.net</a>. Differences between versions are summarized in the <a href="http://www.zimmers.net/anonftp/pub/cbm/firmware/drives/new/1541/1541-dos_diffs.zip">archive</a>.
	
	ROM disassembly and tables digitization made by <b>g3sl@protonmail.ch</b>. Feel free to send me you comments suggestions and fixes.
	</p>
	<h2>RAM variables</h1>
	<table>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Job queue: $0000-$0005</h1>
<p>The job queue is used to tell the disk controller what
disk operations to perform. A disk command such as LOAD,
SAVE, SCRATCH, etc. is interpreted by the drive's 6502
(while in its normal mode) and broken down into a set of
simple operations (jobs) such as: read track 9 sector 18
into data buffer #2, write the data in buffer #3 out to
track 12 sector 5, etc. The track and sector information
required for the job is placed into the header table and
the JOB CODE corresponding to the job to be done is put
in the job queue. The job code's position in the queue
indicates which data buffer (if any) is to be used and
where the track and sector information is stored in the
header table. When the 6502 is next in its floppy disk
controller mode (it switches every 10 milliseconds), it
scans the job queue looking for jobs to do. If it finds
one, it carries it out making use of the track and sector
information in the header table. Once the job is done,
or aborted, the disk controller replaces the job code
with an error code that indicates the job status.</p>
<pre><code>Job codes:
   $80 READ a sector
   $90 WRITE a sector
   $A0 VERIFY a sector
   $B0 SEEK any sector
   $C0 BUMP (move) head to track #1
   $D0 JUMP to machine code in buffer
   $E0 EXECUTE code in buffer once up to speed &amp; head ready

Error codes:
   $01 job completed successfully!
   $02 header block not found
   $03 no SYNC character
   $04 data block not found
   $05 data block checksum error
   $07 verify error after write
   $08 write protect error
   $09 header block checksum error
   $0A data block too long
   $0B ID mismatch error
   $10 byte decoding error</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">JOBS</td>
				<td class="fit">0000</td>
				<td><p>Use buffer #0 ($0300+), find T/S in $06/7</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0001</td>
				<td><p>Use buffer #1 ($0400+), find T/S in $08/9</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0002</td>
				<td><p>Use buffer #2 ($0500+), find T/S in $0A/B</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0003</td>
				<td><p>Use buffer #3 ($0600+), find T/S in $0C/D</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0004</td>
				<td><p>Use buffer #4 ($0700+), find T/S in $0E/F</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0005</td>
				<td><p>Use buffer #5 (no RAM), find T/S in $10/1</p>
</td>
				</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Header table: $0006-$0011</h1>
<p>This is the area that specifies which tracks and sectors
are to be used for the jobs in the job queue. Tracks and
sectors are not needed for BUMP or JUMP jobs.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">HDRS</td>
				<td class="fit">0006</td>
				<td><p>Track/sector for job in $0000 (buffer 0)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0008</td>
				<td><p>Track/sector for job in $0001 (buffer 1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">000A</td>
				<td><p>Track/sector for job in $0002 (buffer 2)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">000C</td>
				<td><p>Track/sector for job in $0003 (buffer 3)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">000E</td>
				<td><p>Track/sector for job in $0004 (buffer 4)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0010</td>
				<td><p>Track/sector for job in $0005 (buffer 5)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DSKID</td>
				<td class="fit">0012</td>
				<td><p>Master copy of disk ID. This is the ID
specified when the disk was formatted.
It is updated whenever a SEEK job is
performed (see ROM patch $EF25) . The
initialize command performs a seek and
therefore updates the master ID.</p>
<pre><code>$0012 first ID character
$0013 second ID character</code></pre>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0014</td>
				<td><p>Unused - Disk ID for drive #1</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">HEADER</td>
				<td class="fit">0016</td>
				<td><p>Image of the most recent header read.
The characters appear here in the same
sequence that Commodore's manual says
they are recorded onto the disk surface,</p>
<pre><code>$0016 first ID character
$0017 second ID character
$0018 track number
$0019 sector number
$001A header checksum

Note: They are actually recorded onto
      disk in the opposite sequence.</code></pre>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ACTJOB</td>
				<td class="fit">001B</td>
				<td><p>Not used</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">WPSW</td>
				<td class="fit">001C</td>
				<td><p>Flag to indicate that there has been a
change in the write protect status.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">001D</td>
				<td><p>Unused (WPSW for drive #1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LWPT</td>
				<td class="fit">001E</td>
				<td><p>Last state of the write protect switch</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">001F</td>
				<td><p>UNUSED (LWPT for drive #1) Set to $01
on power-up</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DRVST</td>
				<td class="fit">0020</td>
				<td><p>Disk drive status</p>
<pre><code>Bit 4    shut down drv motor?  1=yes 0=no
Bit 5    drive motor           1=on  0=off
Bit 6    head stepping         1=on  0=off
Bit 7    drive ready?          1=no  0=yes</code></pre>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0021</td>
				<td><p>Unused (DRVST for drive #1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DRVTRK</td>
				<td class="fit">0022</td>
				<td><p>Track currently under R/W head</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0023</td>
				<td><p>Unused (DRVTRK for drive #1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">STAB</td>
				<td class="fit">0024</td>
				<td><p>Work area for doing interconversions of
binary data and its GCR write images.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SAVPNT</td>
				<td class="fit">002E</td>
				<td><p>Temporary storage of pointers</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUFPNT</td>
				<td class="fit">0030</td>
				<td><p>Pointer to currently active buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">HDRPNT</td>
				<td class="fit">0032</td>
				<td><p>Pointer to active values in header table</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">GCRPNT</td>
				<td class="fit">0034</td>
				<td><p>Pointer to last character converted</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">GCRERR</td>
				<td class="fit">0035</td>
				<td><p>Not used</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BYTCNT</td>
				<td class="fit">0036</td>
				<td><p>Byte counter for GCR/binary conversions</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BITCNT</td>
				<td class="fit">0037</td>
				<td><p>Not used</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BID</td>
				<td class="fit">0038</td>
				<td><p>Data block ID character ($07)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">HBID</td>
				<td class="fit">0039</td>
				<td><p>Header block ID character ($08)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CHKSUM</td>
				<td class="fit">003A</td>
				<td><p>Storage of data or header checksum</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">HINIB</td>
				<td class="fit">003B</td>
				<td><p>Unused</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BYTE</td>
				<td class="fit">003C</td>
				<td><p>Unused</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DRIVE</td>
				<td class="fit">003D</td>
				<td><p>Always $00 on 1541</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CDRIVE</td>
				<td class="fit">003E</td>
				<td><p>Currently active drive ($FF if inactive)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">JOBN</td>
				<td class="fit">003F</td>
				<td><p>Position of last job in job queue (0-5)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TRACC</td>
				<td class="fit">0040</td>
				<td><p>Byte counter for GCR/binary conversions</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NXTJOB</td>
				<td class="fit">0041</td>
				<td><p>Position of next job in job queue (0-5)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NXTRK</td>
				<td class="fit">0042</td>
				<td><p>Next track to move head to</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SECTR</td>
				<td class="fit">0043</td>
				<td><p>Sector counter. Used by format routine</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">WORK</td>
				<td class="fit">0044</td>
				<td><p>Temporary workspace</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">JOB</td>
				<td class="fit">0045</td>
				<td><p>Temporary storage of job code</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CTRACK</td>
				<td class="fit">0046</td>
				<td><p>Unused</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DBID</td>
				<td class="fit">0047</td>
				<td><p>Data block ID code. Set on reset to $07.
This may be changed to write or read
data blocks with different data block
ID codes. However, the first nybble of
the data block ID code should always be
a zero ($0-). Otherwise, the controller
will have difficulty detecting the end
of the sync mark and the start of DBID.
If you try to read a sector whose DBID
is different from the value stored here,
the disk controller will put an error
code of $04 in the job queue and the
drive will report a #22 error (DATA
BLOCK NOT FOUND) .</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ACLTIM</td>
				<td class="fit">0048</td>
				<td><p>Timer for acceleration of head</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SAVSP</td>
				<td class="fit">0049</td>
				<td><p>Temporary save of the stack pointer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">STEPS</td>
				<td class="fit">004A</td>
				<td><p>The number of steps to move the head to
get to the desired track. To move the
head over 1 track, requires XX steps.
Values between and 127 move the head
out (to lower track numbers) . Values
over 128 move the head (256-value) steps
in (to higher track numbers)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TMP</td>
				<td class="fit">004B</td>
				<td><p>Temporary storage</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CSECT</td>
				<td class="fit">004C</td>
				<td><p>Last sector read</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NEXTS</td>
				<td class="fit">004D</td>
				<td><p>Next sector to service</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NXTBF</td>
				<td class="fit">004E</td>
				<td><p>Hi byte of a pointer to the next buffer
of GCR bytes to be changed into binary.
The GCR bytes in the overflow buffer are
translated first. This points to the
buffer that holds the rest of them.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NXTPNT</td>
				<td class="fit">004F</td>
				<td><p>Lo byte of a pointer to the next GCR
byte location that is to be translated</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">GCRFLG</td>
				<td class="fit">0050</td>
				<td><p>Flag to indicate whether the data in the
currently active buffer has been left
in binary (0) or GCR (1) form.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FTNUM</td>
				<td class="fit">0051</td>
				<td><p>Used by the formatting routine to store
the number of the track currently being
formatted. Set on reset to $FF.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BTAB</td>
				<td class="fit">0052</td>
				<td><p>Staging area for the four binary bytes
being converted to GCR by PUT4BG ($F6D0)
or from GCR by GET4GB ($F7E6) .</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">GTAB</td>
				<td class="fit">0056</td>
				<td><p>Staging area for the five GCR bytes
being converted from binary by PUT4BG
($F6D0) or to binary by GET4GB ($F7E6) .</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">AS</td>
				<td class="fit">005E</td>
				<td><p>Number of steps to use to accelerate or
decelerate when stepping the head ($04)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">AF</td>
				<td class="fit">005F</td>
				<td><p>Acceleration/deceleration factor ($04)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ACLSTP</td>
				<td class="fit">0060</td>
				<td><p>Number of steps left to accelerate or
decelerate when stepping the head</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RSTEPS</td>
				<td class="fit">0061</td>
				<td><p>Number of steps left to step the head
in fast stepping (run) mode.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NXTST</td>
				<td class="fit">0062</td>
				<td><p>Pointer to the appropriate head stepping
routine. Normally $FA05 (not stepping)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">MINSTP</td>
				<td class="fit">0064</td>
				<td><p>Minimum number of steps for the head to
move to make the use of fast stepping
mode useful ($C8). If fewer steps needed,
use the slow stepping mode.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">VNMI</td>
				<td class="fit">0065</td>
				<td><p>Pointer to start of NMI routine ($EB2E) .
Set on power up or drive reset.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NMIFLG</td>
				<td class="fit">0067</td>
				<td><p>Flag to indicate whether NMI in progress</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">AUTOFG</td>
				<td class="fit">0068</td>
				<td><p>Flag to enable (0) or disable (1) the
auto initialization of a disk (read BAM)
if ID mismatch detected.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SECINC</td>
				<td class="fit">0069</td>
				<td><p>Sector increment for use by SEQ routine.
Set on reset to ($0A) .</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">REVCNT</td>
				<td class="fit">006A</td>
				<td><p>Counter for error recovery (number of
attempts so far) Set on reset to $05</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">USRJMP</td>
				<td class="fit">006B</td>
				<td><p>Pointer to the start of the user jump
table ($FFF6) . Set on power up or reset.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BMPNT</td>
				<td class="fit">006D</td>
				<td><p>Pointer to the start of the bit map
($0400). Set when a disk is initialized.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T0</td>
				<td class="fit">006F</td>
				<td><p>Temporary work area ($6F on reset)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1</td>
				<td class="fit">0070</td>
				<td><p>Temporary work area</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T2</td>
				<td class="fit">0071</td>
				<td><p>Temporary work area</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T3</td>
				<td class="fit">0072</td>
				<td><p>Temporary work area ($FF on reset)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T4</td>
				<td class="fit">0073</td>
				<td><p>Temporary work area</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">0074</td>
				<td><p>Temporary work area</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">IP</td>
				<td class="fit">0075</td>
				<td><p>Indirect pointer variable ($0100)
Set on power up or reset.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LSNADR</td>
				<td class="fit">0077</td>
				<td><p>Listener address ($28 on reset)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TLKADR</td>
				<td class="fit">0078</td>
				<td><p>Talker address ($48 on reset)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LSNACT</td>
				<td class="fit">0079</td>
				<td><p>Active listener flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TLKACT</td>
				<td class="fit">007A</td>
				<td><p>Active talker flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ADRSED</td>
				<td class="fit">007B</td>
				<td><p>Addressed flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ATNPND</td>
				<td class="fit">007C</td>
				<td><p>Attention pending flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ATNMOD</td>
				<td class="fit">007D</td>
				<td><p>6502 in attention mode</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PRGTRK</td>
				<td class="fit">007E</td>
				<td><p>Last program accessed</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DRVNUM</td>
				<td class="fit">007F</td>
				<td><p>Current drive number (always in 1541)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TRACK</td>
				<td class="fit">0080</td>
				<td><p>Current track number ($00 after use)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SECTOR</td>
				<td class="fit">0081</td>
				<td><p>Current sector number ($00 after use)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LINDX</td>
				<td class="fit">0082</td>
				<td><p>Logical index (current channel#)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SA</td>
				<td class="fit">0083</td>
				<td><p>Current secondary address</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ORGSA</td>
				<td class="fit">0084</td>
				<td><p>Original secondary address</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DATA</td>
				<td class="fit">0085</td>
				<td><p>Temporary data byte</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">R0</td>
				<td class="fit">0086</td>
				<td><p>Temporary result</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">R1</td>
				<td class="fit">0087</td>
				<td><p>Temporary result</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">R2</td>
				<td class="fit">0088</td>
				<td><p>Temporary result</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">R3</td>
				<td class="fit">0089</td>
				<td><p>Temporary result</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">R4</td>
				<td class="fit">008A</td>
				<td><p>Temporary result</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RESULT</td>
				<td class="fit">008B</td>
				<td><p>Result area ($008B-$008E)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ACCUM</td>
				<td class="fit">008F</td>
				<td><p>Accumulator ($008F-0093)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DIRBUF</td>
				<td class="fit">0094</td>
				<td><p>Directory buffer ($0094-0095) $05/$02</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ICMD</td>
				<td class="fit">0096</td>
				<td><p>IEEE command in (not used on 1541)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">MYPA</td>
				<td class="fit">0097</td>
				<td><p>MY PA flag $00</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CONT</td>
				<td class="fit">0098</td>
				<td><p>Bit counter for serial $00</p>
</td>
				</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Buffer byte pointers</h1>
<p>These pointers (one for each buffer) are
used to point at the next byte in the
buffer to be used. The B-P command sets
these pointers.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUFTAB</td>
				<td class="fit">0099</td>
				<td><p>Points to next byte in buffer #0 ($0300)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">009B</td>
				<td><p>Points to next byte in buffer #1 ($0400)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">009D</td>
				<td><p>Points to next byte in buffer #2 ($0500)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">009F</td>
				<td><p>Points to next byte in buffer #3 ($0600)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">00A1</td>
				<td><p>Points to next byte in buffer #4 ($0700)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">00A3</td>
				<td><p>Points to next byte in CMD buffer ($0200)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit"></td>
				<td class="fit">00A5</td>
				<td><p>Points to next byte in ERR buf f er ($02D6 )</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUF0</td>
				<td class="fit">00A7</td>
				<td><p>Table of channel#'s assigned to each of
the buffers. $FF is inactive buffer.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUF1</td>
				<td class="fit">00AE</td>
				<td><p>Table of channelt's assigned to each of
the buffers. $FF is inactive buffer.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RECL</td>
				<td class="fit">00B5</td>
				<td><p>Table of lo bytes of record numbers for
each buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RECH</td>
				<td class="fit">00BB</td>
				<td><p>Table of hi bytes of record numbers for
each buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NR</td>
				<td class="fit">00C1</td>
				<td><p>Table of next record numbers for buffers</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RS</td>
				<td class="fit">00C7</td>
				<td><p>Table of record size for each buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SS</td>
				<td class="fit">00CD</td>
				<td><p>Table of side sectors for each buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">F1PTR</td>
				<td class="fit">00D3</td>
				<td><p>File stream 1 pointer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RECPTR</td>
				<td class="fit">00D4</td>
				<td><p>Pointer to start of record</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SSNUM</td>
				<td class="fit">00D5</td>
				<td><p>Number of side sector</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SSIND</td>
				<td class="fit">00D6</td>
				<td><p>Index to side sector</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RELPTR</td>
				<td class="fit">00D7</td>
				<td><p>Relative file pointer to track</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ENTSEC</td>
				<td class="fit">00D8</td>
				<td><p>Sector of directory entries</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ENTIND</td>
				<td class="fit">00DD</td>
				<td><p>Index of directory entries</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FILDRV</td>
				<td class="fit">00E2</td>
				<td><p>Default flag, drive # (all on 1541)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PATTYP</td>
				<td class="fit">00E7</td>
				<td><p>Pattern, replace, closed-flags, type</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FILTYP</td>
				<td class="fit">00EC</td>
				<td><p>Channel file type</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CHNRDY</td>
				<td class="fit">00F2</td>
				<td><p>Channel status</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">EIOFLG</td>
				<td class="fit">00F8</td>
				<td><p>Temporary for EOI</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">JOBNUM</td>
				<td class="fit">00F9</td>
				<td><p>Current job number</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LRUTBL</td>
				<td class="fit">00FA</td>
				<td><p>Least recently used table</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NODRV</td>
				<td class="fit">00FF</td>
				<td><p>No drive flag for drives and 1</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DSKVER</td>
				<td class="fit">0101</td>
				<td><p>DOS version taken from track 18 sector
for drives 0 and 1</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ZPEND</td>
				<td class="fit">0103</td>
				<td><p>Unused</p>
</td>
				</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Stack area $0104-$01FF</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CMDBUF</td>
				<td class="fit">0200</td>
				<td><p>Command buffer ($0200-$0229)</p>
<p>Disk commands such as: N0:GAMES #1,G1
that are sent to the disk drive from
the computer over the serial bus are
stored here. The command is parsed to
locate special characters such as ':' ','</p>
<p>Once the command has been interpreted,
ROM routines are executed to do it.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CMDNUM</td>
				<td class="fit">022A</td>
				<td><p>Command code number</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LINTAB</td>
				<td class="fit">023B</td>
				<td><p>SA:LINDX table ($022B-$023D)</p>
<p>This table indicates the current status
of each data channel (secondary address)
Each&quot; position represents one channel,
channel 0=$022B; 1=$022C; 2=$022D; etc.</p>
<pre><code>Possible channel status values are:
$FF - inactive
$81 - open for write
$41 - read/write
$01 - open for read</code></pre>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CHNDAT</td>
				<td class="fit">023E</td>
				<td><p>Channel data byte ($023E-$0243)
The most recent byte read or written
for each channel</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LSTCHR</td>
				<td class="fit">0244</td>
				<td><p>Channel last character pointer</p>
<p>Points to the last character read or
written in the buffer for each channel</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TYPE</td>
				<td class="fit">024A</td>
				<td><p>Active file type</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">STRSIZ</td>
				<td class="fit">024B</td>
				<td><p>Length of the string</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TEMPSA</td>
				<td class="fit">024C</td>
				<td><p>Temporary secondary address</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CMD</td>
				<td class="fit">024D</td>
				<td><p>Temporary job command</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LSTSEC</td>
				<td class="fit">024E</td>
				<td><p>Work area for finding best sector to do</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUFUSE</td>
				<td class="fit">024F</td>
				<td><p>Buffer allocation</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">MDIRTY</td>
				<td class="fit">0251</td>
				<td><p>BAM dirty flag (drives 0/1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ENTFND</td>
				<td class="fit">0253</td>
				<td><p>Directory entry found flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DIRLST</td>
				<td class="fit">0254</td>
				<td><p>Directory listing flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CMDWAT</td>
				<td class="fit">0255</td>
				<td><p>Command waiting flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LINUSE</td>
				<td class="fit">0256</td>
				<td><p>LINDX use word</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LBUSED</td>
				<td class="fit">0257</td>
				<td><p>Last buffer used</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">REC</td>
				<td class="fit">0258</td>
				<td><p>Record size. Used by directory routines</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TRKSS</td>
				<td class="fit">0259</td>
				<td><p>Side sector track. Used by dir routines</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SECSS</td>
				<td class="fit">025A</td>
				<td><p>Side sector sector. Used by dir routines</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LSTJOB</td>
				<td class="fit">025B</td>
				<td><p>Last job by buffer ($025B/C/D/E/F)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DSEC</td>
				<td class="fit">0260</td>
				<td><p>Sector of directory entry by buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DIND</td>
				<td class="fit">0266</td>
				<td><p>Index of directory entry by buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ERWORD</td>
				<td class="fit">026C</td>
				<td><p>Error word for recovery</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ERLED</td>
				<td class="fit">026D</td>
				<td><p>Error LED mask for flashing</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PRGDRV</td>
				<td class="fit">026E</td>
				<td><p>Last program drive</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PRGSEC</td>
				<td class="fit">026F</td>
				<td><p>Last program sector</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">WLINDX</td>
				<td class="fit">0270</td>
				<td><p>Write LINDX</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">RLINDX</td>
				<td class="fit">0271</td>
				<td><p>Read LINDX</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NBTEMP</td>
				<td class="fit">0272</td>
				<td><p># blocks temp</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CMDSIZ</td>
				<td class="fit">0274</td>
				<td><p>Command string size</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">CHAR</td>
				<td class="fit">0275</td>
				<td><p>Character under the parser</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LIMIT</td>
				<td class="fit">0276</td>
				<td><p>PTR limit in comparison</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">F1CNT</td>
				<td class="fit">0277</td>
				<td><p>File stream 1 count</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">F2CNT</td>
				<td class="fit">0278</td>
				<td><p>File stream 2 count</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">F2PTR</td>
				<td class="fit">0279</td>
				<td><p>File stream 2 pointer</p>
</td>
				</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Parser tables ( $027A-$0289 )</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FILTBL</td>
				<td class="fit">027A</td>
				<td><p>Table of filename pointers</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FILTRK</td>
				<td class="fit">0280</td>
				<td><p>First file link (Track)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FILSEC</td>
				<td class="fit">0285</td>
				<td><p>First file link (Sector)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PATFLG</td>
				<td class="fit">028A</td>
				<td><p>Pattern presence flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">IMAGE</td>
				<td class="fit">028B</td>
				<td><p>File stream image</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DRVCNT</td>
				<td class="fit">028C</td>
				<td><p>Number of drive searches</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DRVFLG</td>
				<td class="fit">028D</td>
				<td><p>Drive search flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LSTDRV</td>
				<td class="fit">028E</td>
				<td><p>Last drive w/o error. Used as the
default drive number.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FOUND</td>
				<td class="fit">028F</td>
				<td><p>Found flag in directory searches</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DIRSEC</td>
				<td class="fit">0290</td>
				<td><p>Directory sector</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DELSEC</td>
				<td class="fit">0291</td>
				<td><p>Sector of first available entry</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DELIND</td>
				<td class="fit">0292</td>
				<td><p>Index of first available entry</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">LSTBUF</td>
				<td class="fit">0293</td>
				<td><p>=0 if last block</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">INDEX</td>
				<td class="fit">0294</td>
				<td><p>Current index in buffer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">FILCNT</td>
				<td class="fit">0295</td>
				<td><p>Counter of file entries</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TYPFLG</td>
				<td class="fit">0296</td>
				<td><p>Match by type of flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">MODE</td>
				<td class="fit">0297</td>
				<td><p>Active file mode (R,W)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">JOBRTN</td>
				<td class="fit">0298</td>
				<td><p>Job return flag</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">EPTR</td>
				<td class="fit">0299</td>
				<td><p>Pointer for recovery</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TOFF</td>
				<td class="fit">029A</td>
				<td><p>Total track offset</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">UBAM</td>
				<td class="fit">029B</td>
				<td><p>Last BAM update pointer</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">TBAM</td>
				<td class="fit">029D</td>
				<td><p>Track # of BAM image (drive 0/1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BAM</td>
				<td class="fit">02A1</td>
				<td><p>BAM images ($02A1-02B0)</p>
</td>
				</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Output buffers ( $02B1-$02F8 )</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NAMBUF</td>
				<td class="fit">02B1</td>
				<td><p>Directory buffer ($02B1-$02D4 )</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ERRBUF</td>
				<td class="fit">02D5</td>
				<td><p>Error message buffer ($02D5-$02F8)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">WBAM</td>
				<td class="fit">02F9</td>
				<td><p>Don't write BAM flag. Set to at start
and end of any disk command.</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NDBL</td>
				<td class="fit">02FA</td>
				<td><p># of disk blocks free (lo byte 0/1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">NDBK</td>
				<td class="fit">02FC</td>
				<td><p># of disk blocks free (hi byte 0/1)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PHASE</td>
				<td class="fit">02FE</td>
				<td><p>Current phase of head stepper motor</p>
</td>
				</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Data buffers ( $0300-$07FF)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUF0</td>
				<td class="fit">0300</td>
				<td><p>Data buffer #0 ($0300-$03FF)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUF1</td>
				<td class="fit">0400</td>
				<td><p>Data buffer #1 ($0400-$04FF)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUF2</td>
				<td class="fit">0500</td>
				<td><p>Data buffer #2 ($0500-$05FF)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUF3</td>
				<td class="fit">0600</td>
				<td><p>Data buffer #3 ($0600-$06FF)</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">BUF4</td>
				<td class="fit">0700</td>
				<td><p>Data buffer #4 ($0700-$07FF) BAM ONLY!</p>
</td>
				</tr>
		</tbody>
	</table>

	<h2>IO mapping</h1>
	<table>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Serial I/O 6522 ( $1800-$180F)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PB</td>
				<td class="fit">1800</td>
				<td><p>Data port B - Serial data I/O</p>
<pre><code>Bits for serial handshake:

Name   Bit Hex  Connect
DATIN  0   $01  Data in line
DATOUT 1   $02  Data out line
CLKIN  2   $04  Clock in line
CLKOUT 3   $08  Clock out line
ATNA   4   $10  Attention acknowledge line
ATN    7   $80  Attention in line</code></pre>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PA1</td>
				<td class="fit">1801</td>
				<td><p>Data port A - Unused</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DDRB1</td>
				<td class="fit">1802</td>
				<td><p>Data direCtion for port B</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DDRA1</td>
				<td class="fit">1803</td>
				<td><p>Data direCtion for port A - Unused</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1LC1</td>
				<td class="fit">1804</td>
				<td><p>Timer 1 low counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1HC1</td>
				<td class="fit">1805</td>
				<td><p>Timer 1 high counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1LL2</td>
				<td class="fit">1806</td>
				<td><p>Timer 1 low latch</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1HL2</td>
				<td class="fit">1807</td>
				<td><p>Timer 1 high latch</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T2LC1</td>
				<td class="fit">1808</td>
				<td><p>Timer 2 low counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T2HC1</td>
				<td class="fit">1809</td>
				<td><p>Timer 2 high counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SR1</td>
				<td class="fit">180A</td>
				<td><p>Shift register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ACR1</td>
				<td class="fit">180B</td>
				<td><p>Auxiliary control register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PCR1</td>
				<td class="fit">180C</td>
				<td><p>Peripheral control register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">IFR1</td>
				<td class="fit">180D</td>
				<td><p>Interrupt flag register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">IER1</td>
				<td class="fit">180E</td>
				<td><p>Interrupt enable register</p>
</td>
				</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td><h1>Disk controller 6522 ( $1C00-$1C0F)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DSKCNT</td>
				<td class="fit">1C00</td>
				<td><p>Data port B - Disk controller I/O</p>
<pre><code>Bit Hex     Connect
0/1 $01/$02 Bits &amp; 1 are cycled to step the head
2   $04     Motor on (1) or off (0)
3   $08     Drive active LED on/off
4   $10     Write protect sense
5   $20     Density select (0)
6   $40	    Density select (1)
7   $80     SYNC detect line</code></pre>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DATA2</td>
				<td class="fit">1C01</td>
				<td><p>Data port A - GCR data I/O to diskette</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DDRB2</td>
				<td class="fit">1C02</td>
				<td><p>Data direction for port B</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">DDRA2</td>
				<td class="fit">1C03</td>
				<td><p>Data direction for port A</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1LC2</td>
				<td class="fit">1C04</td>
				<td><p>Timer 1 low counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1HC2</td>
				<td class="fit">1C05</td>
				<td><p>Timer 1 high counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1LL2</td>
				<td class="fit">1C06</td>
				<td><p>Timer 1 low latch</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T1HL2</td>
				<td class="fit">1C07</td>
				<td><p>Timer 1 high latch</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T2LC2</td>
				<td class="fit">1C08</td>
				<td><p>Timer 2 low counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">T2HC2</td>
				<td class="fit">1C09</td>
				<td><p>Timer 2 high counter</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">SR2</td>
				<td class="fit">1C0A</td>
				<td><p>Shift register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">ACR2</td>
				<td class="fit">1C0B</td>
				<td><p>Auxiliary control register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">PCR2</td>
				<td class="fit">1C0C</td>
				<td><p>Peripheral control register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">IFR2</td>
				<td class="fit">1C0D</td>
				<td><p>Interrupt flag register</p>
</td>
				</tr>
		</tbody>
			<tbody class="code">
				<tr>
				<td class="fit">IER2</td>
				<td class="fit">1C0E</td>
				<td><p>Interrupt enable register</p>
</td>
				</tr>
		</tbody>
	</table>
	<h2>ROM mapping</h1>
	<table>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C000</td>
				<td>97</td>
				<td class="fit"></td><td rowspan="1"><p>Checksum of $Cxxx and $DXXX ROM</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C001</td>
				<td>AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA</td>
				<td class="fit"></td><td rowspan="1"><p>Unused</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Turn on drive-active LED</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETLDA</td><td class="fit">C100</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="14"><p>Set bit 3 of DSKCNT ($1C00) to turn on
LED for the current drive (DRVNUM; $7F).</p>
</td></tr>
				<tr><td></td><td class="fit">C101</td>
				<td>A9 F7</td>
				<td class="fit">LDA #$F7</td></tr>
				<tr><td></td><td class="fit">C103</td>
				<td>2D 00 1C</td>
				<td class="fit">AND $1C00</td></tr>
				<tr><td></td><td class="fit">C106</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">C107</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td></tr>
				<tr><td></td><td class="fit">C109</td>
				<td>F0 05</td>
				<td class="fit">BEQ $C110</td></tr>
				<tr><td></td><td class="fit">C10B</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">C10C</td>
				<td>09 00</td>
				<td class="fit">ORA #$00</td></tr>
				<tr><td></td><td class="fit">C10E</td>
				<td>D0 03</td>
				<td class="fit">BNE $C113</td></tr>
				<tr><td></td><td class="fit">C110</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">C111</td>
				<td>09 08</td>
				<td class="fit">ORA #$08</td></tr>
				<tr><td></td><td class="fit">C113</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
				<tr><td></td><td class="fit">C116</td>
				<td>58</td>
				<td class="fit">CLI</td></tr>
				<tr><td></td><td class="fit">C117</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Turn on drive-active LED</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LEDSON</td><td class="fit">C118</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="6"><p>Set bit 3 of DSKCNT ($1C00) to turn on
drive active LED for drive 0.</p>
</td></tr>
				<tr><td></td><td class="fit">C119</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td></tr>
				<tr><td></td><td class="fit">C11B</td>
				<td>0D 00 1C</td>
				<td class="fit">ORA $1C00</td></tr>
				<tr><td></td><td class="fit">C11E</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
				<tr><td></td><td class="fit">C121</td>
				<td>58</td>
				<td class="fit">CLI</td></tr>
				<tr><td></td><td class="fit">C122</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Turn off error LED</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERROFF</td><td class="fit">C123</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Store $00 in ERWORD ($026C) and in ERLED
($026D) to clear any error status and
turn off drive-active/error LED.</p>
</td></tr>
				<tr><td></td><td class="fit">C125</td>
				<td>8D 6C 02</td>
				<td class="fit">STA $026C</td></tr>
				<tr><td></td><td class="fit">C128</td>
				<td>8D 6D 02</td>
				<td class="fit">STA $026D</td></tr>
				<tr><td></td><td class="fit">C12B</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Turn on error LED</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERRON</td><td class="fit">C12C</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="14"><p>Store $80 in ERWORD ($026C) to ensure
LED will continue to flash and set bit
3 of DSKCNT to turn the LED on using
the LED mask from LEDMSK ($FECA).</p>
</td></tr>
				<tr><td></td><td class="fit">C12D</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">C12E</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">C12F</td>
				<td>A9 50</td>
				<td class="fit">LDA #$50</td></tr>
				<tr><td></td><td class="fit">C131</td>
				<td>8D 6C 02</td>
				<td class="fit">STA $026C</td></tr>
				<tr><td></td><td class="fit">C134</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
				<tr><td></td><td class="fit">C136</td>
				<td>BD CA FE</td>
				<td class="fit">LDA $FECA,X</td></tr>
				<tr><td></td><td class="fit">C139</td>
				<td>8D 6D 02</td>
				<td class="fit">STA $026D</td></tr>
				<tr><td></td><td class="fit">C13C</td>
				<td>0D 00 1C</td>
				<td class="fit">ORA $1C00</td></tr>
				<tr><td></td><td class="fit">C13F</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
				<tr><td></td><td class="fit">C142</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">C143</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">C144</td>
				<td>58</td>
				<td class="fit">CLI</td></tr>
				<tr><td></td><td class="fit">C145</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Parse string in command buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PARSXQ</td><td class="fit">C146</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Clear the &quot;don't write BAM&quot; flag, WBAM
($02F9) and move the drive number of the
last successful job from LSTDRV ($028E)
to DRVNUM ($7F). This makes the
last used drive the default drive.</p>
</td></tr>
				<tr><td></td><td class="fit">C148</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
				<tr><td></td><td class="fit">C14B</td>
				<td>AD 8E 02</td>
				<td class="fit">LDA $028E</td></tr>
				<tr><td></td><td class="fit">C14E</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C150</td>
				<td>20 BC E6</td>
				<td class="fit">JSR $E6BC</td><td rowspan="1"><p>JSR to OKERR ($E6BC) to clear any errors
and move the OK error message into the
error buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C153</td>
				<td>A5 84</td>
				<td class="fit">LDA $84</td><td rowspan="5"><p>Check if the command's secondary address
(ORGSA; $84) was $0F (command channel).</p>
</td></tr>
				<tr><td></td><td class="fit">C155</td>
				<td>10 09</td>
				<td class="fit">BPL $C160</td></tr>
				<tr><td></td><td class="fit">C157</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">C159</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td></tr>
				<tr><td></td><td class="fit">C15B</td>
				<td>F0 03</td>
				<td class="fit">BEQ $C160</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C15D</td>
				<td>4C B4 D7</td>
				<td class="fit">JMP $D7B4</td><td rowspan="1"><p>If it was not $0F, exit with a JMP to
OPEN ($D7B4).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PS5</td><td class="fit">C160</td>
				<td>20 B3 C2</td>
				<td class="fit">JSR $C2B3</td><td rowspan="1"><p>If the secondary address was $0F, JSR to
CMDSET ($C2B3) to interpret the command
and set up the necessary variables and
registers (on return .Y=0).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C163</td>
				<td>B1 A3</td>
				<td class="fit">LDA ($A3),Y</td><td rowspan="3"><p>Move first character of command from the
command buffer ($0200) to CHAR ($0275).</p>
</td></tr>
				<tr><td></td><td class="fit">C165</td>
				<td>8D 75 02</td>
				<td class="fit">STA $0275</td></tr>
				<tr><td></td><td class="fit">C168</td>
				<td>A2 0B</td>
				<td class="fit">LDX #$0B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PS10</td><td class="fit">C16A</td>
				<td>BD 89 FE</td>
				<td class="fit">LDA $FE89,X</td><td rowspan="7"><p>Search the command table (CMDTBL; $FE89)
for this character. If not found, exit
by loading .A with a #$31 (BAD COMMAND)
and jumping to the command level error
handler (CMDERR; $C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">C16D</td>
				<td>CD 75 02</td>
				<td class="fit">CMP $0275</td></tr>
				<tr><td></td><td class="fit">C170</td>
				<td>F0 08</td>
				<td class="fit">BEQ $C17A</td></tr>
				<tr><td></td><td class="fit">C172</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">C173</td>
				<td>10 F5</td>
				<td class="fit">BPL $C16A</td></tr>
				<tr><td></td><td class="fit">C175</td>
				<td>A9 31</td>
				<td class="fit">LDA #$31</td></tr>
				<tr><td></td><td class="fit">C177</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PS20</td><td class="fit">C17A</td>
				<td>8E 2A 02</td>
				<td class="fit">STX $022A</td><td rowspan="3"><p>If found, store the command's position
in the table (the command number) into
CMDNUM ($022A).</p>
<p>Check if this command
must be parsed by comparing the command
number with $09. If parsing is required
(NEW, RENAME, SCRATCH, COPY, &amp; LOAD),</p>
</td></tr>
				<tr><td></td><td class="fit">C17D</td>
				<td>E0 09</td>
				<td class="fit">CPX #$09</td></tr>
				<tr><td></td><td class="fit">C17F</td>
				<td>90 03</td>
				<td class="fit">BCC $C184</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C181</td>
				<td>20 EE C1</td>
				<td class="fit">JSR $C1EE</td><td rowspan="1"><p>JSR to TAGCMD ($C1EE) to set tables,
pointers and patterns.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PS30</td><td class="fit">C184</td>
				<td>AE 2A 02</td>
				<td class="fit">LDX $022A</td><td rowspan="6"><p>Move the address of the appropriate ROM
routine from the tables, CJUMPL ($FE95)
and CJUMPH ($FEA1) into $6F/$70 (TEMP).</p>
<p>Exit with an indirect JMP to the routine
via the vector at TEMP ($6F).</p>
</td></tr>
				<tr><td></td><td class="fit">C187</td>
				<td>BD 95 FE</td>
				<td class="fit">LDA $FE95,X</td></tr>
				<tr><td></td><td class="fit">C18A</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">C18C</td>
				<td>BD A1 FE</td>
				<td class="fit">LDA $FEA1,X</td></tr>
				<tr><td></td><td class="fit">C18F</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">C191</td>
				<td>6C 6F 00</td>
				<td class="fit">JMP ($006F)</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Terminate command successfully</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ENDCMD</td><td class="fit">C194</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="7"><p>Clear the &quot;don't write BAM&quot; flag, WBAM
($02F9).</p>
<p>Load .A with the error status
from ERWORD ($026C).</p>
<p>If non-zero, an
error has occurred so exit with a JMP
to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">C196</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
				<tr><td></td><td class="fit">C199</td>
				<td>AD 6C 02</td>
				<td class="fit">LDA $026C</td></tr>
				<tr><td></td><td class="fit">C19C</td>
				<td>D0 2A</td>
				<td class="fit">BNE $C1C8</td></tr>
				<tr><td></td><td class="fit">C19E</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">C1A0</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">C1A1</td>
				<td>84 80</td>
				<td class="fit">STY $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCREND</td><td class="fit">C1A3</td>
				<td>84 81</td>
				<td class="fit">STY $81</td><td rowspan="4"><p>If command completed with no errors, set
TRACK ($80). SECTOR ($81), and the
pointer into the command buffer, CB($A3)
to $00.</p>
<p>JSR to ERRMSG ($E6C7) and ERROFF
($C123) to clear any error status.</p>
</td></tr>
				<tr><td></td><td class="fit">C1A5</td>
				<td>84 A3</td>
				<td class="fit">STY $A3</td></tr>
				<tr><td></td><td class="fit">C1A7</td>
				<td>20 C7 E6</td>
				<td class="fit">JSR $E6C7</td></tr>
				<tr><td></td><td class="fit">C1AA</td>
				<td>20 23 C1</td>
				<td class="fit">JSR $C123</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCREN1</td><td class="fit">C1AD</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="7"><p>Move current drive number from DRVNUM
($7F) to last used drive number, LSTDRV
($028E).</p>
<p>Set the drive-busy flag, NODRV
($FF) to $00 to indicate that the drive
is inactive.</p>
<p>JSR to CLRCB ($C1BD) to
zero the command buffer. JMP to FREICH
($D4DA) to clear the internal channel.</p>
</td></tr>
				<tr><td></td><td class="fit">C1AF</td>
				<td>8D 8E 02</td>
				<td class="fit">STA $028E</td></tr>
				<tr><td></td><td class="fit">C1B2</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">C1B3</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">C1B5</td>
				<td>95 FF</td>
				<td class="fit">STA $FF,X</td></tr>
				<tr><td></td><td class="fit">C1B7</td>
				<td>20 BD C1</td>
				<td class="fit">JSR $C1BD</td></tr>
				<tr><td></td><td class="fit">C1BA</td>
				<td>4C DA D4</td>
				<td class="fit">JMP $D4DA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLRCB</td><td class="fit">C1BD</td>
				<td>A0 28</td>
				<td class="fit">LDY #$28</td><td rowspan="6"><p>Clear the command buffer ($0200-$0228)
Erase any old command information by
overwriting the old command with $00.</p>
</td></tr>
				<tr><td></td><td class="fit">C1BF</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">C1C1</td>
				<td>99 00 02</td>
				<td class="fit">STA $0200,Y</td></tr>
				<tr><td></td><td class="fit">C1C4</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C1C5</td>
				<td>10 FA</td>
				<td class="fit">BPL $C1C1</td></tr>
				<tr><td></td><td class="fit">C1C7</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Command level error handling</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMDERR</td><td class="fit">C1C8</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Set TRACK ($80) and SECTOR ($81) to $00
and JMP to CMDER2 ($E645) .</p>
</td></tr>
				<tr><td></td><td class="fit">C1CA</td>
				<td>84 80</td>
				<td class="fit">STY $80</td></tr>
				<tr><td></td><td class="fit">C1CC</td>
				<td>84 81</td>
				<td class="fit">STY $81</td></tr>
				<tr><td></td><td class="fit">C1CE</td>
				<td>4C 45 E6</td>
				<td class="fit">JMP $E645</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Simple parser</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SIMPRS</td><td class="fit">C1D1</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="4"><p>Initialize .X and the file table pointer
FILTBL ($027A) to $00. Load .A with a
$3A (:) and JSR to PARSE ($C268) to scan
the command string for a colon.</p>
</td></tr>
				<tr><td></td><td class="fit">C1D3</td>
				<td>8E 7A 02</td>
				<td class="fit">STX $027A</td></tr>
				<tr><td></td><td class="fit">C1D6</td>
				<td>A9 3A</td>
				<td class="fit">LDA #$3A</td></tr>
				<tr><td></td><td class="fit">C1D8</td>
				<td>20 68 C2</td>
				<td class="fit">JSR $C268</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C1DB</td>
				<td>F0 05</td>
				<td class="fit">BEQ $C1E2</td><td rowspan="5"><p>On return Z=1 if &quot;:&quot; found and .Y points
to its position in the command. If not
found, leave FILTAB=$00 and exit. If &quot;:&quot;
was found, set FILTAB=(&quot;:&quot; position-1)
and exit. All exits are with a JMP to
SETANY ($C368) to set the drive number.</p>
</td></tr>
				<tr><td></td><td class="fit">C1DD</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C1DE</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C1DF</td>
				<td>8C 7A 02</td>
				<td class="fit">STY $027A</td></tr>
				<tr><td></td><td class="fit">C1E2</td>
				<td>4C 68 C3</td>
				<td class="fit">JMP $C368</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find colon (:) in command string</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PRSCLN</td><td class="fit">C1E5</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Load .X and .Y with $00 and. A with $3A
(:) and JMP to PARSE ($C268).</p>
</td></tr>
				<tr><td></td><td class="fit">C1E7</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
				<tr><td></td><td class="fit">C1E9</td>
				<td>A9 3A</td>
				<td class="fit">LDA #$3A</td></tr>
				<tr><td></td><td class="fit">C1EB</td>
				<td>4C 68 C2</td>
				<td class="fit">JMP $C268</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Tag command string, set up CMD structure and file stream pointers</h1>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h2>Command Structure (Bit mapped)</h2>
<p>The disk commands, RENAME, SCRATCH, NEW,
and LOAD, are analyzed by this routine
to determine the command structure. As
the command is parsed bits in IMAGE
($028B) are set or cleared to indicate
the presence or adsence of various parts
of the command. Once the command has
been analyzed, its structure image is
checked against the correct structure
for that command diven in STRUCT ($FEA5+)</p>
<pre><code>Bit | Name | Meaning
----|------|--------
7   | P1   | Wild cards present (Y=1)
6   | G1   | More than one file implied (Y=1)
5   | D1   | Drive # specified (not default)
4   | N1   | Filename1 given
3   | P2   | Wild cards present (Y=1)
2   | G2   | More than one file implied (Y=1)
1   | D2   | Drive # specified (not default)
0   | N2   | Filename2 given

Note: Bits 7-4 refer to file #1
      Bits 3-0 refer to file #2</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TAGCMD</td><td class="fit">C1EE</td>
				<td>20 E5 C1</td>
				<td class="fit">JSR $C1E5</td><td rowspan="2"><p>JSR to PRSCLN ($C1E5) to locate the
position of the colon (:) that is a
necessary part of all these commands,
e.g. R0:NEWNAME=OLDNAME (Rename)</p>
</td></tr>
				<tr><td></td><td class="fit">C1F1</td>
				<td>D0 05</td>
				<td class="fit">BNE $C1F8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC25</td><td class="fit">C1F3</td>
				<td>A9 34</td>
				<td class="fit">LDA #$34</td><td rowspan="2"><p>If no colon was found, load .A with $34
to indicate a bad command and exit with
a JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">C1F5</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC30</td><td class="fit">C1F8</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="3"><p>If a colon was found, set FILTAB to the
colon position-1.</p>
</td></tr>
				<tr><td></td><td class="fit">C1F9</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C1FA</td>
				<td>8C 7A 02</td>
				<td class="fit">STY $027A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C1FD</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Check if a comma was found before the
colon (.X &gt; on return from PARSE).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C1FE</td>
				<td>D0 F3</td>
				<td class="fit">BNE $C1F3</td><td rowspan="1"><p>If a comma was found, the syntax is bad
so exit via TC25 ($C1F3).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC35</td><td class="fit">C200</td>
				<td>A9 3D</td>
				<td class="fit">LDA #$3D</td><td rowspan="5"><p>Load .A with $3D (=) and JSR to PARSE
($C268). On return .X=0 indicates that
no wild-card characters (? or *) were
found.</p>
<p>If any were found, set bit 6 (G1)
of IMAGE ($028B) to indicate that the
command applies to more than one file.</p>
</td></tr>
				<tr><td></td><td class="fit">C202</td>
				<td>20 68 C2</td>
				<td class="fit">JSR $C268</td></tr>
				<tr><td></td><td class="fit">C205</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">C206</td>
				<td>F0 02</td>
				<td class="fit">BEQ $C20A</td></tr>
				<tr><td></td><td class="fit">C208</td>
				<td>A9 40</td>
				<td class="fit">LDA #$40</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC40</td><td class="fit">C20A</td>
				<td>09 21</td>
				<td class="fit">ORA #$21</td><td rowspan="2"><p>In all cases, set bit 5 (Dl) of IMAGE
to indicate that a drive # is present
and set bit (N2) to indicate that a
second file name is given (fixed later).</p>
</td></tr>
				<tr><td></td><td class="fit">C20C</td>
				<td>8D 8B 02</td>
				<td class="fit">STA $028B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C20F</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Increment .X and use it to set the
lengths of filenames 1 and 2, F1CNT and
F2CNT ($0277/8).</p>
<p>Filename 2 will default
to the same length as filename 1.</p>
</td></tr>
				<tr><td></td><td class="fit">C210</td>
				<td>8E 77 02</td>
				<td class="fit">STX $0277</td></tr>
				<tr><td></td><td class="fit">C213</td>
				<td>8E 78 02</td>
				<td class="fit">STX $0278</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C216</td>
				<td>AD 8A 02</td>
				<td class="fit">LDA $028A</td><td rowspan="5"><p>Check if PARSE found any wild cards by
loading PATFLG ($028A). If any found,
set bit 7 (PI) of IMAGE ($028B).</p>
</td></tr>
				<tr><td></td><td class="fit">C219</td>
				<td>F0 0D</td>
				<td class="fit">BEQ $C228</td></tr>
				<tr><td></td><td class="fit">C21B</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td></tr>
				<tr><td></td><td class="fit">C21D</td>
				<td>0D 8B 02</td>
				<td class="fit">ORA $028B</td></tr>
				<tr><td></td><td class="fit">C220</td>
				<td>8D 8B 02</td>
				<td class="fit">STA $028B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C223</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set pattern flag, PATFLG ($028A) to $00
to prepare for parsing the rest of the
command.</p>
</td></tr>
				<tr><td></td><td class="fit">C225</td>
				<td>8D 8A 02</td>
				<td class="fit">STA $028A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC50</td><td class="fit">C228</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Check if there is any command left to
parse by checking the value of .Y set by
PARSE.</p>
<p>If .Y=0, nothing left so branch
to TC75 ($C254) to check structure.</p>
</td></tr>
				<tr><td></td><td class="fit">C229</td>
				<td>F0 29</td>
				<td class="fit">BEQ $C254</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C22B</td>
				<td>9D 7A 02</td>
				<td class="fit">STA $027A,X</td><td rowspan="3"><p>Store value from .Y in filetable, FILTBL
($027A),X. Set the pointer to the start
of filename #2, F2PNT ($0279) from the
current value of F1CNT ($0277).</p>
</td></tr>
				<tr><td></td><td class="fit">C22E</td>
				<td>AD 77 02</td>
				<td class="fit">LDA $0277</td></tr>
				<tr><td></td><td class="fit">C231</td>
				<td>8D 79 02</td>
				<td class="fit">STA $0279</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C234</td>
				<td>A9 8D</td>
				<td class="fit">LDA #$8D</td><td rowspan="5"><p>Load .A with $8D (shifted CR) and JSR to
PARSE ($C268) to parse the rest of the
command.</p>
<p>On return increment .X so it
points to the end of the string and put
the value into F2CNT ($0278). Decrement
the value of .X to restore its former
value.</p>
</td></tr>
				<tr><td></td><td class="fit">C236</td>
				<td>20 68 C2</td>
				<td class="fit">JSR $C268</td></tr>
				<tr><td></td><td class="fit">C239</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">C23A</td>
				<td>8E 78 02</td>
				<td class="fit">STX $0278</td></tr>
				<tr><td></td><td class="fit">C23D</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C23E</td>
				<td>AD 8A 02</td>
				<td class="fit">LDA $028A</td><td rowspan="3"><p>Check if any wild cards were found by
PARSE in filename 2 by checking the
pattern flag, PATFLG ($028A).</p>
<p>If any
were found, set 3 (P2) of IMAGE ($028B).</p>
</td></tr>
				<tr><td></td><td class="fit">C241</td>
				<td>F0 02</td>
				<td class="fit">BEQ $C245</td></tr>
				<tr><td></td><td class="fit">C243</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC60</td><td class="fit">C245</td>
				<td>EC 77 02</td>
				<td class="fit">CPX $0277</td><td rowspan="2"><p>Check if there was a second filename by
checking if .X = F1CNT. If second file
name is only 1 chr long, branch to TC70.</p>
</td></tr>
				<tr><td></td><td class="fit">C248</td>
				<td>F0 02</td>
				<td class="fit">BEQ $C24C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C24A</td>
				<td>09 04</td>
				<td class="fit">ORA #$04</td><td rowspan="1"><p>Set bit 2 to indicate that the command
implies more than one second file name.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC70</td><td class="fit">C24C</td>
				<td>09 03</td>
				<td class="fit">ORA #$03</td><td rowspan="3"><p>Set bit 1 to indicate that a second
drive is specified and bit to indicate
that a second file name is given.</p>
<p>EOR this with IMAGE (clears bit 0) and store
the result back into IMAGE ($028B) .</p>
</td></tr>
				<tr><td></td><td class="fit">C24E</td>
				<td>4D 8B 02</td>
				<td class="fit">EOR $028B</td></tr>
				<tr><td></td><td class="fit">C251</td>
				<td>8D 8B 02</td>
				<td class="fit">STA $028B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC75</td><td class="fit">C254</td>
				<td>AD 8B 02</td>
				<td class="fit">LDA $028B</td><td rowspan="5"><p>Check IMAGE against the entry for that
command (CMD number from CMDNUM, $022A)
in the structure table, STRUCT ($FEA5+)</p>
<p>If match, syntax is OK; exit with an RTS</p>
</td></tr>
				<tr><td></td><td class="fit">C257</td>
				<td>AE 2A 02</td>
				<td class="fit">LDX $022A</td></tr>
				<tr><td></td><td class="fit">C25A</td>
				<td>3D A5 FE</td>
				<td class="fit">AND $FEA5,X</td></tr>
				<tr><td></td><td class="fit">C25D</td>
				<td>D0 01</td>
				<td class="fit">BNE $C260</td></tr>
				<tr><td></td><td class="fit">C25F</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TC80</td><td class="fit">C260</td>
				<td>8D 6C 02</td>
				<td class="fit">STA $026C</td><td rowspan="3"><p>Store IMAGE in ERWORD ($026C).</p>
<p>Load .A with a $30 to indicate a bad syntax and
exit with a JMP to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">C263</td>
				<td>A9 30</td>
				<td class="fit">LDA #$30</td></tr>
				<tr><td></td><td class="fit">C265</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Parse string</h1>
<p>On entry, .A contains the character to
be found in the string, .Y points to the
the character in the string where the
scan is to start, and .X points into the
file table, FILTAB,X.</p>
<p>The routine scans the string for special
characters &quot;*&quot;. &quot;?&quot;, and &quot;,&quot; as well as
the desired character.</p>
<p>In scanning the string .Y is used as a pointer to the
character in the command string being
examined and .X is a pointer into the
file table, FILTAB (S027B+) for storing
the positions (.Y value) of the start &amp;
end of file names that are found.</p>
<p>When a wild card (* or ?) is found, the pattern
flag PATFLG ($028A) is incremented.</p>
<p>When a comma is found, its position is noted
in the file table, FILTAB and a check is
made to ensure that not too many file
names are present.</p>
<p>When the special character is found or
the end of the command is reached, the
routine ends.</p>
<p>If no wild cards have been
found, the pattern type, PATTYP,X is set
to $80. Otherwise it is left unchanged.</p>
<p>On exit, .Y=0 and the Z flag =0 if the
desired character has not been found. If
it has been found, .Y = the position of
the character and the Z flag is set.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PARSE</td><td class="fit">C268</td>
				<td>8D 75 02</td>
				<td class="fit">STA $0275</td><td rowspan="1"><p>Store the desired character in CHAR
($0275) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PR10</td><td class="fit">C26B</td>
				<td>CC 74 02</td>
				<td class="fit">CPY $0274</td><td rowspan="2"><p>Start of loop using .Y as a counter to
scan the command string. If .Y is
greater than or equal to the length of
the command string, CMDSIZE ($0274) ,
branch to PR30 ($C29E) .</p>
</td></tr>
				<tr><td></td><td class="fit">C26E</td>
				<td>B0 2E</td>
				<td class="fit">BCS $C29E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C270</td>
				<td>B1 A3</td>
				<td class="fit">LDA ($A3),Y</td><td rowspan="4"><p>Load command string character into .A
and increment .Y counter. Check if it is
the desired character. If it is, branch
to PR35 ($C2A0) .</p>
</td></tr>
				<tr><td></td><td class="fit">C272</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">C273</td>
				<td>CD 75 02</td>
				<td class="fit">CMP $0275</td></tr>
				<tr><td></td><td class="fit">C276</td>
				<td>F0 28</td>
				<td class="fit">BEQ $C2A0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C278</td>
				<td>C9 2A</td>
				<td class="fit">CMP #$2A</td><td rowspan="4"><p>Check if it is a wild card (&quot;*&quot; or &quot;?&quot;).
If not, branch to PR25 ($C283).</p>
</td></tr>
				<tr><td></td><td class="fit">C27A</td>
				<td>F0 04</td>
				<td class="fit">BEQ $C280</td></tr>
				<tr><td></td><td class="fit">C27C</td>
				<td>C9 3F</td>
				<td class="fit">CMP #$3F</td></tr>
				<tr><td></td><td class="fit">C27E</td>
				<td>D0 03</td>
				<td class="fit">BNE $C283</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PR20</td><td class="fit">C280</td>
				<td>EE 8A 02</td>
				<td class="fit">INC $028A</td><td rowspan="1"><p>Increment the pattern flag, PATFLG
($028A) to count the # of wild cards.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PR25</td><td class="fit">C283</td>
				<td>C9 2C</td>
				<td class="fit">CMP #$2C</td><td rowspan="2"><p>Check if it is a comma (&quot;,&quot;). If not,
branch back to PR10 to get next command
string character.</p>
</td></tr>
				<tr><td></td><td class="fit">C285</td>
				<td>D0 E4</td>
				<td class="fit">BNE $C26B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C287</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="5"><p>Transfer character count from .Y to .A
and store in the file table, FILTAB+1,X
($027B,X) to indicate where the file
name ends. Load .A with the pattern flag
PATFLG and AND it with $7F. If the
result is zero (no wild cards found) ,
branch to PR28.</p>
</td></tr>
				<tr><td></td><td class="fit">C288</td>
				<td>9D 7B 02</td>
				<td class="fit">STA $027B,X</td></tr>
				<tr><td></td><td class="fit">C28B</td>
				<td>AD 8A 02</td>
				<td class="fit">LDA $028A</td></tr>
				<tr><td></td><td class="fit">C28E</td>
				<td>29 7F</td>
				<td class="fit">AND #$7F</td></tr>
				<tr><td></td><td class="fit">C290</td>
				<td>F0 07</td>
				<td class="fit">BEQ $C299</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C292</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="3"><p>Wild cards were present, so store $80
in PATTYP,X ($E7,X) to indicate this.
Also store $80 into PATFLG to zero the
count of wild cards but indicate that
there are wild cards in the string.</p>
</td></tr>
				<tr><td></td><td class="fit">C294</td>
				<td>95 E7</td>
				<td class="fit">STA $E7,X</td></tr>
				<tr><td></td><td class="fit">C296</td>
				<td>8D 8A 02</td>
				<td class="fit">STA $028A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PR28</td><td class="fit">C299</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Increment .X (counts number of files &amp;
points into FILTAB) and compare it to
$04 (the maximum number of file names
allowed in a command string). If the
maximum has not been exceeded, branch
back to PR10 to continue the scan.</p>
</td></tr>
				<tr><td></td><td class="fit">C29A</td>
				<td>E0 04</td>
				<td class="fit">CPX #$04</td></tr>
				<tr><td></td><td class="fit">C29C</td>
				<td>90 CD</td>
				<td class="fit">BCC $C26B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PR30</td><td class="fit">C29E</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00 to indicate that the
desired character was not found.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PR35</td><td class="fit">C2A0</td>
				<td>AD 74 02</td>
				<td class="fit">LDA $0274</td><td rowspan="5"><p>Store a copy of the command size, CMDSIZ
($0274) into the file table, FILTAB+1,X
($027B,X). Load the pattern flag, PATFLG
and AND it with $7F. If the result is 0,
no wild cards have been found so branch
to PR4 0.</p>
</td></tr>
				<tr><td></td><td class="fit">C2A3</td>
				<td>9D 7B 02</td>
				<td class="fit">STA $027B,X</td></tr>
				<tr><td></td><td class="fit">C2A6</td>
				<td>AD 8A 02</td>
				<td class="fit">LDA $028A</td></tr>
				<tr><td></td><td class="fit">C2A9</td>
				<td>29 7F</td>
				<td class="fit">AND #$7F</td></tr>
				<tr><td></td><td class="fit">C2AB</td>
				<td>F0 04</td>
				<td class="fit">BEQ $C2B1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C2AD</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Wild cards were present, so store $80
in PATTYP,X ($E7,X) to indicate this.</p>
</td></tr>
				<tr><td></td><td class="fit">C2AF</td>
				<td>95 E7</td>
				<td class="fit">STA $E7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PR40</td><td class="fit">C2B1</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Transfer character count from .Y to .A.
This sets the Z flag if the desired
character has not been found.</p>
</td></tr>
				<tr><td></td><td class="fit">C2B2</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMDSET</td><td class="fit">C2B3</td>
				<td>A4 A3</td>
				<td class="fit">LDY $A3</td><td rowspan="2"><p>Initialize command tables &amp; pointers
Find length of command string and zero
all variables and pointers.
Load .Y from BUFTAB+CBPTR ($A3). This is
the length of the command that was sent
from the computer. If .Y=0, branch to
CS08 ($C2CB) .</p>
</td></tr>
				<tr><td></td><td class="fit">C2B5</td>
				<td>F0 14</td>
				<td class="fit">BEQ $C2CB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C2B7</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement .Y and if .Y=0, branch to CS07
($C2CA) .</p>
</td></tr>
				<tr><td></td><td class="fit">C2B8</td>
				<td>F0 10</td>
				<td class="fit">BEQ $C2CA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C2BA</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td><td rowspan="3"><p>Load .A with the character from the
command buffer, CMDBUF,Y ($0200, Y) and
see if it is a carriage return ($0D). If
it is, branch to CS08 ($C2CB) .</p>
</td></tr>
				<tr><td></td><td class="fit">C2BD</td>
				<td>C9 0D</td>
				<td class="fit">CMP #$0D</td></tr>
				<tr><td></td><td class="fit">C2BF</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $C2CB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C2C1</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="5"><p>Decrement .Y and load the next character
from the command buffer. If this is a
carriage return ($0D). branch to CS08
($C2CB). If not, increment .Y</p>
</td></tr>
				<tr><td></td><td class="fit">C2C2</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td></tr>
				<tr><td></td><td class="fit">C2C5</td>
				<td>C9 0D</td>
				<td class="fit">CMP #$0D</td></tr>
				<tr><td></td><td class="fit">C2C7</td>
				<td>F0 02</td>
				<td class="fit">BEQ $C2CB</td></tr>
				<tr><td></td><td class="fit">C2C9</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CS07</td><td class="fit">C2CA</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y pointer into command buffer</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CS08</td><td class="fit">C2CB</td>
				<td>8C 74 02</td>
				<td class="fit">STY $0274</td><td rowspan="4"><p>Store length of command (.Y) in CMDSIZ
($027B). Compare length (.Y) with the
maximum allowable length ($2A) to set
the carry flag. Load .Y with $FF. If
command length was OK, branch to CMDRST.</p>
</td></tr>
				<tr><td></td><td class="fit">C2CE</td>
				<td>C0 2A</td>
				<td class="fit">CPY #$2A</td></tr>
				<tr><td></td><td class="fit">C2D0</td>
				<td>A0 FF</td>
				<td class="fit">LDY #$FF</td></tr>
				<tr><td></td><td class="fit">C2D2</td>
				<td>90 08</td>
				<td class="fit">BCC $C2DC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C2D4</td>
				<td>8C 2A 02</td>
				<td class="fit">STY $022A</td><td rowspan="3"><p>Command over-size so set command number
($022A) to $FF, load .A with $32 to
indicate a TOO LONG ERROR and exit with
a JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">C2D7</td>
				<td>A9 32</td>
				<td class="fit">LDA #$32</td></tr>
				<tr><td></td><td class="fit">C2D9</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMDRST</td><td class="fit">C2DC</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="23"><p>Zero all important variables &amp; pointers:</p>
<pre><code>BUFTAB+CBPTR ($A3)
FILTBL 	($027A-7F)
ENTSEC 	($00D8-DC)
ENTIND 	($00DD-E1)
FILDRV 	($00E2-E6)
PATTYP 	($00E7-EB)
FILTRK 	($0280-84)
FILSEC 	($0285-89)
REC 	($0258)
TYPE	($024A)
TYPFLG 	($0296)
F1PTR	($00D3)
F2PTR	($0279)
PATFLG 	($028A)
ERWORD	($026C)</code></pre>
</td></tr>
				<tr><td></td><td class="fit">C2DE</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">C2DF</td>
				<td>85 A3</td>
				<td class="fit">STA $A3</td></tr>
				<tr><td></td><td class="fit">C2E1</td>
				<td>8D 58 02</td>
				<td class="fit">STA $0258</td></tr>
				<tr><td></td><td class="fit">C2E4</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td></tr>
				<tr><td></td><td class="fit">C2E7</td>
				<td>8D 96 02</td>
				<td class="fit">STA $0296</td></tr>
				<tr><td></td><td class="fit">C2EA</td>
				<td>85 D3</td>
				<td class="fit">STA $D3</td></tr>
				<tr><td></td><td class="fit">C2EC</td>
				<td>8D 79 02</td>
				<td class="fit">STA $0279</td></tr>
				<tr><td></td><td class="fit">C2EF</td>
				<td>8D 77 02</td>
				<td class="fit">STA $0277</td></tr>
				<tr><td></td><td class="fit">C2F2</td>
				<td>8D 78 02</td>
				<td class="fit">STA $0278</td></tr>
				<tr><td></td><td class="fit">C2F5</td>
				<td>8D 8A 02</td>
				<td class="fit">STA $028A</td></tr>
				<tr><td></td><td class="fit">C2F8</td>
				<td>8D 6C 02</td>
				<td class="fit">STA $026C</td></tr>
				<tr><td></td><td class="fit">C2FB</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td></tr>
				<tr><td></td><td class="fit">C2FD</td>
				<td>9D 79 02</td>
				<td class="fit">STA $0279,X</td></tr>
				<tr><td></td><td class="fit">C300</td>
				<td>95 D7</td>
				<td class="fit">STA $D7,X</td></tr>
				<tr><td></td><td class="fit">C302</td>
				<td>95 DC</td>
				<td class="fit">STA $DC,X</td></tr>
				<tr><td></td><td class="fit">C304</td>
				<td>95 E1</td>
				<td class="fit">STA $E1,X</td></tr>
				<tr><td></td><td class="fit">C306</td>
				<td>95 E6</td>
				<td class="fit">STA $E6,X</td></tr>
				<tr><td></td><td class="fit">C308</td>
				<td>9D 7F 02</td>
				<td class="fit">STA $027F,X</td></tr>
				<tr><td></td><td class="fit">C30B</td>
				<td>9D 84 02</td>
				<td class="fit">STA $0284,X</td></tr>
				<tr><td></td><td class="fit">C30E</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">C30F</td>
				<td>D0 EC</td>
				<td class="fit">BNE $C2FD</td></tr>
				<tr><td></td><td class="fit">C311</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set first drive &amp; table pointers</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ONEDRV</td><td class="fit">C312</td>
				<td>AD 78 02</td>
				<td class="fit">LDA $0278</td><td rowspan="5"><p>Change pointer to end of the first file
name (F1CNT; $0277) to point to the end
of the second file name (use value from
F2CNT; $0278). Store $01 in F2CNT and in
F2PTR ($0279) to clear these variables</p>
</td></tr>
				<tr><td></td><td class="fit">C315</td>
				<td>8D 77 02</td>
				<td class="fit">STA $0277</td></tr>
				<tr><td></td><td class="fit">C318</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">C31A</td>
				<td>8D 78 02</td>
				<td class="fit">STA $0278</td></tr>
				<tr><td></td><td class="fit">C31D</td>
				<td>8D 79 02</td>
				<td class="fit">STA $0279</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ALLDRS</td><td class="fit">C320</td>
				<td>AC 8E 02</td>
				<td class="fit">LDY $028E</td><td rowspan="2"><p>Set up all drives from F2CNT:
Load .Y with last drive used from LSTDRV
($028E) and .X with $00.</p>
</td></tr>
				<tr><td></td><td class="fit">C323</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AD10</td><td class="fit">C325</td>
				<td>86 D3</td>
				<td class="fit">STX $D3</td><td rowspan="2"><p>Save .X into F1PTR ($D3). Load .A from
FILTAB,X ($027A,X) so it points to the
start of the Xth file specified in the
command string.</p>
</td></tr>
				<tr><td></td><td class="fit">C327</td>
				<td>BD 7A 02</td>
				<td class="fit">LDA $027A,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C32A</td>
				<td>20 3C C3</td>
				<td class="fit">JSR $C33C</td><td rowspan="1"><p>JSR to SETDRV ($C33C) to set drive #.
On return .Y contains the drive number
specified in the command or the default.
NOTE: Bits represent drives (If bit 7
set, use default. Bit = drive #0/1)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C32D</td>
				<td>A6 D3</td>
				<td class="fit">LDX $D3</td><td rowspan="4"><p>Recover .X pointer from F1PTR. Store .A
in FILTAB,X ($027A,X). Move drive # from
.Y to .A and store in FILDRV, X ($027A,X)</p>
</td></tr>
				<tr><td></td><td class="fit">C32F</td>
				<td>9D 7A 02</td>
				<td class="fit">STA $027A,X</td></tr>
				<tr><td></td><td class="fit">C332</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">C333</td>
				<td>95 E2</td>
				<td class="fit">STA $E2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C335</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="4"><p>Increment .X pointer and compare it to
F2CNT ($0278) to see if any more files
were specified. If more, branch back to
AD10 to do the next one. If not, RTS</p>
</td></tr>
				<tr><td></td><td class="fit">C336</td>
				<td>EC 78 02</td>
				<td class="fit">CPX $0278</td></tr>
				<tr><td></td><td class="fit">C339</td>
				<td>90 EA</td>
				<td class="fit">BCC $C325</td></tr>
				<tr><td></td><td class="fit">C33B</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETDRV</td><td class="fit">C33C</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Set drive # from text or default to
On entry and exit .A is an index into
the command buffer.
On entry .Y is the default drive #. On
exit it is the drive specified or the
default drive.
Move pointer into command buffer from
.A to .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C33D</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00 to ensure that the
1541' s default drive is ALWAYS DRIVE #0</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C33F</td>
				<td>A9 3A</td>
				<td class="fit">LDA #$3A</td><td rowspan="1"><p>Load .A with $3A (:) to prepare to hunt
for a colon (drive # is just before :).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C341</td>
				<td>DD 01 02</td>
				<td class="fit">CMP $0201,X</td><td rowspan="2"><p>Check for colon in command string at
CMDBUF+1,X ($0201, X). Picks up syntax:
X#: FILENAME as in SO: JUNK
If found, branch to SD40.</p>
</td></tr>
				<tr><td></td><td class="fit">C344</td>
				<td>F0 0C</td>
				<td class="fit">BEQ $C352</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C346</td>
				<td>DD 00 02</td>
				<td class="fit">CMP $0200,X</td><td rowspan="2"><p>Check for colon in command string at
CMDBUF,X ($0200, X). Picks up default
drive syntax as in S:JUNK
If colon NOT found, branch to SD40.</p>
</td></tr>
				<tr><td></td><td class="fit">C349</td>
				<td>D0 16</td>
				<td class="fit">BNE $C361</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C34B</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="1"><p>Colon found so increment pointer (.X) so
it points to the first character in the
filename.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SD20</td><td class="fit">C34C</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer .Y to .A to set up the default
drive</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SD22</td><td class="fit">C34D</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="1"><p>AND .A with $01 to ensure drive number
in ASCII form ($30 or $31) is converted
to $00 or $01.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SD24</td><td class="fit">C34F</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="3"><p>Transfer .A to .Y to restore drive #.
Transfer .X to .A to restore index into
command string and exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">C350</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">C351</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SD40</td><td class="fit">C352</td>
				<td>BD 00 02</td>
				<td class="fit">LDA $0200,X</td><td rowspan="1"><p>Set drive # from command string with the
syntax: X#: FILENAME. On entry .X points
to the # in the command string.
Load .A with the drive number (in ASCII)
from CMDBUF,X ($0200, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C355</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment .X twice so it points to the
first character in the file name.</p>
</td></tr>
				<tr><td></td><td class="fit">C356</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C357</td>
				<td>C9 30</td>
				<td class="fit">CMP #$30</td><td rowspan="2"><p>Compare .A (drive number) to $30 (dr#0) .
If equal, branch back to SD22 ($C34D)</p>
</td></tr>
				<tr><td></td><td class="fit">C359</td>
				<td>F0 F2</td>
				<td class="fit">BEQ $C34D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C35B</td>
				<td>C9 31</td>
				<td class="fit">CMP #$31</td><td rowspan="3"><p>Compare .A (drive number) to $31 (dr#l) .
If equal, branch back to SD22 ($C34D)
If not equal, must be default drive so
branch back to SD20 ($C34C) .</p>
</td></tr>
				<tr><td></td><td class="fit">C35D</td>
				<td>F0 EE</td>
				<td class="fit">BEQ $C34D</td></tr>
				<tr><td></td><td class="fit">C35F</td>
				<td>D0 EB</td>
				<td class="fit">BNE $C34C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SD50</td><td class="fit">C361</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Set drive # from command string with the
syntax: X#,FILE or xx=FILE.
Transfer the drive number from .Y to .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C362</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td><td rowspan="3"><p>OR .A with $80 to set the default drive
bit and then AND the result with $81 to
mask off any odd bits. Branch back to
SD24 ($C34F) to terminate routine.</p>
</td></tr>
				<tr><td></td><td class="fit">C364</td>
				<td>29 81</td>
				<td class="fit">AND #$81</td></tr>
				<tr><td></td><td class="fit">C366</td>
				<td>D0 E7</td>
				<td class="fit">BNE $C34F</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set drive # from any configuration</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETANY</td><td class="fit">C368</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set IMAGE ($028B) to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">C36A</td>
				<td>8D 8B 02</td>
				<td class="fit">STA $028B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C36D</td>
				<td>AC 7A 02</td>
				<td class="fit">LDY $027A</td><td rowspan="1"><p>Load .Y from FILTBL ($027A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SA05</td><td class="fit">C370</td>
				<td>B1 A3</td>
				<td class="fit">LDA ($A3),Y</td><td rowspan="2"><p>Load .A with the (CB) ,Y character from
the command string and JSR to TST0V1 to
test for a &quot;0&quot; or &quot;1&quot; .</p>
</td></tr>
				<tr><td></td><td class="fit">C372</td>
				<td>20 BD C3</td>
				<td class="fit">JSR $C3BD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C375</td>
				<td>10 11</td>
				<td class="fit">BPL $C388</td><td rowspan="1"><p>On return .A contains $00 or $01 if the
drive was specified. If not specified,
.A is $80 or $81. If the drive number
was given, branch to SA20 ($C388) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C377</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment the pointer into the command
string (.Y). Compare the pointer value
to the command length (CMDSIZ; $0274)
to see if we are at the end. If we are,
branch to SA10 ($C383) .</p>
</td></tr>
				<tr><td></td><td class="fit">C378</td>
				<td>CC 74 02</td>
				<td class="fit">CPY $0274</td></tr>
				<tr><td></td><td class="fit">C37B</td>
				<td>B0 06</td>
				<td class="fit">BCS $C383</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C37D</td>
				<td>AC 74 02</td>
				<td class="fit">LDY $0274</td><td rowspan="3"><p>If not &quot;0&quot; or &quot;1&quot;, set the pointer (.Y)
to the end of the command less one (so
it points to the last character before
the RETURN to pick up things like V0)
and loop back to SA05 ($C370).</p>
</td></tr>
				<tr><td></td><td class="fit">C380</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C381</td>
				<td>D0 ED</td>
				<td class="fit">BNE $C370</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SA10</td><td class="fit">C383</td>
				<td>CE 8B 02</td>
				<td class="fit">DEC $028B</td><td rowspan="2"><p>Decrement IMAGE (becomes $FF) to flag a
default drive status and load .A with a
$00 to ensure default to on the 1541.</p>
</td></tr>
				<tr><td></td><td class="fit">C386</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SA20</td><td class="fit">C388</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the drive number in .A with $01, and
store the result in the current drive
number, DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">C38A</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C38C</td>
				<td>4C 00 C1</td>
				<td class="fit">JMP $C100</td><td rowspan="1"><p>Exit with a JMP to SETLDS ($C100) to
turn on the drive active light.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Toggle drive number</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TOGDRV</td><td class="fit">C38F</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="5"><p>Load .A with current drive number from
DRVNUM ($7F). EOR it with $01 to flip
bit #0, AND it with $01 to mask off the
bits 1-7, and store the result back in
DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">C391</td>
				<td>49 01</td>
				<td class="fit">EOR #$01</td></tr>
				<tr><td></td><td class="fit">C393</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">C395</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
				<tr><td></td><td class="fit">C397</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set pointers to one file stream and check type</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FS1SET</td><td class="fit">C398</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Zero .Y and load .A with the pointer to
the end of file name 1 (F1CNT; $0277) .</p>
</td></tr>
				<tr><td></td><td class="fit">C39A</td>
				<td>AD 77 02</td>
				<td class="fit">LDA $0277</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C39D</td>
				<td>CD 78 02</td>
				<td class="fit">CMP $0278</td><td rowspan="2"><p>Compare .A to the pointer to the end of
file name 2 (F2CNT; $0278). If equal,
there is no second file so branch to
FS15 ($C3B8).</p>
</td></tr>
				<tr><td></td><td class="fit">C3A0</td>
				<td>F0 16</td>
				<td class="fit">BEQ $C3B8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C3A2</td>
				<td>CE 78 02</td>
				<td class="fit">DEC $0278</td><td rowspan="4"><p>Decrement F2CNT and load .Y with its
value. Load .A with the pointer to the
filetype in the command string from
FILTAB,Y ($027A,Y). Transfer this value
to .Y and use it to load the file type
into .A from the command string (CB) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">C3A5</td>
				<td>AC 78 02</td>
				<td class="fit">LDY $0278</td></tr>
				<tr><td></td><td class="fit">C3A8</td>
				<td>B9 7A 02</td>
				<td class="fit">LDA $027A,Y</td></tr>
				<tr><td></td><td class="fit">C3AB</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C3AC</td>
				<td>B1 A3</td>
				<td class="fit">LDA ($A3),Y</td><td rowspan="2"><p>Load .Y with $04 (the number of file
types less 1) .</p>
</td></tr>
				<tr><td></td><td class="fit">C3AE</td>
				<td>A0 04</td>
				<td class="fit">LDY #$04</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FS10</td><td class="fit">C3B0</td>
				<td>D9 BB FE</td>
				<td class="fit">CMP $FEBB,Y</td><td rowspan="4"><p>Loop to compare the file type in .A to
the list of possible file types ,TYPLST,Y
When a match occurs, branch to FS15
($C3B8). If no match found this time,
decrement .Y and, if there are any file
types left, loop back to FS10. NOTE: if
no match occurs, file assumed to be DEL.</p>
</td></tr>
				<tr><td></td><td class="fit">C3B3</td>
				<td>F0 03</td>
				<td class="fit">BEQ $C3B8</td></tr>
				<tr><td></td><td class="fit">C3B5</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C3B6</td>
				<td>D0 F8</td>
				<td class="fit">BNE $C3B0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FS15</td><td class="fit">C3B8</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="3"><p>Transfer file type from .Y to .A and
store in TYPFLG ($0296).</p>
</td></tr>
				<tr><td></td><td class="fit">C3B9</td>
				<td>8D 96 02</td>
				<td class="fit">STA $0296</td></tr>
				<tr><td></td><td class="fit">C3BC</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test if character in .A is ASCII or 1</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TST0V1</td><td class="fit">C3BD</td>
				<td>C9 30</td>
				<td class="fit">CMP #$30</td><td rowspan="5"><p>Compare .A to ASCII &quot;0&quot; ($30) and then
to ASCII &quot;1&quot; ($31). If a match in either
case, branch to T0V1.
OR .A with $80 to set bit 7 to indicate
no match was found.</p>
</td></tr>
				<tr><td></td><td class="fit">C3BF</td>
				<td>F0 06</td>
				<td class="fit">BEQ $C3C7</td></tr>
				<tr><td></td><td class="fit">C3C1</td>
				<td>C9 31</td>
				<td class="fit">CMP #$31</td></tr>
				<tr><td></td><td class="fit">C3C3</td>
				<td>F0 02</td>
				<td class="fit">BEQ $C3C7</td></tr>
				<tr><td></td><td class="fit">C3C5</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">T0V1</td><td class="fit">C3C7</td>
				<td>29 81</td>
				<td class="fit">AND #$81</td><td rowspan="2"><p>AND .A with $81 to convert ASCII to HEX
and preserve bit 7.</p>
</td></tr>
				<tr><td></td><td class="fit">C3C9</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Determine optimal search for LOOKUP and FINFIL</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPTSCH</td><td class="fit">C3CA</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="5"><p>Zero TEMP ($6F) and DRVFLG ($028D) and
push $00 onto the stack. Load .X with
value from F2CNT ($0278).
Note: TEMP is the drive mask.</p>
</td></tr>
				<tr><td></td><td class="fit">C3CC</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">C3CE</td>
				<td>8D 8D 02</td>
				<td class="fit">STA $028D</td></tr>
				<tr><td></td><td class="fit">C3D1</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">C3D2</td>
				<td>AE 78 02</td>
				<td class="fit">LDX $0278</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS10</td><td class="fit">C3D5</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="7"><p>Pull .A from the stack and OR it with
the value in TEMP ($6F). Push the result
back onto the stack.</p>
<p>Load .A with $01 and store this value in TEMP.
Decrement .X (pointer into file table).</p>
<p>If no files left (.X=$FF), branch to $OS30.</p>
</td></tr>
				<tr><td></td><td class="fit">C3D6</td>
				<td>05 6F</td>
				<td class="fit">ORA $6F</td></tr>
				<tr><td></td><td class="fit">C3D8</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">C3D9</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">C3DB</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">C3DD</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">C3DE</td>
				<td>30 0F</td>
				<td class="fit">BMI $C3EF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C3E0</td>
				<td>B5 E2</td>
				<td class="fit">LDA $E2,X</td><td rowspan="4"><p>Load .A with the drive for the file from
FILDRV,X ($E2,X).</p>
<p>If this file uses the default drive (bit 7 set), branch to
OS15. Do two ASL's on TEMP ($6F).</p>
</td></tr>
				<tr><td></td><td class="fit">C3E2</td>
				<td>10 04</td>
				<td class="fit">BPL $C3E8</td></tr>
				<tr><td></td><td class="fit">C3E4</td>
				<td>06 6F</td>
				<td class="fit">ASL $6F</td></tr>
				<tr><td></td><td class="fit">C3E6</td>
				<td>06 6F</td>
				<td class="fit">ASL $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS15</td><td class="fit">C3E8</td>
				<td>4A</td>
				<td class="fit">LSR</td><td rowspan="2"><p>Do one LSR on .A. If drive number in .A
was 1, the carry bit is set so branch
back to OS10.</p>
</td></tr>
				<tr><td></td><td class="fit">C3E9</td>
				<td>90 EA</td>
				<td class="fit">BCC $C3D5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C3EB</td>
				<td>06 6F</td>
				<td class="fit">ASL $6F</td><td rowspan="2"><p>Since drive number was 0, do one ASL on
TEMP ($6F) and branch back to OS10.</p>
</td></tr>
				<tr><td></td><td class="fit">C3ED</td>
				<td>D0 E6</td>
				<td class="fit">BNE $C3D5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS30</td><td class="fit">C3EF</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="9"><p>Pull .A from the stack and transfer this
value to .X. Use this value as an index
and load .A with a value from the search
table, SCHTBL-1,X ($C43F,X).</p>
<p>Push this value onto the stack, AND it with $03,
and store the result in DRVCNT ($028C).</p>
<p>Pull the original value off the stack
and do an ASL. If bit 7 is not set,
branch to OS40.</p>
</td></tr>
				<tr><td></td><td class="fit">C3F0</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">C3F1</td>
				<td>BD 3F C4</td>
				<td class="fit">LDA $C43F,X</td></tr>
				<tr><td></td><td class="fit">C3F4</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">C3F5</td>
				<td>29 03</td>
				<td class="fit">AND #$03</td></tr>
				<tr><td></td><td class="fit">C3F7</td>
				<td>8D 8C 02</td>
				<td class="fit">STA $028C</td></tr>
				<tr><td></td><td class="fit">C3FA</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">C3FB</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">C3FC</td>
				<td>10 3E</td>
				<td class="fit">BPL $C43C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C3FE</td>
				<td>A5 E2</td>
				<td class="fit">LDA $E2</td><td rowspan="1"><p>If bit 7 was set, load A. with the value
from FILDRV ($E2) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS35</td><td class="fit">C400</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="4"><p>AND .A with $01 and store the result in
DRVNUM ($7F). Load .A with DRVCNT ( $028C)
and if $00, only one drive is addressed
so branch to OS60.</p>
</td></tr>
				<tr><td></td><td class="fit">C402</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
				<tr><td></td><td class="fit">C404</td>
				<td>AD 8C 02</td>
				<td class="fit">LDA $028C</td></tr>
				<tr><td></td><td class="fit">C407</td>
				<td>F0 2B</td>
				<td class="fit">BEQ $C434</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C409</td>
				<td>20 3D C6</td>
				<td class="fit">JSR $C63D</td><td rowspan="7"><p>JSR to AUTOI ($C63D) to check the drive
status and initialize it if necessary.
On return, branch to OS70 if the drive
is ready (. A=0) .</p>
</td></tr>
				<tr><td></td><td class="fit">C40C</td>
				<td>F0 12</td>
				<td class="fit">BEQ $C420</td></tr>
				<tr><td></td><td class="fit">C40E</td>
				<td>20 8F C3</td>
				<td class="fit">JSR $C38F</td></tr>
				<tr><td></td><td class="fit">C411</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">C413</td>
				<td>8D 8C 02</td>
				<td class="fit">STA $028C</td></tr>
				<tr><td></td><td class="fit">C416</td>
				<td>20 3D C6</td>
				<td class="fit">JSR $C63D</td></tr>
				<tr><td></td><td class="fit">C419</td>
				<td>F0 1E</td>
				<td class="fit">BEQ $C439</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS45</td><td class="fit">C41B</td>
				<td>A9 74</td>
				<td class="fit">LDA #$74</td><td rowspan="2"><p>Drive is not ready so load .A with $74
to indicate the drive is not ready and
JSR to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">C41D</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS50</td><td class="fit">C420</td>
				<td>20 8F C3</td>
				<td class="fit">JSR $C38F</td><td rowspan="6"><p>JSR to TOGDRV ($C38F) to switch drives
and JSR to AUTOI ($C63D) to check this
drive's status and init it if necessary.
On return, save the processor status on
the stack. JSR to TOGDRV to switch back
to the first drive. On return, pull the
status back off the stack. If the second
drive is active, branch to OS70.</p>
</td></tr>
				<tr><td></td><td class="fit">C423</td>
				<td>20 3D C6</td>
				<td class="fit">JSR $C63D</td></tr>
				<tr><td></td><td class="fit">C426</td>
				<td>08</td>
				<td class="fit">PHP</td></tr>
				<tr><td></td><td class="fit">C427</td>
				<td>20 8F C3</td>
				<td class="fit">JSR $C38F</td></tr>
				<tr><td></td><td class="fit">C42A</td>
				<td>28</td>
				<td class="fit">PLP</td></tr>
				<tr><td></td><td class="fit">C42B</td>
				<td>F0 0C</td>
				<td class="fit">BEQ $C439</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C42D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Since second drive is not active, set
DRVCNT ($020C) to $00 to indicate only
one drive addressed and branch to OS70.</p>
</td></tr>
				<tr><td></td><td class="fit">C42F</td>
				<td>8D 8C 02</td>
				<td class="fit">STA $028C</td></tr>
				<tr><td></td><td class="fit">C432</td>
				<td>F0 05</td>
				<td class="fit">BEQ $C439</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS60</td><td class="fit">C434</td>
				<td>20 3D C6</td>
				<td class="fit">JSR $C63D</td><td rowspan="2"><p>JSR to AUTOI ($C63D) to check the drive
status and initialize it if necessary.
On return, branch to OS45 if the drive
is NOT ready (.AO0) .</p>
</td></tr>
				<tr><td></td><td class="fit">C437</td>
				<td>D0 E2</td>
				<td class="fit">BNE $C41B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS70</td><td class="fit">C439</td>
				<td>4C 00 C1</td>
				<td class="fit">JMP $C100</td><td rowspan="1"><p>Teminate routine with a JMP to SETLDS
($C100) to turn on the drive active LEDs</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OS45</td><td class="fit">C43C</td>
				<td>2A</td>
				<td class="fit">ROL</td><td rowspan="2"><p>Do a ROL on the value in .A and JMP to
OS35 ($C400).</p>
</td></tr>
				<tr><td></td><td class="fit">C43D</td>
				<td>4C 00 C4</td>
				<td class="fit">JMP $C400</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCHTBL</td><td class="fit">C440</td>
				<td>00 80 41 01 01 01 01 81 81 81 81 42 42 42 42</td>
				<td class="fit"></td><td rowspan="1"><h1>Search Table</h1>
<pre><code>BYTES $00, $80, $41
BYTES $01, $01, $01, $01
BYTES $81, $81, $81, $81
BYTES $42, $42, $42, $42</code></pre>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Look up all files in command string in the directory and fill tables with info</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LOOKUP</td><td class="fit">C44F</td>
				<td>20 CA C3</td>
				<td class="fit">JSR $C3CA</td><td rowspan="1"><p>JSR to OPTSCH to find optimal search
pattern and turn on drive active LEDs.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LK05</td><td class="fit">C452</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Store $00 in DELIND ($0292). to indicate
that we are NOT looking for a deleted or
unused directory entry. But, for one or
more specific file names. JSR to SRCHST
($C5AC) to start the search process.</p>
</td></tr>
				<tr><td></td><td class="fit">C454</td>
				<td>8D 92 02</td>
				<td class="fit">STA $0292</td></tr>
				<tr><td></td><td class="fit">C457</td>
				<td>20 AC C5</td>
				<td class="fit">JSR $C5AC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C45A</td>
				<td>D0 19</td>
				<td class="fit">BNE $C475</td><td rowspan="1"><p>On return, branch to LK25 if a valid
file name was found (Z flag =0)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LK10</td><td class="fit">C45C</td>
				<td>CE 8C 02</td>
				<td class="fit">DEC $028C</td><td rowspan="2"><p>Since no file name was found, decrement
DRVCNT ($028C). the number of drive
searches to be made. If any more left
(DRVCNT &gt;= 0), branch to LK15.</p>
</td></tr>
				<tr><td></td><td class="fit">C45F</td>
				<td>10 01</td>
				<td class="fit">BPL $C462</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C461</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Since there are no more drive searches
to be done, exit with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LK15</td><td class="fit">C462</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="5"><p>Store $01 in DRVFLG ($028D) and JSR to
TOGDRV ($C38F) to switch drives. JSR to
SETLDS ($C100) to turn on the other LED.
Then JMP back to LK05 to begin the
search on the other drive.</p>
</td></tr>
				<tr><td></td><td class="fit">C464</td>
				<td>8D 8D 02</td>
				<td class="fit">STA $028D</td></tr>
				<tr><td></td><td class="fit">C467</td>
				<td>20 8F C3</td>
				<td class="fit">JSR $C38F</td></tr>
				<tr><td></td><td class="fit">C46A</td>
				<td>20 00 C1</td>
				<td class="fit">JSR $C100</td></tr>
				<tr><td></td><td class="fit">C46D</td>
				<td>4C 52 C4</td>
				<td class="fit">JMP $C452</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LK20</td><td class="fit">C470</td>
				<td>20 17 C6</td>
				<td class="fit">JSR $C617</td><td rowspan="1"><p>JSR to SEARCH ($C617) to read the next
valid file name in the directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C473</td>
				<td>F0 10</td>
				<td class="fit">BEQ $C485</td><td rowspan="1"><p>On return, branch to LK30 to abandon the
search if a valid file name was NOT
found (Z flag = 1) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LK25</td><td class="fit">C475</td>
				<td>20 D8 C4</td>
				<td class="fit">JSR $C4D8</td><td rowspan="1"><p>JSR to COMPAR ($C4D8) to compare the
list, of files found with list of those
required. On return, FOUND ($028F) is
if all files have NOT been found.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C478</td>
				<td>AD 8F 02</td>
				<td class="fit">LDA $028F</td><td rowspan="2"><p>Load .A with the value from FOUND. If
not all the files have been found yet,
branch to LK26 to continue the search.</p>
</td></tr>
				<tr><td></td><td class="fit">C47B</td>
				<td>F0 01</td>
				<td class="fit">BEQ $C47E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C47D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>All files have been found so exit from
the routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LK26</td><td class="fit">C47E</td>
				<td>AD 53 02</td>
				<td class="fit">LDA $0253</td><td rowspan="3"><p>Load .A with the value from ENTFND
($0253) to check if the most recent
compare found a match. If not (.A=$FF),
branch to LK20 to search directory for
another valid file name. If a match was
found, branch back to LK25 to try again.</p>
</td></tr>
				<tr><td></td><td class="fit">C481</td>
				<td>30 ED</td>
				<td class="fit">BMI $C470</td></tr>
				<tr><td></td><td class="fit">C483</td>
				<td>10 F0</td>
				<td class="fit">BPL $C475</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LK30</td><td class="fit">C485</td>
				<td>AD 8F 02</td>
				<td class="fit">LDA $028F</td><td rowspan="2"><p>Load .A with the value from FOUND. If
not all the files have been found yet,
branch to LK10 to continue the search.</p>
</td></tr>
				<tr><td></td><td class="fit">C488</td>
				<td>F0 D2</td>
				<td class="fit">BEQ $C45C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C48A</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>All files found so exit with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find next file name matching any file in stream &amp; return with entry stuffed into tables</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FFRE</td><td class="fit">C48B</td>
				<td>20 04 C6</td>
				<td class="fit">JSR $C604</td><td rowspan="1"><p>JSR to SRRE ($C604) to set up and read
in the next block of directory entries.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C48E</td>
				<td>F0 1A</td>
				<td class="fit">BEQ $C4AA</td><td rowspan="1"><p>If no files found, branch to FF10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C490</td>
				<td>D0 28</td>
				<td class="fit">BNE $C4BA</td><td rowspan="1"><p>If files were found, branch to FF25.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FF15</td><td class="fit">C492</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="4"><p>Store $01 in DRVFLG ($028D) and JSR to
TOGDRV ($C38F) to switch to the other
drive. JSR to SETLDS ($C100) to turn on
the new drive active light.</p>
</td></tr>
				<tr><td></td><td class="fit">C494</td>
				<td>8D 8D 02</td>
				<td class="fit">STA $028D</td></tr>
				<tr><td></td><td class="fit">C497</td>
				<td>20 8F C3</td>
				<td class="fit">JSR $C38F</td></tr>
				<tr><td></td><td class="fit">C49A</td>
				<td>20 00 C1</td>
				<td class="fit">JSR $C100</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find starting entry in the directory</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FFST</td><td class="fit">C49D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Store $00 in DELIND ($0292),to indicate
that we are NOT looking for a deleted or
unused directory entry. But, for one or
more specific file names. JSR to SRCHST
($C5AC) to start the search process.</p>
</td></tr>
				<tr><td></td><td class="fit">C49F</td>
				<td>8D 92 02</td>
				<td class="fit">STA $0292</td></tr>
				<tr><td></td><td class="fit">C4A2</td>
				<td>20 AC C5</td>
				<td class="fit">JSR $C5AC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4A5</td>
				<td>D0 13</td>
				<td class="fit">BNE $C4BA</td><td rowspan="1"><p>On return, branch to FF25 if a valid
file name was found (Z flag = 0)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4A7</td>
				<td>8D 8F 02</td>
				<td class="fit">STA $028F</td><td rowspan="1"><p>Store .A value in FOUND ($028F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FF10</td><td class="fit">C4AA</td>
				<td>AD 8F 02</td>
				<td class="fit">LDA $028F</td><td rowspan="2"><p>Load .A from FOUND ($028F) .If non-zero,
all files found so branch to FF40 &amp; exit</p>
</td></tr>
				<tr><td></td><td class="fit">C4AD</td>
				<td>D0 28</td>
				<td class="fit">BNE $C4D7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4AF</td>
				<td>CE 8C 02</td>
				<td class="fit">DEC $028C</td><td rowspan="3"><p>Since there is nothing more on this
drive, decrement DRVCNT by 1. If any
more drives left, branch to FF15 to try
the other drive. If none left, do an RTS</p>
</td></tr>
				<tr><td></td><td class="fit">C4B2</td>
				<td>10 DE</td>
				<td class="fit">BPL $C492</td></tr>
				<tr><td></td><td class="fit">C4B4</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Continue scan of directory</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDFIL</td><td class="fit">C4B5</td>
				<td>20 17 C6</td>
				<td class="fit">JSR $C617</td><td rowspan="1"><p>JSR to SEARCH ($C617) to retrieve the
next valid file name from the directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4B8</td>
				<td>F0 F0</td>
				<td class="fit">BEQ $C4AA</td><td rowspan="1"><p>On return, branch to FF10 if no more
entries available on this drive.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FF25</td><td class="fit">C4BA</td>
				<td>20 D8 C4</td>
				<td class="fit">JSR $C4D8</td><td rowspan="1"><p>JSR to COMPAR ($C4D8) to see if any of
the names found match the ones needed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4BD</td>
				<td>AE 53 02</td>
				<td class="fit">LDX $0253</td><td rowspan="4"><p>On return, load .X from ENTFND ($0253).
If a match on a name was found (.X&lt;128),
branch to FF30 to check the file type.
If no match found (.X&gt;127), load .A with
the value from FOUND ($028F) to check if
all files have been found. If not(.A=0),
branch back to FNDFIL to load another
name from the directory.</p>
</td></tr>
				<tr><td></td><td class="fit">C4C0</td>
				<td>10 07</td>
				<td class="fit">BPL $C4C9</td></tr>
				<tr><td></td><td class="fit">C4C2</td>
				<td>AD 8F 02</td>
				<td class="fit">LDA $028F</td></tr>
				<tr><td></td><td class="fit">C4C5</td>
				<td>F0 EE</td>
				<td class="fit">BEQ $C4B5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4C7</td>
				<td>D0 0E</td>
				<td class="fit">BNE $C4D7</td><td rowspan="1"><p>If .AO0, all files have been found so
branch to FF40 and exit with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FF30</td><td class="fit">C4C9</td>
				<td>AD 96 02</td>
				<td class="fit">LDA $0296</td><td rowspan="2"><p>Check the file type flag, TYPFLG ($0296) .
If it is $00, there is no file type
restriction so branch to FF40 and exit.</p>
</td></tr>
				<tr><td></td><td class="fit">C4CC</td>
				<td>F0 09</td>
				<td class="fit">BEQ $C4D7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4CE</td>
				<td>B5 E7</td>
				<td class="fit">LDA $E7,X</td><td rowspan="4"><p>Load the file pattern type from PATTYP,X
($E7,X), AND it with the file type mask#$07,
and compare it to the value in
TYPFLG ($0296). If the file types do not
match, branch back to FNDFIL to continue
the search.</p>
</td></tr>
				<tr><td></td><td class="fit">C4D0</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">C4D2</td>
				<td>CD 96 02</td>
				<td class="fit">CMP $0296</td></tr>
				<tr><td></td><td class="fit">C4D5</td>
				<td>D0 DE</td>
				<td class="fit">BNE $C4B5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FF40</td><td class="fit">C4D7</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Compare all file names in command list with each valid entry in directory.</h1>
<p>Any matches are tabulated.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">COMPAR</td><td class="fit">C4D8</td>
				<td>A2 FF</td>
				<td class="fit">LDX #$FF</td><td rowspan="6"><p>Set the found-entry flag, ENTFND ($0253)
to $FF and zero the pattern flag PATFLG
(S028A).</p>
<p>JSR to CMPCHK ($C589) to check
the file table for unfound files. If
there are unfound files (Z flag = 1),
branch to CP10 to begin comparing.</p>
</td></tr>
				<tr><td></td><td class="fit">C4DA</td>
				<td>8E 53 02</td>
				<td class="fit">STX $0253</td></tr>
				<tr><td></td><td class="fit">C4DD</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">C4DE</td>
				<td>8E 8A 02</td>
				<td class="fit">STX $028A</td></tr>
				<tr><td></td><td class="fit">C4E1</td>
				<td>20 89 C5</td>
				<td class="fit">JSR $C589</td></tr>
				<tr><td></td><td class="fit">C4E4</td>
				<td>F0 06</td>
				<td class="fit">BEQ $C4EC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP02</td><td class="fit">C4E6</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP05</td><td class="fit">C4E7</td>
				<td>20 94 C5</td>
				<td class="fit">JSR $C594</td><td rowspan="2"><p>JSR to CC10 ($C594) to set F2PTR ($0279)
to point to the next file needed on this
drive. On return, branch to CP02 to exit
if no more files needed on this drive.</p>
</td></tr>
				<tr><td></td><td class="fit">C4EA</td>
				<td>D0 FA</td>
				<td class="fit">BNE $C4E6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP10</td><td class="fit">C4EC</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="4"><p>Load .A with the current drive number
from DRVNUM ($7F) and EOR it with the
drive number specified for the file,
FILDRV,X ($E2,X). LSR the result. If the
carry flag is clear, the drive number is
correct for this file so branch to CP20
to find the name in the directory list.</p>
</td></tr>
				<tr><td></td><td class="fit">C4EE</td>
				<td>55 E2</td>
				<td class="fit">EOR $E2,X</td></tr>
				<tr><td></td><td class="fit">C4F0</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">C4F1</td>
				<td>90 0B</td>
				<td class="fit">BCC $C4FE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4F3</td>
				<td>29 40</td>
				<td class="fit">AND #$40</td><td rowspan="2"><p>AND the value in .A with $40 to check if
we are to use the default drive (NOTE:
$40 rather than $80 because of the LSR) .
If we can not use the default drive,
branch back to CP05 to set up the next
file name on our list of files needed.</p>
</td></tr>
				<tr><td></td><td class="fit">C4F5</td>
				<td>F0 F0</td>
				<td class="fit">BEQ $C4E7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C4F7</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="3"><p>Compare DRVCNT ($028C) with $02. If
equal. don't use default drive so branch
back to CP05.</p>
</td></tr>
				<tr><td></td><td class="fit">C4F9</td>
				<td>CD 8C 02</td>
				<td class="fit">CMP $028C</td></tr>
				<tr><td></td><td class="fit">C4FC</td>
				<td>F0 E9</td>
				<td class="fit">BEQ $C4E7</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>At this point we have a match on the drive numbers so check the directory entries to see if we can match a name.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP20</td><td class="fit">C4FE</td>
				<td>BD 7A 02</td>
				<td class="fit">LDA $027A,X</td><td rowspan="2"><p>Load .A with the pointer to the position
of the required file name from FILTBL,X
($027A,X) and transfer this value to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">C501</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C502</td>
				<td>20 A6 C6</td>
				<td class="fit">JSR $C6A6</td><td rowspan="3"><p>JSR to FNDLMT to find the end of the
command string. On return, load the
pointer into the directory buffer (.Y)
with $03 (so it points past the file
type, track and sector) and JMP to CP33.</p>
</td></tr>
				<tr><td></td><td class="fit">C505</td>
				<td>A0 03</td>
				<td class="fit">LDY #$03</td></tr>
				<tr><td></td><td class="fit">C507</td>
				<td>4C 1D C5</td>
				<td class="fit">JMP $C51D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP30</td><td class="fit">C50A</td>
				<td>BD 00 02</td>
				<td class="fit">LDA $0200,X</td><td rowspan="3"><p>Compare the .Xth character in the
command string (the required filename)
with the .Yth character in the directory
buffer (the directory entry). If equal ,
branch to CP32 to set up for the next
character.</p>
</td></tr>
				<tr><td></td><td class="fit">C50D</td>
				<td>D1 94</td>
				<td class="fit">CMP ($94),Y</td></tr>
				<tr><td></td><td class="fit">C50F</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $C51B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C511</td>
				<td>C9 3F</td>
				<td class="fit">CMP #$3F</td><td rowspan="2"><p>No exact match so check if the command
buffer character is a &quot;?&quot; which will
match any character. If not, branch to
to CP05 to try the next file name.</p>
</td></tr>
				<tr><td></td><td class="fit">C513</td>
				<td>D0 D2</td>
				<td class="fit">BNE $C4E7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C515</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Compare the character we just used from
the directory buffer with $A0 to see if
we've reached the end of the name. If
we have, branch to CP0 5 to try the next
file name.</p>
</td></tr>
				<tr><td></td><td class="fit">C517</td>
				<td>C9 A0</td>
				<td class="fit">CMP #$A0</td></tr>
				<tr><td></td><td class="fit">C519</td>
				<td>F0 CC</td>
				<td class="fit">BEQ $C4E7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP32</td><td class="fit">C51B</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment .X and .Y</p>
</td></tr>
				<tr><td></td><td class="fit">C51C</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP33</td><td class="fit">C51D</td>
				<td>EC 76 02</td>
				<td class="fit">CPX $0276</td><td rowspan="2"><p>Compare .X with the length of the
command string, LIMIT ($0276). If we are at the
at the end, branch to CP34.</p>
</td></tr>
				<tr><td></td><td class="fit">C520</td>
				<td>B0 09</td>
				<td class="fit">BCS $C52B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C522</td>
				<td>BD 00 02</td>
				<td class="fit">LDA $0200,X</td><td rowspan="3"><p>Check if the new character in the file
name, CMDBUF,X ($0200, X) is a &quot;*&quot;. If it
is, it matches everything so branch to
CP40 to tabulate this match.</p>
</td></tr>
				<tr><td></td><td class="fit">C525</td>
				<td>C9 2A</td>
				<td class="fit">CMP #$2A</td></tr>
				<tr><td></td><td class="fit">C527</td>
				<td>F0 0C</td>
				<td class="fit">BEQ $C535</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C529</td>
				<td>D0 DF</td>
				<td class="fit">BNE $C50A</td><td rowspan="1"><p>If not a &quot;*&quot;, branch to CP30 to keep on
matching.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP34</td><td class="fit">C52B</td>
				<td>C0 13</td>
				<td class="fit">CPY #$13</td><td rowspan="2"><p>Compare .Y to $13 to see if we are at
the end of the name in the directory.
If we are, branch to CP40 to tabulate.</p>
</td></tr>
				<tr><td></td><td class="fit">C52D</td>
				<td>B0 06</td>
				<td class="fit">BCS $C535</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C52F</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>If not at the limit, check the character
in the directory entry name. If it isn't
an $A0, we did not get to the end of the
name so branch back to CP05 to try again</p>
</td></tr>
				<tr><td></td><td class="fit">C531</td>
				<td>C9 A0</td>
				<td class="fit">CMP #$A0</td></tr>
				<tr><td></td><td class="fit">C533</td>
				<td>D0 B2</td>
				<td class="fit">BNE $C4E7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP40</td><td class="fit">C535</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="2"><p>The filenames match so keep track of it
by storing the pointer to the entry from
F2PNT ($0279) intoENTFND ($0253).</p>
</td></tr>
				<tr><td></td><td class="fit">C538</td>
				<td>8E 53 02</td>
				<td class="fit">STX $0253</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C53B</td>
				<td>B5 E7</td>
				<td class="fit">LDA $E7,X</td><td rowspan="3"><p>Get the file type pattern ($80. $81 , etc)
from PATTYP,X ($E7,X), AND it with $80,
and store it in PSTFLG.</p>
</td></tr>
				<tr><td></td><td class="fit">C53D</td>
				<td>29 80</td>
				<td class="fit">AND #$80</td></tr>
				<tr><td></td><td class="fit">C53F</td>
				<td>8D 8A 02</td>
				<td class="fit">STA $028A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C542</td>
				<td>AD 94 02</td>
				<td class="fit">LDA $0294</td><td rowspan="2"><p>Get the pointer to the directory entry
from INDEX ($0294) and store it in the
entry index, ENTIND,X ($DD,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">C545</td>
				<td>95 DD</td>
				<td class="fit">STA $DD,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C547</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Get the sector on track 18 on which the
entry is stored from SECTOR ($81) and
store it in, ENTSEC,X ($D8,X).</p>
</td></tr>
				<tr><td></td><td class="fit">C549</td>
				<td>95 D8</td>
				<td class="fit">STA $D8,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C54B</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="9"><p>Zero .Y and load .A with the file type
of this directory entry from (DIRBUF) ,Y
($94) ,Y. Increment .Y. Save the type on
the stack. AND the type with $40 to see
if this is a locked file type, and store
the result in TEMP ($6F). Pull the file
type off the stack and AND it with $DF
($FF-$20). If the result is &gt; 127 (the
replacement bit not set). branch to CP42</p>
</td></tr>
				<tr><td></td><td class="fit">C54D</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
				<tr><td></td><td class="fit">C54F</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">C550</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">C551</td>
				<td>29 40</td>
				<td class="fit">AND #$40</td></tr>
				<tr><td></td><td class="fit">C553</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">C555</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">C556</td>
				<td>29 DF</td>
				<td class="fit">AND #$DF</td></tr>
				<tr><td></td><td class="fit">C558</td>
				<td>30 02</td>
				<td class="fit">BMI $C55C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C55A</td>
				<td>09 20</td>
				<td class="fit">ORA #$20</td><td rowspan="1"><p>OR the result with $20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CP42</td><td class="fit">C55C</td>
				<td>29 27</td>
				<td class="fit">AND #$27</td><td rowspan="3"><p>AND the result with $27 and OR it with
the value stored in TEMP ($6F) and store
the final result back in TEMP.</p>
</td></tr>
				<tr><td></td><td class="fit">C55E</td>
				<td>05 6F</td>
				<td class="fit">ORA $6F</td></tr>
				<tr><td></td><td class="fit">C560</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C562</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="4"><p>Load .A with $80, AND .A with the file
pattern type from PATTYP,X ($E7,X), OR
the result with the value in TEMP ($6F) ,
and store the final result back in
PATTYP,X.</p>
</td></tr>
				<tr><td></td><td class="fit">C564</td>
				<td>35 E7</td>
				<td class="fit">AND $E7,X</td></tr>
				<tr><td></td><td class="fit">C566</td>
				<td>05 6F</td>
				<td class="fit">ORA $6F</td></tr>
				<tr><td></td><td class="fit">C568</td>
				<td>95 E7</td>
				<td class="fit">STA $E7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C56A</td>
				<td>B5 E2</td>
				<td class="fit">LDA $E2,X</td><td rowspan="4"><p>Load .A with the file's drive number
from FILDRV,X ($E2,X). AND it with $80
to preserve the default drive bit, OR it
with the current drive number, DRVNUM
($7F) and store the result back into
FILDRV,X ($E2,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">C56C</td>
				<td>29 80</td>
				<td class="fit">AND #$80</td></tr>
				<tr><td></td><td class="fit">C56E</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td></tr>
				<tr><td></td><td class="fit">C570</td>
				<td>95 E2</td>
				<td class="fit">STA $E2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C572</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Move the file's first track link from
(DIRBUF) ,Y(.Y=1) to FILTRK,X ($0280) and
increment .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">C574</td>
				<td>9D 80 02</td>
				<td class="fit">STA $0280,X</td></tr>
				<tr><td></td><td class="fit">C577</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C578</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Move the file's first sector link from
(DIRBUF) ,Y(.Y=2) to FILSEC,X ($0285).</p>
</td></tr>
				<tr><td></td><td class="fit">C57A</td>
				<td>9D 85 02</td>
				<td class="fit">STA $0285,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C57D</td>
				<td>AD 58 02</td>
				<td class="fit">LDA $0258</td><td rowspan="2"><p>Check the current record length, REC
($0258). If NOT $00, branch to CMPCHK.</p>
</td></tr>
				<tr><td></td><td class="fit">C580</td>
				<td>D0 07</td>
				<td class="fit">BNE $C589</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C582</td>
				<td>A0 15</td>
				<td class="fit">LDY #$15</td><td rowspan="3"><p>Set .Y to $15 and move the file entry's
record size from (DIRBUF) ,Y to REC.</p>
</td></tr>
				<tr><td></td><td class="fit">C584</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
				<tr><td></td><td class="fit">C586</td>
				<td>8D 58 02</td>
				<td class="fit">STA $0258</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMPCHK</td><td class="fit">C589</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="4"><p>Check table for unfound files
Set all-files-found flag, FOUND ($028F)
to $FF. Move the number of files to test
from F2CNT ($0278) to F2PTR ($0279).</p>
</td></tr>
				<tr><td></td><td class="fit">C58B</td>
				<td>8D 8F 02</td>
				<td class="fit">STA $028F</td></tr>
				<tr><td></td><td class="fit">C58E</td>
				<td>AD 78 02</td>
				<td class="fit">LDA $0278</td></tr>
				<tr><td></td><td class="fit">C591</td>
				<td>8D 79 02</td>
				<td class="fit">STA $0279</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CC10</td><td class="fit">C594</td>
				<td>CE 79 02</td>
				<td class="fit">DEC $0279</td><td rowspan="3"><p>Decrement the file count, F2PTR ($0279).
If any files left, branch to CC15.
If none left, exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">C597</td>
				<td>10 01</td>
				<td class="fit">BPL $C59A</td></tr>
				<tr><td></td><td class="fit">C599</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CC15</td><td class="fit">C59A</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="5"><p>Load .X with the number of the file to
test from F2PTR. Load .A with the file's
pattern type from PATTYP,X ($E7,X). If
file has not been found yet (bit 7 is
still set) abort search by branching to
CC20.
Load .A with the file's first track link
from FILTRK,X ($0280, X). If non-zero,
the file has been found. so branch back
to CC10 to test the next file.</p>
</td></tr>
				<tr><td></td><td class="fit">C59D</td>
				<td>B5 E7</td>
				<td class="fit">LDA $E7,X</td></tr>
				<tr><td></td><td class="fit">C59F</td>
				<td>30 05</td>
				<td class="fit">BMI $C5A6</td></tr>
				<tr><td></td><td class="fit">C5A1</td>
				<td>BD 80 02</td>
				<td class="fit">LDA $0280,X</td></tr>
				<tr><td></td><td class="fit">C5A4</td>
				<td>D0 EE</td>
				<td class="fit">BNE $C594</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CC20</td><td class="fit">C5A6</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Load .A with $00 and store it in the
all-files-found flag, FOUND ($028F) to
indicate that all files have NOT been
found and exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">C5A8</td>
				<td>8D 8F 02</td>
				<td class="fit">STA $028F</td></tr>
				<tr><td></td><td class="fit">C5AB</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Initiate search of directory</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SRCHST</td><td class="fit">C5AC</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Returns with valid entry (DELIND=0) or
with the first deleted entry (DELIND=1)
Load .Y with $00 and store it in DELSEC.
($0291). Decrement .Y to $FF and store
it in the f ound-an-entry flag, ENTFND
($0253) .</p>
</td></tr>
				<tr><td></td><td class="fit">C5AE</td>
				<td>8C 91 02</td>
				<td class="fit">STY $0291</td></tr>
				<tr><td></td><td class="fit">C5B1</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C5B2</td>
				<td>8C 53 02</td>
				<td class="fit">STY $0253</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5B5</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="5"><p>To start search at the beginning of the
directory, set TRACK ($80) to $12 (#18)
(from $FE79) and SECTOR ($81) to $01.
Also store $01 in last-sector-in-f ile
flag, LSTBUF ($0293) .</p>
</td></tr>
				<tr><td></td><td class="fit">C5B8</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
				<tr><td></td><td class="fit">C5BA</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">C5BC</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
				<tr><td></td><td class="fit">C5BE</td>
				<td>8D 93 02</td>
				<td class="fit">STA $0293</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5C1</td>
				<td>20 75 D4</td>
				<td class="fit">JSR $D475</td><td rowspan="1"><p>JSR to OPNIRD ($D475) to open the
internal channel (SA=16) for a read and
to read in the first one or two sectors
in the file whose T/S link is given in
TRACK ($80) and SECTOR ($81).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SR10</td><td class="fit">C5C4</td>
				<td>AD 93 02</td>
				<td class="fit">LDA $0293</td><td rowspan="2"><p>Test LSTBUF ($0293) to see if we have
exhausted the last sector in the
directory file. If not (LSTBUF &lt;&gt; $00),
branch to SR15.</p>
</td></tr>
				<tr><td></td><td class="fit">C5C7</td>
				<td>D0 01</td>
				<td class="fit">BNE $C5CA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5C9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SR15</td><td class="fit">C5CA</td>
				<td>A9 07</td>
				<td class="fit">LDA #$07</td><td rowspan="2"><p>Set the file count, FILCNT ($0295) to
$07 to indicate that there are 8 entries
(0-7) left to examine in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">C5CC</td>
				<td>8D 95 02</td>
				<td class="fit">STA $0295</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5CF</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Load .A with $00 and JSR to DRDBYT to
read the first byte in the sector (the
track link). On return store this value
into LSTBUF ($0293). This sets LSTBUF to
$00 if there are no more blocks left in
in the directory file.</p>
</td></tr>
				<tr><td></td><td class="fit">C5D1</td>
				<td>20 F6 D4</td>
				<td class="fit">JSR $D4F6</td></tr>
				<tr><td></td><td class="fit">C5D4</td>
				<td>8D 93 02</td>
				<td class="fit">STA $0293</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SR20</td><td class="fit">C5D7</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="1"><p>JSR to GETPNT ($D4E8) to set the
directory pointer, DIRBUF ($94/5) to the
data that was just read into the active
buffer, BUFTAB,X ($99/A,X).</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: DIRBUF does NOT point to the start of the data
      buffer ($0300, $0400,...). It points to the first
      data byte ($0302, $0402,...). As the entries are
      examined, it is update to point to the start of
      the entry ($0x02, $0x22, $0x42,...).</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5DA</td>
				<td>CE 95 02</td>
				<td class="fit">DEC $0295</td><td rowspan="2"><p>Decrement the entry count, FILCNT and
load .Y with $00 to begin examination of
the first directory entry.</p>
</td></tr>
				<tr><td></td><td class="fit">C5DD</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5DF</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Test the entry's file type in (DIRBUF) ,Y
If non-zero, this is NOT a deleted or
blank entry so branch to SR30.</p>
</td></tr>
				<tr><td></td><td class="fit">C5E1</td>
				<td>D0 18</td>
				<td class="fit">BNE $C5FB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5E3</td>
				<td>AD 91 02</td>
				<td class="fit">LDA $0291</td><td rowspan="2"><p>Process a scratched or blank entry
Test DELSEC ($0291) to see if a deleted
entry has already been found. If it has
(DELSEC &lt;&gt; $00), branch to SEARCH ( $C617 )</p>
</td></tr>
				<tr><td></td><td class="fit">C5E6</td>
				<td>D0 2F</td>
				<td class="fit">BNE $C617</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5E8</td>
				<td>20 3B DE</td>
				<td class="fit">JSR $DE3B</td><td rowspan="3"><p>This is first deleted entry so JSR to
CURBLK ($DE3B) to set up the current
sector in SECTOR ($81). Save the sector
number in DELSEC ($0291) .</p>
</td></tr>
				<tr><td></td><td class="fit">C5EB</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td></tr>
				<tr><td></td><td class="fit">C5ED</td>
				<td>8D 91 02</td>
				<td class="fit">STA $0291</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5F0</td>
				<td>A5 94</td>
				<td class="fit">LDA $94</td><td rowspan="3"><p>Load .A with the low byte of the pointer
to the start of this entry (its position
in the data buffer) from DIRBUF ($94) .
Load .X with the current value of DELIND
($0292). This sets the Z flag to 1 if
only valid entries are desired.
Store the pointer in .A into DELIND.</p>
</td></tr>
				<tr><td></td><td class="fit">C5F2</td>
				<td>AE 92 02</td>
				<td class="fit">LDX $0292</td></tr>
				<tr><td></td><td class="fit">C5F5</td>
				<td>8D 92 02</td>
				<td class="fit">STA $0292</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5F8</td>
				<td>F0 1D</td>
				<td class="fit">BEQ $C617</td><td rowspan="1"><p>If the Z flag is set, we need valid
entries, not deleted ones, so branch to
SEARCH to continue the search.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C5FA</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>We wanted a deleted entry and we found
one so terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SR30</td><td class="fit">C5FB</td>
				<td>A2 01</td>
				<td class="fit">LDX #$01</td><td rowspan="3"><p>We have found a valid entry. Check if we
are looking for one by comparing DELIND
($0292) to $01. If not equal, we want a
valid entry so branch to SR50.</p>
</td></tr>
				<tr><td></td><td class="fit">C5FD</td>
				<td>EC 92 02</td>
				<td class="fit">CPX $0292</td></tr>
				<tr><td></td><td class="fit">C600</td>
				<td>D0 2D</td>
				<td class="fit">BNE $C62F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C602</td>
				<td>F0 13</td>
				<td class="fit">BEQ $C617</td><td rowspan="1"><p>If DELIND = 1, we want a deleted entry,
not a valid one, so branch to SEARCH to
continue the quest!</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Re-enter the directory search</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SRRE</td><td class="fit">C604</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="4"><p>Set TRACK ($80) to $12 (#18) from $FE85
Set SECTOR ($81) from the last directory
sector used, DIRSEC ($0290) .</p>
</td></tr>
				<tr><td></td><td class="fit">C607</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
				<tr><td></td><td class="fit">C609</td>
				<td>AD 90 02</td>
				<td class="fit">LDA $0290</td></tr>
				<tr><td></td><td class="fit">C60C</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C60E</td>
				<td>20 75 D4</td>
				<td class="fit">JSR $D475</td><td rowspan="1"><p>JSR to OPNIRD ($D475) to open the
internal channel (SA=16) for a read and
to read in the first one or two sectors
in the file whose T/S link is given in
TRACK ($80) and SECTOR ($81).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C611</td>
				<td>AD 94 02</td>
				<td class="fit">LDA $0294</td><td rowspan="2"><p>Load .A with the pointer INDEX ($0294)
that points to the start of the last
entry we were examining and JSR to
SETPNT ($D4C8) to set the DIRPNT ($94/5)
to point to the start of the entry.</p>
</td></tr>
				<tr><td></td><td class="fit">C614</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Continue search of entries</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SEARCH</td><td class="fit">C617</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="4"><p>Set found-entry flag, ENTFND ($0253) to
$FF. Load .A with number of entries left
in the buffer from FILCNT ($0295). If
none left, branch to SR40 to get the
next buffer of directory entries.</p>
</td></tr>
				<tr><td></td><td class="fit">C619</td>
				<td>8D 53 02</td>
				<td class="fit">STA $0253</td></tr>
				<tr><td></td><td class="fit">C61C</td>
				<td>AD 95 02</td>
				<td class="fit">LDA $0295</td></tr>
				<tr><td></td><td class="fit">C61F</td>
				<td>30 08</td>
				<td class="fit">BMI $C629</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C621</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="3"><p>There is at least one more entry left in
this buffer so load .A with $20 (the #
of characters in each entry) and JSR to
INCPTR ($D1C6) to set DIRPTR ($94/5) to
point to the start of the next entry.
JMP to SR20 ($C5D7) to process it.</p>
</td></tr>
				<tr><td></td><td class="fit">C623</td>
				<td>20 C6 D1</td>
				<td class="fit">JSR $D1C6</td></tr>
				<tr><td></td><td class="fit">C626</td>
				<td>4C D7 C5</td>
				<td class="fit">JMP $C5D7</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get next buffer of entries</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SR40</td><td class="fit">C629</td>
				<td>20 4D D4</td>
				<td class="fit">JSR $D44D</td><td rowspan="2"><p>JSR to NXTBUF ($D44D) to read in the
next directory sector and JMP to SR10
to begin processing it.</p>
</td></tr>
				<tr><td></td><td class="fit">C62C</td>
				<td>4C C4 C5</td>
				<td class="fit">JMP $C5C4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SR50</td><td class="fit">C62F</td>
				<td>A5 94</td>
				<td class="fit">LDA $94</td><td rowspan="2"><p>We have found a valid entry so save
how far we got and return.
Save low byte of the pointer to the
entry, from DIRBUF($94) in INDEX ( $0294 ) .</p>
</td></tr>
				<tr><td></td><td class="fit">C631</td>
				<td>8D 94 02</td>
				<td class="fit">STA $0294</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C634</td>
				<td>20 3B DE</td>
				<td class="fit">JSR $DE3B</td><td rowspan="1"><p>JSR to CURBLK ($DE3B) to store the
sector we are checking in SECTOR ($81) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C637</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Save the current sector number from
SECTOR ($81) in DIRSEC ($0290) and RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">C639</td>
				<td>8D 90 02</td>
				<td class="fit">STA $0290</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AUTOI</td><td class="fit">C63C</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="3"><p>Check drive for active diskette, init
if needed. Return no drive status.
Test auto-initialization flag, AUTOFG
($68). If AUTOFG &lt;&gt; 0, auto-init is
disabled so branch to AUT02 ($C669).</p>
</td></tr>
				<tr><td></td><td class="fit">C63D</td>
				<td>A5 68</td>
				<td class="fit">LDA $68</td></tr>
				<tr><td></td><td class="fit">C63F</td>
				<td>D0 28</td>
				<td class="fit">BNE $C669</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C641</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="3"><p>Load .X with the current drive number
from DRVNUM ($7F). Test whether the
diskette has been changed by doing an
LSR on the wr ite-protect-change flag for
the current drive, WPSW,X ($1C/D). If
the carry flag, C, is clear, the disk
has not been changed so branch to AUT02 .</p>
</td></tr>
				<tr><td></td><td class="fit">C643</td>
				<td>56 1C</td>
				<td class="fit">LSR $1C,X</td></tr>
				<tr><td></td><td class="fit">C645</td>
				<td>90 22</td>
				<td class="fit">BCC $C669</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C647</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Load .A with $FF. Store this value as
the job return code in JOBRTN ($0298) .</p>
</td></tr>
				<tr><td></td><td class="fit">C649</td>
				<td>8D 98 02</td>
				<td class="fit">STA $0298</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C64C</td>
				<td>20 0E D0</td>
				<td class="fit">JSR $D00E</td><td rowspan="1"><p>JSR to ITRIAL ($D00E) to do a SEEK to
the current drive to determine if a
diskette is present.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C64F</td>
				<td>A0 FF</td>
				<td class="fit">LDY #$FF</td><td rowspan="1"><p>Load .Y with $FF (default to true) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C651</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td><td rowspan="2"><p>Compare the value in return job code in
.A with $02. If equal, NO SYNC was found
so branch to AUTOI to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">C653</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $C65F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C655</td>
				<td>C9 03</td>
				<td class="fit">CMP #$03</td><td rowspan="2"><p>Compare the value in return job code in
.A with $03. If equal, NO HEADER was
found so branch to AUTOI to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">C657</td>
				<td>F0 06</td>
				<td class="fit">BEQ $C65F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C659</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td><td rowspan="2"><p>Compare the value in return job code in
.A with $0F. If equal, NO DRIVE was
found so branch to AUTOI to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">C65B</td>
				<td>F0 02</td>
				<td class="fit">BEQ $C65F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C65D</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Seems OK so load .Y with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AUTO1</td><td class="fit">C65F</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="4"><p>Load .X with the current drive number
DRVNUM ($7F). Transfer the value of .Y
into .A ($00 if OK;$FF if BAD) and store
in the current drive status, NODRV,X
($FF,X). If status is bad (not $00),
branch to AUT02 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">C661</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">C662</td>
				<td>95 FF</td>
				<td class="fit">STA $FF,X</td></tr>
				<tr><td></td><td class="fit">C664</td>
				<td>D0 03</td>
				<td class="fit">BNE $C669</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C666</td>
				<td>20 42 D0</td>
				<td class="fit">JSR $D042</td><td rowspan="1"><p>JSR to INITDR ($D042) to initialize the
current drive.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AUTO2</td><td class="fit">C669</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="3"><p>Load .A with the current no-drive status
and terminate routine with an RTS.</p>
<pre><code>Note: Z flag set if all is OK.</code></pre>
</td></tr>
				<tr><td></td><td class="fit">C66B</td>
				<td>B5 FF</td>
				<td class="fit">LDA $FF,X</td></tr>
				<tr><td></td><td class="fit">C66D</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Transfer filename from CMD to buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TRNAME</td><td class="fit">C66E</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>On entry, .A=string size; .X=starting
index in command string; .Y=buffer #
Save .A (string size) on the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C66F</td>
				<td>20 A6 C6</td>
				<td class="fit">JSR $C6A6</td><td rowspan="1"><p>JSR to FNDLMT ($C6A6) to find the limit
of the string in the command buffer that
is pointed to by .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C672</td>
				<td>20 88 C6</td>
				<td class="fit">JSR $C688</td><td rowspan="1"><p>JSR to TRCMBF ($C688) to transfer the
command buffer contents from .X to LIMIT
to the data buffer whose number is in .Y</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C675</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Restore the string size into .A from the
stack. Set the carry flag and subtract
the maximum string size, STRSIZ ($024B) .</p>
</td></tr>
				<tr><td></td><td class="fit">C676</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">C677</td>
				<td>ED 4B 02</td>
				<td class="fit">SBC $024B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C67A</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="3"><p>Transfer the result from .A to .X. If
the result is or negative, the string
does not need padding so branch to TN20.</p>
</td></tr>
				<tr><td></td><td class="fit">C67B</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $C687</td></tr>
				<tr><td></td><td class="fit">C67D</td>
				<td>90 08</td>
				<td class="fit">BCC $C687</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C67F</td>
				<td>A9 A0</td>
				<td class="fit">LDA #$A0</td><td rowspan="1"><p>String is short and needs to be padded
so load .A with $A0 .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TN10</td><td class="fit">C681</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td><td rowspan="4"><p>Loop to pad the string in the directory
buffer with .X $A0 ' s.</p>
</td></tr>
				<tr><td></td><td class="fit">C683</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">C684</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">C685</td>
				<td>D0 FA</td>
				<td class="fit">BNE $C681</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TN20</td><td class="fit">C687</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Transfer CMD buffer to another buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TRCMBF</td><td class="fit">C688</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="3"><p>.X=index to first chr in command buffer
LIMIT=index to last chr+1 in CMD buffer
. Y=buffer#. Uses current buffer pointer.
Multiply .Y by 2 (TYA; ASL; TAY) .</p>
</td></tr>
				<tr><td></td><td class="fit">C689</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">C68A</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C68B</td>
				<td>B9 99 00</td>
				<td class="fit">LDA $0099,Y</td><td rowspan="5"><p>Use current buffer pointers, BUFTAB,Y
($99/A,Y) to set the directory buffer
pointers, DIRBUF ($94/5).
Zero .Y (index into directory buffer)</p>
</td></tr>
				<tr><td></td><td class="fit">C68E</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
				<tr><td></td><td class="fit">C690</td>
				<td>B9 9A 00</td>
				<td class="fit">LDA $009A,Y</td></tr>
				<tr><td></td><td class="fit">C693</td>
				<td>85 95</td>
				<td class="fit">STA $95</td></tr>
				<tr><td></td><td class="fit">C695</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TR10</td><td class="fit">C697</td>
				<td>BD 00 02</td>
				<td class="fit">LDA $0200,X</td><td rowspan="2"><p>Move character from CMDBUF,X ($0200, X)
to (DIRBUF) ,Y ; ($94) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">C69A</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C69C</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="2"><p>Increment .Y. If .Y equals $00, branch
to TR20 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">C69D</td>
				<td>F0 06</td>
				<td class="fit">BEQ $C6A5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C69F</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Increment .X. If .X &lt; LIMIT ($0276)
branch back to TRIO to do next character</p>
</td></tr>
				<tr><td></td><td class="fit">C6A0</td>
				<td>EC 76 02</td>
				<td class="fit">CPX $0276</td></tr>
				<tr><td></td><td class="fit">C6A3</td>
				<td>90 F2</td>
				<td class="fit">BCC $C697</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TR20</td><td class="fit">C6A5</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDLMT</td><td class="fit">C6A6</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Find the limit (end) of the string in the
command buffer that is pointed to by X
Zero the string size, STRSIZ ($024B).
Transfer the starting pointer from .X
to .A and save it on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">C6A8</td>
				<td>8D 4B 02</td>
				<td class="fit">STA $024B</td></tr>
				<tr><td></td><td class="fit">C6AB</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">C6AC</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FL05</td><td class="fit">C6AD</td>
				<td>BD 00 02</td>
				<td class="fit">LDA $0200,X</td><td rowspan="1"><p>Load .A with the Xth command string
character, CMDBUF,X ($0200, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6B0</td>
				<td>C9 2C</td>
				<td class="fit">CMP #$2C</td><td rowspan="2"><p>Compare the character to a &quot;. &quot;. If they
match, we're at the end. Branch to FL10.</p>
</td></tr>
				<tr><td></td><td class="fit">C6B2</td>
				<td>F0 14</td>
				<td class="fit">BEQ $C6C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6B4</td>
				<td>C9 3D</td>
				<td class="fit">CMP #$3D</td><td rowspan="2"><p>Compare the character to a &quot;=&quot;. If they
match, we* re at the end. Branch to FL10.</p>
</td></tr>
				<tr><td></td><td class="fit">C6B6</td>
				<td>F0 10</td>
				<td class="fit">BEQ $C6C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6B8</td>
				<td>EE 4B 02</td>
				<td class="fit">INC $024B</td><td rowspan="2"><p>Increment STRSIZ ($024B) and .X</p>
</td></tr>
				<tr><td></td><td class="fit">C6BB</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6BC</td>
				<td>A9 0F</td>
				<td class="fit">LDA #$0F</td><td rowspan="3"><p>Check if the string size, STRSIZ, has
reached the maximum size of $0F (#15) .
If it has, branch to FL10 to quit.</p>
</td></tr>
				<tr><td></td><td class="fit">C6BE</td>
				<td>CD 4B 02</td>
				<td class="fit">CMP $024B</td></tr>
				<tr><td></td><td class="fit">C6C1</td>
				<td>90 05</td>
				<td class="fit">BCC $C6C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6C3</td>
				<td>EC 74 02</td>
				<td class="fit">CPX $0274</td><td rowspan="2"><p>Compare .X to the pointer to the end of
the command string, CMDSIZ ($0274). If
we're NOT at the end. Branch to FL05.</p>
</td></tr>
				<tr><td></td><td class="fit">C6C6</td>
				<td>90 E5</td>
				<td class="fit">BCC $C6AD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FL10</td><td class="fit">C6C8</td>
				<td>8E 76 02</td>
				<td class="fit">STX $0276</td><td rowspan="1"><p>Store the .X value (the last character
plus 1) into LIMIT ($0276).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6CB</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original .X value off the stack
into .A and transfer it to .X</p>
</td></tr>
				<tr><td></td><td class="fit">C6CC</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6CD</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get file entry from directory (called by STDIR and GETDIR)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETNAM</td><td class="fit">C6CE</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="2"><p>Save secondary address, SA ($83) on the
stack.</p>
</td></tr>
				<tr><td></td><td class="fit">C6D0</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6D1</td>
				<td>A5 82</td>
				<td class="fit">LDA $82</td><td rowspan="2"><p>Save the current channel*, LINDX ($82)
on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">C6D3</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6D4</td>
				<td>20 DE C6</td>
				<td class="fit">JSR $C6DE</td><td rowspan="1"><p>JSR to GNSUB ($C6DE) to get a directory
entry using the internal read channel
SA=$11(#17)\</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6D7</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the original SA and LINDX values
from the stack and reset these variables</p>
</td></tr>
				<tr><td></td><td class="fit">C6D8</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
				<tr><td></td><td class="fit">C6DA</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">C6DB</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6DD</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GNSUB</td><td class="fit">C6DE</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="2"><p>Get file entry subroutine:
Set current secondary address, SA ($83)
to $11 (internal read secondary address)</p>
</td></tr>
				<tr><td></td><td class="fit">C6E0</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6E2</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6E5</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="1"><p>JSR to GETPNT ($D4E8) to set the
directory buffer pointer, DIRBUF ($94/5)
from the pointer to the currently active
buffer using values from BUFTAB ($30/1) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6E8</td>
				<td>AD 53 02</td>
				<td class="fit">LDA $0253</td><td rowspan="2"><p>Test the found entry flag, ENTFLG ($0253 )
to see if there are more files. If there
are more (ENTFLG &gt; 127), branch to GN05.</p>
</td></tr>
				<tr><td></td><td class="fit">C6EB</td>
				<td>10 0A</td>
				<td class="fit">BPL $C6F7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6ED</td>
				<td>AD 8D 02</td>
				<td class="fit">LDA $028D</td><td rowspan="2"><p>No more entries so test DRVFLG ($028D)
to see if we have the other drive to do.
If DRVFLG &lt;&gt; 0, branch to GN050 to do
the other drive.
GN0 5</p>
</td></tr>
				<tr><td></td><td class="fit">C6F0</td>
				<td>D0 0A</td>
				<td class="fit">BNE $C6FC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6F2</td>
				<td>20 06 C8</td>
				<td class="fit">JSR $C806</td><td rowspan="1"><p>JSR to MSGFRE ($C806) to send the BLOCKS
FREE message.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C6F5</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Clear carry bit and exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">C6F6</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN05</td><td class="fit">C6F7</td>
				<td>AD 8D 02</td>
				<td class="fit">LDA $028D</td><td rowspan="2"><p>Test drive flag, DRVFLG ($028D). If $00,
branch to GN10.</p>
</td></tr>
				<tr><td></td><td class="fit">C6FA</td>
				<td>F0 1F</td>
				<td class="fit">BEQ $C71B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN050</td><td class="fit">C6FC</td>
				<td>CE 8D 02</td>
				<td class="fit">DEC $028D</td><td rowspan="2"><p>Decrement drive flag, DRVFLG ($028D). If
not $00, branch to GN0 51 to do a new
directory.</p>
</td></tr>
				<tr><td></td><td class="fit">C6FF</td>
				<td>D0 0D</td>
				<td class="fit">BNE $C70E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C701</td>
				<td>CE 8D 02</td>
				<td class="fit">DEC $028D</td><td rowspan="1"><p>Decrement drive flag, DRVFLG ($028D) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C704</td>
				<td>20 8F C3</td>
				<td class="fit">JSR $C38F</td><td rowspan="1"><p>JSR to TOGDRV ($C38F) to switch drives.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C707</td>
				<td>20 06 C8</td>
				<td class="fit">JSR $C806</td><td rowspan="1"><p>JSR to MSGFRE ($C806) to send the BLOCKS
FREE message.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C70A</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="2"><p>Set the carry flag and exit with a JMP
to TOGDRV ($C3 F) to switch drives.      8</p>
</td></tr>
				<tr><td></td><td class="fit">C70B</td>
				<td>4C 8F C3</td>
				<td class="fit">JMP $C38F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN051</td><td class="fit">C70E</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Load .A with $0and zero the hi byte of
the number of blocks counter, NBTEMP+1
($0273) and thedrive flag DRVFLG ($028D)</p>
</td></tr>
				<tr><td></td><td class="fit">C710</td>
				<td>8D 73 02</td>
				<td class="fit">STA $0273</td></tr>
				<tr><td></td><td class="fit">C713</td>
				<td>8D 8D 02</td>
				<td class="fit">STA $028D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C716</td>
				<td>20 B7 C7</td>
				<td class="fit">JSR $C7B7</td><td rowspan="1"><p>JSR to NEWDIR ($C7B7) to begin a new
directory listing.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C719</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="2"><p>Set the carry flag and exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">C71A</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN10</td><td class="fit">C71B</td>
				<td>A2 18</td>
				<td class="fit">LDX #$18</td><td rowspan="1"><p>Load .X with $18 (#24), the length of an
entry in a directory listing
e.g.' 114  &quot;PROGRAM FILENAME&quot; PRG</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C71D</td>
				<td>A0 1D</td>
				<td class="fit">LDY #$1D</td><td rowspan="1"><p>Load .Y with $1D, the position of the
hi byte of the # of blocks in the file,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C71F</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Load .A with the hi byte of the # of
blocks in the file. Store this into the
hi byte of the block  counter, NBTEMP+1
($0273). If zero, branch to GN12.</p>
</td></tr>
				<tr><td></td><td class="fit">C721</td>
				<td>8D 73 02</td>
				<td class="fit">STA $0273</td></tr>
				<tr><td></td><td class="fit">C724</td>
				<td>F0 02</td>
				<td class="fit">BEQ $C728</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C726</td>
				<td>A2 16</td>
				<td class="fit">LDX #$16</td><td rowspan="1"><p>Load .X with $16 (#22) the directory
length less 2.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN12</td><td class="fit">C728</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="1"><p>Decrement Y so it points to the position
of the lo byte of the # of blocks in
the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C729</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A with the lo byte of the # of
blocks in the file. Store this into
lo byte of the block counter, NBTEMP  the
($0272).</p>
</td></tr>
				<tr><td></td><td class="fit">C72B</td>
				<td>8D 72 02</td>
				<td class="fit">STA $0272</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C72E</td>
				<td>E0 16</td>
				<td class="fit">CPX #$16</td><td rowspan="2"><p>Compare .X to $16 (#22) the directory
length less 2. If they are equal, branch
to GN14.</p>
</td></tr>
				<tr><td></td><td class="fit">C730</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $C73C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C732</td>
				<td>C9 0A</td>
				<td class="fit">CMP #$0A</td><td rowspan="2"><p>Compare .A (the lo byte of the blocks)
with $0A (#10). If .A&lt;10 branch to GN14</p>
</td></tr>
				<tr><td></td><td class="fit">C734</td>
				<td>90 06</td>
				<td class="fit">BCC $C73C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C736</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="1"><p>Decrement .X (we will need less padding
since # of blocks is at least 2 digits.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C737</td>
				<td>C9 64</td>
				<td class="fit">CMP #$64</td><td rowspan="2"><p>Compare .A (the lo byte of the blocks)
with $64 (#100). If A&lt;100 branch to GN14</p>
</td></tr>
				<tr><td></td><td class="fit">C739</td>
				<td>90 01</td>
				<td class="fit">BCC $C73C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C73B</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="1"><p>Decrement .X (we will need less padding
since # of blocks is at least 3 digits).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN14</td><td class="fit">C73C</td>
				<td>20 AC C7</td>
				<td class="fit">JSR $C7AC</td><td rowspan="1"><p>JSR to BLKNB ($C7AC) to clear the name
buffer for the next entry. On return Y=0</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C73F</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A with the file type from the
directory buffer (DIRBUF) ,Y and save the
file type onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">C741</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C742</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="1"><p>Do an ASL of the value in .A to set the
carry bit if this is a valid file that
has not been closed, (see BCS $C764)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C743</td>
				<td>10 05</td>
				<td class="fit">BPL $C74A</td><td rowspan="1"><p>If .A&lt;128, branch to GN15.
NOTE: The branch at $C742 and the code following is what
produces the PRG&lt;. SEQ&lt; , etc. file types. Note that
these file types are LOCKED and can't be SCRATCHED!
The locking and unlocking of files is NOT supported
by any Commodore DOS. To lock a file, change its
file type in its directory entry from $80, $81, etc
to $C0, $C1, etc. Reverse the process for unlocking</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C745</td>
				<td>A9 3C</td>
				<td class="fit">LDA #$3C</td><td rowspan="1"><p>Load .A with a $3C (a &quot;&lt;&quot;).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C747</td>
				<td>9D B2 02</td>
				<td class="fit">STA $02B2,X</td><td rowspan="1"><p>Store this value into the name buffer
NAMBUF+1,X ($02B1,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN15</td><td class="fit">C74A</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the file type off the stack and AND
it with $0F to mask off the higher bits.
Transfer it to .Y to use as an index.</p>
</td></tr>
				<tr><td></td><td class="fit">C74B</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">C74D</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C74E</td>
				<td>B9 C5 FE</td>
				<td class="fit">LDA $FEC5,Y</td><td rowspan="2"><p>Move last character in file type name
from TP2LST,Y ($FEC5,Y) to the name
buffer, NAMBUF,X ($02B1,X).</p>
</td></tr>
				<tr><td></td><td class="fit">C751</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C754</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="1"><p>Decrement .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C755</td>
				<td>B9 C0 FE</td>
				<td class="fit">LDA $FEC0,Y</td><td rowspan="2"><p>Move middle character in file type name
from TP1LST,Y ($FEC0,Y) to the name
buffer, NAMBUF,X ($02B1,X).</p>
</td></tr>
				<tr><td></td><td class="fit">C758</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C75B</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="1"><p>Decrement .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C75C</td>
				<td>B9 BB FE</td>
				<td class="fit">LDA $FEBB,Y</td><td rowspan="2"><p>Move first character in file type name
from TYPLST,Y ($FEBB,Y) to the name
buffer, NAMBUF,X ($02B1,X).</p>
</td></tr>
				<tr><td></td><td class="fit">C75F</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C762</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement .X twice</p>
</td></tr>
				<tr><td></td><td class="fit">C763</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C764</td>
				<td>B0 05</td>
				<td class="fit">BCS $C76B</td><td rowspan="1"><p>If carry bit is set (indicates valid
entry; see $C742) branch to GN20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C766</td>
				<td>A9 2A</td>
				<td class="fit">LDA #$2A</td><td rowspan="1"><p>Load .A with $2A (a &quot;*&quot;) to indicate an
improperly closed file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C768</td>
				<td>9D B2 02</td>
				<td class="fit">STA $02B2,X</td><td rowspan="1"><p>Store the &quot;*&quot; in NAMBUF+1,X ($02B1,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN20</td><td class="fit">C76B</td>
				<td>A9 A0</td>
				<td class="fit">LDA #$A0</td><td rowspan="3"><p>Store a shifted space, $A0 in the buffer
(between name &amp; type) and decrement .X</p>
</td></tr>
				<tr><td></td><td class="fit">C76D</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td></tr>
				<tr><td></td><td class="fit">C770</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C771</td>
				<td>A0 12</td>
				<td class="fit">LDY #$12</td><td rowspan="1"><p>Load .Y with $12 (#18) so it points to
the end of the name in the dir buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN22</td><td class="fit">C773</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="6"><p>Loop to transfer the 16 characters in
the file name from the directory buffer
to the name buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">C775</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td></tr>
				<tr><td></td><td class="fit">C778</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">C779</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C77A</td>
				<td>C0 03</td>
				<td class="fit">CPY #$03</td></tr>
				<tr><td></td><td class="fit">C77C</td>
				<td>B0 F5</td>
				<td class="fit">BCS $C773</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C77E</td>
				<td>A9 22</td>
				<td class="fit">LDA #$22</td><td rowspan="1"><p>Load .A with $22 (a ' &quot; ' )</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C780</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td><td rowspan="1"><p>Store quotation mark before the name.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN30</td><td class="fit">C783</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="17"><p>Loop to scan up the name looking for a
quote mark($22) or a shifted space ($AO).
When either character is found or the
end of the name is reached, store a $22
(quote mark) at that location. Then AND
any remaining characters in the name
with $7F to clear bit 7 for each one.</p>
</td></tr>
				<tr><td></td><td class="fit">C784</td>
				<td>E0 20</td>
				<td class="fit">CPX #$20</td></tr>
				<tr><td></td><td class="fit">C786</td>
				<td>B0 0B</td>
				<td class="fit">BCS $C793</td></tr>
				<tr><td></td><td class="fit">C788</td>
				<td>BD B1 02</td>
				<td class="fit">LDA $02B1,X</td></tr>
				<tr><td></td><td class="fit">C78B</td>
				<td>C9 22</td>
				<td class="fit">CMP #$22</td></tr>
				<tr><td></td><td class="fit">C78D</td>
				<td>F0 04</td>
				<td class="fit">BEQ $C793</td></tr>
				<tr><td></td><td class="fit">C78F</td>
				<td>C9 A0</td>
				<td class="fit">CMP #$A0</td></tr>
				<tr><td></td><td class="fit">C791</td>
				<td>D0 F0</td>
				<td class="fit">BNE $C783</td></tr>
				<tr><td></td><td class="fit">C793</td>
				<td>A9 22</td>
				<td class="fit">LDA #$22</td></tr>
				<tr><td></td><td class="fit">C795</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td></tr>
				<tr><td></td><td class="fit">C798</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">C799</td>
				<td>E0 20</td>
				<td class="fit">CPX #$20</td></tr>
				<tr><td></td><td class="fit">C79B</td>
				<td>B0 0A</td>
				<td class="fit">BCS $C7A7</td></tr>
				<tr><td></td><td class="fit">C79D</td>
				<td>A9 7F</td>
				<td class="fit">LDA #$7F</td></tr>
				<tr><td></td><td class="fit">C79F</td>
				<td>3D B1 02</td>
				<td class="fit">AND $02B1,X</td></tr>
				<tr><td></td><td class="fit">C7A2</td>
				<td>9D B1 02</td>
				<td class="fit">STA $02B1,X</td></tr>
				<tr><td></td><td class="fit">C7A5</td>
				<td>10 F1</td>
				<td class="fit">BPL $C798</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN40</td><td class="fit">C7A7</td>
				<td>20 B5 C4</td>
				<td class="fit">JSR $C4B5</td><td rowspan="2"><p>JSR to FNDFIL ($C4B5) to find the next
entry. On return, set the carry bit.</p>
</td></tr>
				<tr><td></td><td class="fit">C7AA</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GN45</td><td class="fit">C7AB</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKNB</td><td class="fit">C7AC</td>
				<td>A0 1B</td>
				<td class="fit">LDY #$1B</td><td rowspan="2"><p>Balnk the name buffer:
Load .Y with $1B, the length of the name
buffer, and .A with $20, a space.</p>
</td></tr>
				<tr><td></td><td class="fit">C7AE</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKNB1</td><td class="fit">C7B0</td>
				<td>99 B0 02</td>
				<td class="fit">STA $02B0,Y</td><td rowspan="3"><p>Loop to store $20 's in all locations in
the name buffer, NAMBUF ($02B1-CB)</p>
</td></tr>
				<tr><td></td><td class="fit">C7B3</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C7B4</td>
				<td>D0 FA</td>
				<td class="fit">BNE $C7B0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7B6</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>New directory in listing</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NEWDIR</td><td class="fit">C7B7</td>
				<td>20 19 F1</td>
				<td class="fit">JSR $F119</td><td rowspan="1"><p>JSR to BAM2X ($F119) to set BAM pointer
in buffer 0/1 tables and leave in .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7BA</td>
				<td>20 DF F0</td>
				<td class="fit">JSR $F0DF</td><td rowspan="1"><p>JSR to REDBAM ($F0DF) to read in the BAM
to $0700-FF if not already present.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7BD</td>
				<td>20 AC C7</td>
				<td class="fit">JSR $C7AC</td><td rowspan="1"><p>JSR to BLKNB ($C7AC) to blank the name
buffer, NAMBUF ($02B1-CB).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7C0</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Set TEMP ($6F) to $FF</p>
</td></tr>
				<tr><td></td><td class="fit">C7C2</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7C4</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="2"><p>Set NBTEMP ($0272) to the current drive
number from DRVNUM ($7F)</p>
</td></tr>
				<tr><td></td><td class="fit">C7C6</td>
				<td>8E 72 02</td>
				<td class="fit">STX $0272</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7C9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set NBTEMP+1 ($0273) to $00</p>
</td></tr>
				<tr><td></td><td class="fit">C7CB</td>
				<td>8D 73 02</td>
				<td class="fit">STA $0273</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7CE</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="1"><p>Load .X with the position of the read
BAM job in the queue from JOBNUM ($F9) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7D0</td>
				<td>BD E0 FE</td>
				<td class="fit">LDA $FEE0,X</td><td rowspan="2"><p>Set high byte of the pointer to the
directory buffer, DIRBUF ($94/5) using a
value (3,4,5,6,7,7) from BUFIND,X ( $FEE0 )</p>
</td></tr>
				<tr><td></td><td class="fit">C7D3</td>
				<td>85 95</td>
				<td class="fit">STA $95</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7D5</td>
				<td>AD 88 FE</td>
				<td class="fit">LDA $FE88</td><td rowspan="2"><p>Set low byte of the pointer to the
directory buffer, DIRBUF ($94/5) using
the value ($90) from DSKNAM ($FE88).
DIRBUF now points to the start of the
disk name in the BAM buffer ($0x90)</p>
</td></tr>
				<tr><td></td><td class="fit">C7D8</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7DA</td>
				<td>A0 16</td>
				<td class="fit">LDY #$16</td><td rowspan="1"><p>Load .Y with $16 (#22). the name length.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ND10</td><td class="fit">C7DC</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Load .A with character, (DIRBUF) ,Y and
test if it is a shifted blank ($A0) .
If not, branch to ND20.</p>
</td></tr>
				<tr><td></td><td class="fit">C7DE</td>
				<td>C9 A0</td>
				<td class="fit">CMP #$A0</td></tr>
				<tr><td></td><td class="fit">C7E0</td>
				<td>D0 0B</td>
				<td class="fit">BNE $C7ED</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7E2</td>
				<td>A9 31</td>
				<td class="fit">LDA #$31</td><td rowspan="1"><p>Since it is not a shifted blank, load .A
with a $31 (ASCII &quot;1&quot;) for version #1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7E4</td>
				<td>2C</td>
				<td class="fit"></td><td rowspan="1"><p>BYTE $2C here causes branch to ND20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ND15</td><td class="fit">C7E5</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Load .A with character, (DIRBUF) ,Y and
test if it is a shifted blank ($A0) .
If not, branch to ND20.</p>
</td></tr>
				<tr><td></td><td class="fit">C7E7</td>
				<td>C9 A0</td>
				<td class="fit">CMP #$A0</td></tr>
				<tr><td></td><td class="fit">C7E9</td>
				<td>D0 02</td>
				<td class="fit">BNE $C7ED</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7EB</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="1"><p>Since it is not a shifted blank, load .A
with a $20 (ASCII space).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ND20</td><td class="fit">C7ED</td>
				<td>99 B3 02</td>
				<td class="fit">STA $02B3,Y</td><td rowspan="2"><p>Store the character in .A into the name
buffer, NAMBUF+2,Y ($02B3,Y).</p>
</td></tr>
				<tr><td></td><td class="fit">C7F0</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7F1</td>
				<td>10 F2</td>
				<td class="fit">BPL $C7E5</td><td rowspan="1"><p>If more characters left (.Y&gt;=0) branch
back to ND15.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7F3</td>
				<td>A9 12</td>
				<td class="fit">LDA #$12</td><td rowspan="2"><p>Store a $12 (RVS on) in NAMBUF ($02B1)</p>
</td></tr>
				<tr><td></td><td class="fit">C7F5</td>
				<td>8D B1 02</td>
				<td class="fit">STA $02B1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7F8</td>
				<td>A9 22</td>
				<td class="fit">LDA #$22</td><td rowspan="2"><p>Store a $22 (quote) in NAMBUF+1 ($02B2)</p>
</td></tr>
				<tr><td></td><td class="fit">C7FA</td>
				<td>8D B2 02</td>
				<td class="fit">STA $02B2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C7FD</td>
				<td>8D C3 02</td>
				<td class="fit">STA $02C3</td><td rowspan="1"><p>Store a $22 (quote) in NAMBUF+18 ($02C3 )</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C800</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Store a $20 (space) in NAMBUF+19 ($02C4)</p>
</td></tr>
				<tr><td></td><td class="fit">C802</td>
				<td>8D C4 02</td>
				<td class="fit">STA $02C4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C805</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up message &quot;BLOCKS FREE&quot;</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MSGFRE</td><td class="fit">C806</td>
				<td>20 AC C7</td>
				<td class="fit">JSR $C7AC</td><td rowspan="1"><p>JSR to BLKNB ($C7AC) to clear the name
buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C809</td>
				<td>A0 0B</td>
				<td class="fit">LDY #$0B</td><td rowspan="1"><p>Load .Y with $0B (message length -1) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C80B</td>
				<td>B9 17 C8</td>
				<td class="fit">LDA $C817,Y</td><td rowspan="4"><p>Loop using .Y as index to move message
from FREMSG, Y ($C817,Y) to NAMBUF, Y
($02B1,Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">C80E</td>
				<td>99 B1 02</td>
				<td class="fit">STA $02B1,Y</td></tr>
				<tr><td></td><td class="fit">C811</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">C812</td>
				<td>10 F7</td>
				<td class="fit">BPL $C80B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C814</td>
				<td>4C 4D EF</td>
				<td class="fit">JMP $EF4D</td><td rowspan="1"><p>Terminate routine with a JMP to NUMFRE
($EF4D) to calculate the number free.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREMSG</td><td class="fit">C817</td>
				<td>42 4C 4F 43 4B 53 20 46 52 45 45 2E</td>
				<td class="fit"></td><td rowspan="1"><p>Message &quot;BLOCKS FREE&quot;</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Scratch one or more files</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCRTCH</td><td class="fit">C823</td>
				<td>20 98 C3</td>
				<td class="fit">JSR $C398</td><td rowspan="1"><p>JSR to FS1SET ($C398) to set up for one
file stream.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C826</td>
				<td>20 20 C3</td>
				<td class="fit">JSR $C320</td><td rowspan="1"><p>JSR to ALLDRS ($C320) to all drives
needed based on F2CNT.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C829</td>
				<td>20 CA C3</td>
				<td class="fit">JSR $C3CA</td><td rowspan="1"><p>JSR to OPTSCH ($C3CA) to determine best
sequence of drives to use.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C82C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero file counter, R0 ($86)</p>
</td></tr>
				<tr><td></td><td class="fit">C82E</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C830</td>
				<td>20 9D C4</td>
				<td class="fit">JSR $C49D</td><td rowspan="2"><p>JSR to FFST ($C49D) to find the first
directory entry. If not successful,
branch to SC30.</p>
</td></tr>
				<tr><td></td><td class="fit">C833</td>
				<td>30 3D</td>
				<td class="fit">BMI $C872</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: The following code prevents freeing the sectors
      of an unclosed file.</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SC15</td><td class="fit">C835</td>
				<td>20 B7 DD</td>
				<td class="fit">JSR $DDB7</td><td rowspan="1"><p>JSR to TSTCHN ($DDB7) to test for active
files from index table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C838</td>
				<td>90 33</td>
				<td class="fit">BCC $C86D</td><td rowspan="1"><p>If file active (carry clear). branch to
SC25.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: The following code prevents the scratching of
      a locked file (bit 6 of the file type set).</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C83A</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C83C</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="1"><p>Load .A with file type from (DIRBUF) ,Y
($94, Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C83E</td>
				<td>29 40</td>
				<td class="fit">AND #$40</td><td rowspan="1"><p>AND the file type with $40 to test if it
is a locked file (bit 6 of filetype set)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C840</td>
				<td>D0 2B</td>
				<td class="fit">BNE $C86D</td><td rowspan="1"><p>If a locked file, branch to SC25.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C842</td>
				<td>20 B6 C8</td>
				<td class="fit">JSR $C8B6</td><td rowspan="1"><p>JSR to DELDIR ($C8B6) to delete the
directory entry. Stores $00 as the file
type and rewrite the sector on disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C845</td>
				<td>A0 13</td>
				<td class="fit">LDY #$13</td><td rowspan="1"><p>Load .Y with $13 (#19) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C847</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="1"><p>Test whether this is a relative file by
loading .A with 19th character of the
entry (the track of the side-sector
pointer for a REL file) from (DIRBUF) ,Y</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C849</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $C855</td><td rowspan="1"><p>If $00, not a REL file so branch to SC17</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C84B</td>
				<td>85 80</td>
				<td class="fit">STA $80</td><td rowspan="1"><p>Store trackpointer into TRACK ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C84D</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment  Y and move sector pointer
from (DIRBUF) ,Y into SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">C84E</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
				<tr><td></td><td class="fit">C850</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C852</td>
				<td>20 7D C8</td>
				<td class="fit">JSR $C87D</td><td rowspan="1"><p>JSR to DELFIL ($C87D) to free the side
sectors by updating and writing the BAM</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: The following code prevents freeing the sectors
of a file if its replacement was incomplete (bit 5 set).</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SC17</td><td class="fit">C855</td>
				<td>AE 53 02</td>
				<td class="fit">LDX $0253</td><td rowspan="2"><p>Load .X with the directory entry counter
ENTFND ($0253) and .A with $20.</p>
</td></tr>
				<tr><td></td><td class="fit">C858</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C85A</td>
				<td>35 E7</td>
				<td class="fit">AND $E7,X</td><td rowspan="1"><p>AND .A with the file pattern type in
PATTYP,X ($E7,X) to check if this is an
opened but unclosed file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C85C</td>
				<td>D0 0D</td>
				<td class="fit">BNE $C86B</td><td rowspan="1"><p>If unclosed file, branch to SC20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C85E</td>
				<td>BD 80 02</td>
				<td class="fit">LDA $0280,X</td><td rowspan="2"><p>Move initial track link from FILTRK,X
($0280, X) into TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">C861</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C863</td>
				<td>BD 85 02</td>
				<td class="fit">LDA $0285,X</td><td rowspan="2"><p>Move initial sector link from FILSEC,X
($0285, X) into SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">C866</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C868</td>
				<td>20 7D C8</td>
				<td class="fit">JSR $C87D</td><td rowspan="1"><p>JSR to DELFIL ($C87D) to free the file
blocks by updating and writing the BAM</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SC20</td><td class="fit">C86B</td>
				<td>E6 86</td>
				<td class="fit">INC $86</td><td rowspan="1"><p>Increment the file counter, R0 ($86).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SC25</td><td class="fit">C86D</td>
				<td>20 8B C4</td>
				<td class="fit">JSR $C48B</td><td rowspan="1"><p>JSR to FFRE ($C48B) to match the next
filename in the command string.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C870</td>
				<td>10 C3</td>
				<td class="fit">BPL $C835</td><td rowspan="1"><p>If a match found, branch to SC15</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SC30</td><td class="fit">C872</td>
				<td>A5 86</td>
				<td class="fit">LDA $86</td><td rowspan="2"><p>All done. Store number of files that
have been scratched, R0 ($86) into
TRACK ($80)</p>
</td></tr>
				<tr><td></td><td class="fit">C874</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C876</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Load .A with $01 and .Y with $00</p>
</td></tr>
				<tr><td></td><td class="fit">C878</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C87A</td>
				<td>4C A3 C1</td>
				<td class="fit">JMP $C1A3</td><td rowspan="1"><p>Exit with a JMP to SCREND ($C1A3)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Delete file by links</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DELFIL</td><td class="fit">C87D</td>
				<td>20 5F EF</td>
				<td class="fit">JSR $EF5F</td><td rowspan="1"><p>JSR to FRETS ($EF5F) to mark the first
file block as free in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C880</td>
				<td>20 75 D4</td>
				<td class="fit">JSR $D475</td><td rowspan="1"><p>JSR to OPNIRD ($D475) to open the
internal read channel (SA=17) and read
in the first one or two blocks.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C883</td>
				<td>20 19 F1</td>
				<td class="fit">JSR $F119</td><td rowspan="1"><p>JSR to BAM2X ($F119) to set BAM pointers
in the buffer tables</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C886</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="6"><p>Load .A from BUF0,X ($A7,X) and compare
it to $FF to see if buffer inactive.
If inactive (.A=$FF, branch to DEL2     )
Load write BAM flag, WBAM ($02F9). OR it,
with $40 to set bit6 and store it back
in WBAM to indicate both buffers active.</p>
</td></tr>
				<tr><td></td><td class="fit">C888</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">C88A</td>
				<td>F0 08</td>
				<td class="fit">BEQ $C894</td></tr>
				<tr><td></td><td class="fit">C88C</td>
				<td>AD F9 02</td>
				<td class="fit">LDA $02F9</td></tr>
				<tr><td></td><td class="fit">C88F</td>
				<td>09 40</td>
				<td class="fit">ORA #$40</td></tr>
				<tr><td></td><td class="fit">C891</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DEL2</td><td class="fit">C894</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and JSR to SETPNT ( $D4C8 ) to set
pointers to the currently active buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">C896</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C899</td>
				<td>20 56 D1</td>
				<td class="fit">JSR $D156</td><td rowspan="1"><p>JSR to RDBYT ($D156) to direct read one
byte (the track link from the buffer)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C89C</td>
				<td>85 80</td>
				<td class="fit">STA $80</td><td rowspan="1"><p>Store track link into TRACK ($80)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C89E</td>
				<td>20 56 D1</td>
				<td class="fit">JSR $D156</td><td rowspan="1"><p>JSR to RDBYT ($D156) to direct read one
byte (the sector link from the buffer)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8A1</td>
				<td>85 81</td>
				<td class="fit">STA $81</td><td rowspan="1"><p>Store sector link into SECTOR ($81)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8A3</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Test track link. If not $00 (not final
sector in this file). branch to DELI</p>
</td></tr>
				<tr><td></td><td class="fit">C8A5</td>
				<td>D0 06</td>
				<td class="fit">BNE $C8AD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8A7</td>
				<td>20 F4 EE</td>
				<td class="fit">JSR $EEF4</td><td rowspan="1"><p>JSR to MAPOUT ($EEF4) write out the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8AA</td>
				<td>4C 27 D2</td>
				<td class="fit">JMP $D227</td><td rowspan="1"><p>Exit with a JMP to FRECHN ($D227) to
free the internal read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DEL1</td><td class="fit">C8AD</td>
				<td>20 5F EF</td>
				<td class="fit">JSR $EF5F</td><td rowspan="1"><p>JSR to FRETS ($EF5F) to de-allocate (free)
specified in TRACK ($80) &amp; SECTOR ($81)
in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8B0</td>
				<td>20 4D D4</td>
				<td class="fit">JSR $D44D</td><td rowspan="1"><p>JSR to NXTBUF ($D44D) to read in the
next block in the file (use T/S link) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8B3</td>
				<td>4C 94 C8</td>
				<td class="fit">JMP $C894</td><td rowspan="1"><p>JMP to DEL2 to de-allocate the new block</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Delete the directory entry</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DELDIR</td><td class="fit">C8B6</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00 (will point to the 0th
character in the entry; the file type) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8B8</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Set the file type, (DIRBUF) ,Y; ($94) ,Y
to $00 to indicate a scratched file.</p>
</td></tr>
				<tr><td></td><td class="fit">C8B9</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8BB</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write out the
directory block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8BE</td>
				<td>4C 99 D5</td>
				<td class="fit">JMP $D599</td><td rowspan="1"><p>Exit with a JMP to WATJOB ($D599) to
wait for the write job to be completed.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Duplicate disk</h1>
<p>Not available on the 1541</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8C1</td>
				<td>A9 31</td>
				<td class="fit">LDA #$31</td><td rowspan="2"><p>Load .A with a $31 to indicate a bad
command and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">C8C3</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Format diskette routine</h1>
<p>This routine sets up a jump instruction in buffer
that points to the code used by the disk controller
to do the formatting.</p>
<p>It then puts an exectute job
code in the job queue. The routine then waits while
the disk controller actually does the formatting.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FORMAT</td><td class="fit">C8C6</td>
				<td>A9 4C</td>
				<td class="fit">LDA #$4C</td><td rowspan="6"><p>Store JMP $FABB ( $4C. $BB, $FA) at the
start of buffer ($0600/1/2).</p>
</td></tr>
				<tr><td></td><td class="fit">C8C8</td>
				<td>8D 00 06</td>
				<td class="fit">STA $0600</td></tr>
				<tr><td></td><td class="fit">C8CB</td>
				<td>A9 C7</td>
				<td class="fit">LDA #$C7</td></tr>
				<tr><td></td><td class="fit">C8CD</td>
				<td>8D 01 06</td>
				<td class="fit">STA $0601</td></tr>
				<tr><td></td><td class="fit">C8D0</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">C8D2</td>
				<td>8D 02 06</td>
				<td class="fit">STA $0602</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8D5</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td><td rowspan="2"><p>Load .A with $03 and JSR to SETH ($D6D3)
to set up header of active buffer to the
values in TRACK ($80) and SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">C8D7</td>
				<td>20 D3 D6</td>
				<td class="fit">JSR $D6D3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8DA</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>Load drive number, DRVNUM ($7F). EOR it
with $E0 (execute job code) and store
the result in the job queue ($0003) .</p>
</td></tr>
				<tr><td></td><td class="fit">C8DC</td>
				<td>09 E0</td>
				<td class="fit">ORA #$E0</td></tr>
				<tr><td></td><td class="fit">C8DE</td>
				<td>85 03</td>
				<td class="fit">STA $03</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FMT105</td><td class="fit">C8E0</td>
				<td>A5 03</td>
				<td class="fit">LDA $03</td><td rowspan="2"><p>Load .A from the job queue ($0003). If
.A &gt; 127, the job has not been finished
yet so branch back to FMT105.</p>
</td></tr>
				<tr><td></td><td class="fit">C8E2</td>
				<td>30 FC</td>
				<td class="fit">BMI $C8E0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8E4</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td><td rowspan="2"><p>Compare .A with $02. if .A &lt; 2, the job
was completed OK so branch to FMT110.</p>
</td></tr>
				<tr><td></td><td class="fit">C8E6</td>
				<td>90 07</td>
				<td class="fit">BCC $C8EF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8E8</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td><td rowspan="3"><p>Error code returned by disk controller
indicates a problem so load .A with $03
and .X with $00 and exit with a JMP to
ERROR ($E60A).</p>
</td></tr>
				<tr><td></td><td class="fit">C8EA</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
				<tr><td></td><td class="fit">C8EC</td>
				<td>4C 0A E6</td>
				<td class="fit">JMP $E60A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FMT110</td><td class="fit">C8EF</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Job completed satisfactorily so exit with
an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Copy disk files routine</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DSKCPY</td><td class="fit">C8F0</td>
				<td>A9 E0</td>
				<td class="fit">LDA #$E0</td><td rowspan="2"><p>Store $E0 in BUFUSE ($024F) to kill the
BAM buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">C8F2</td>
				<td>8D 4F 02</td>
				<td class="fit">STA $024F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8F5</td>
				<td>20 D1 F0</td>
				<td class="fit">JSR $F0D1</td><td rowspan="1"><p>JSR to CLNBAM ($F0D1) to settrack and
sector links in BAM to $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8F8</td>
				<td>20 19 F1</td>
				<td class="fit">JSR $F119</td><td rowspan="1"><p>JSR to BAM2X ($F119) to return the BAM
LINDX in .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8FB</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF in BUF0,X ($A7,X) to mark the
BAM as out-of-memory .</p>
</td></tr>
				<tr><td></td><td class="fit">C8FD</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C8FF</td>
				<td>A9 0F</td>
				<td class="fit">LDA #$0F</td><td rowspan="2"><p>Store $0F in LINUSE ($0256) to free all
LINDXs.</p>
</td></tr>
				<tr><td></td><td class="fit">C901</td>
				<td>8D 56 02</td>
				<td class="fit">STA $0256</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C904</td>
				<td>20 E5 C1</td>
				<td class="fit">JSR $C1E5</td><td rowspan="1"><p>JSR to PRSCLN ($C1E5) to parse the
command string and find the colon,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C907</td>
				<td>D0 03</td>
				<td class="fit">BNE $C90C</td><td rowspan="1"><p>If colon found (Z flag =0) ,branch to
DX0000.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C909</td>
				<td>4C C1 C8</td>
				<td class="fit">JMP $C8C1</td><td rowspan="1"><p>Colon not found in command string so
command must be CX=Y. This command is
not supported on the 1541 soexit with
a JMP to DUPLCT ($C8C1).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DX0000</td><td class="fit">C90C</td>
				<td>20 F8 C1</td>
				<td class="fit">JSR $C1F8</td><td rowspan="1"><p>JSR to TC30 ($C1F8) to parse the command
string.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DX0005</td><td class="fit">C90F</td>
				<td>20 20 C3</td>
				<td class="fit">JSR $C320</td><td rowspan="1"><p>JSR to ALLDRS ($C320) to put the drive
numbers into the file table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C912</td>
				<td>AD 8B 02</td>
				<td class="fit">LDA $028B</td><td rowspan="3"><p>Load .A with the command pattern image
as determined by the parser from IMAGE
($028B). AND the image with %01010101
($55). If the result is not $00, the
command must be a concatenate or normal
copy so branch to DX0020.</p>
</td></tr>
				<tr><td></td><td class="fit">C915</td>
				<td>29 55</td>
				<td class="fit">AND #$55</td></tr>
				<tr><td></td><td class="fit">C917</td>
				<td>D0 0F</td>
				<td class="fit">BNE $C928</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C919</td>
				<td>AE 7A 02</td>
				<td class="fit">LDX $027A</td><td rowspan="2"><p>Check for pattern matching in the name
(as in cl:game=0 :*) by loading .X from
FILTBL ($027A) and then loading .A from
the command string, CMDBUF,X ($0200, X).</p>
</td></tr>
				<tr><td></td><td class="fit">C91C</td>
				<td>BD 00 02</td>
				<td class="fit">LDA $0200,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C91F</td>
				<td>C9 2A</td>
				<td class="fit">CMP #$2A</td><td rowspan="2"><p>The value in .A is compared to $2A (&quot;*&quot;)
If there is no match, there is no wild
so branch to DX0020.</p>
</td></tr>
				<tr><td></td><td class="fit">C921</td>
				<td>D0 05</td>
				<td class="fit">BNE $C928</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DX0010</td><td class="fit">C923</td>
				<td>A9 30</td>
				<td class="fit">LDA #$30</td><td rowspan="2"><p>Load .A with the $30 to indicate a
syntax error and JMP to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">C925</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DX0020</td><td class="fit">C928</td>
				<td>AD 8B 02</td>
				<td class="fit">LDA $028B</td><td rowspan="3"><p>Load .A with the command pattern image
as determined by the parser from IMAGE
($028B). AND the image with %11011001
($D9). If the result is not $00, the
syntax is bad so branch to DX0010 and
abort.</p>
</td></tr>
				<tr><td></td><td class="fit">C92B</td>
				<td>29 D9</td>
				<td class="fit">AND #$D9</td></tr>
				<tr><td></td><td class="fit">C92D</td>
				<td>D0 F4</td>
				<td class="fit">BNE $C923</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C92F</td>
				<td>4C 52 C9</td>
				<td class="fit">JMP $C952</td><td rowspan="1"><p>JMP to COPY ($C952) to do the file copy,
syntax error and JMP to CMDERR ($C1C8).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUPS1</td><td class="fit">C932</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="13"><p>Subroutine used to set up for copying
entire disk (C1=0). Not used on 1541.</p>
</td></tr>
				<tr><td></td><td class="fit">C934</td>
				<td>8D 58 02</td>
				<td class="fit">STA $0258</td></tr>
				<tr><td></td><td class="fit">C937</td>
				<td>8D 8C 02</td>
				<td class="fit">STA $028C</td></tr>
				<tr><td></td><td class="fit">C93A</td>
				<td>8D 80 02</td>
				<td class="fit">STA $0280</td></tr>
				<tr><td></td><td class="fit">C93D</td>
				<td>8D 81 02</td>
				<td class="fit">STA $0281</td></tr>
				<tr><td></td><td class="fit">C940</td>
				<td>A5 E3</td>
				<td class="fit">LDA $E3</td></tr>
				<tr><td></td><td class="fit">C942</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">C944</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
				<tr><td></td><td class="fit">C946</td>
				<td>09 01</td>
				<td class="fit">ORA #$01</td></tr>
				<tr><td></td><td class="fit">C948</td>
				<td>8D 91 02</td>
				<td class="fit">STA $0291</td></tr>
				<tr><td></td><td class="fit">C94B</td>
				<td>AD 7B 02</td>
				<td class="fit">LDA $027B</td></tr>
				<tr><td></td><td class="fit">C94E</td>
				<td>8D 7A 02</td>
				<td class="fit">STA $027A</td></tr>
				<tr><td></td><td class="fit">C951</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Copy file(s) to one file</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">COPY</td><td class="fit">C952</td>
				<td>20 4F C4</td>
				<td class="fit">JSR $C44F</td><td rowspan="1"><p>JSR to LOOKUP ($C44F) to look up the
file(s) listed in the command string in
the directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C955</td>
				<td>AD 78 02</td>
				<td class="fit">LDA $0278</td><td rowspan="3"><p>Load .A with the number of filenames in
the command string from F2CNT($0278) and
compare it with $03. If fewer than three
files, this is not a concatenate so
branch to COP10 ($C9A1).</p>
</td></tr>
				<tr><td></td><td class="fit">C958</td>
				<td>C9 03</td>
				<td class="fit">CMP #$03</td></tr>
				<tr><td></td><td class="fit">C95A</td>
				<td>90 45</td>
				<td class="fit">BCC $C9A1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C95C</td>
				<td>A5 E2</td>
				<td class="fit">LDA $E2</td><td rowspan="3"><p>Load .A with the first file drive number
from FILDRV ($E2) and compare it to the
second drive number in FILDRV+1 ($E3) .
If not equal, this is not a concatenate
so branch to COP10 ($C9A1).</p>
</td></tr>
				<tr><td></td><td class="fit">C95E</td>
				<td>C5 E3</td>
				<td class="fit">CMP $E3</td></tr>
				<tr><td></td><td class="fit">C960</td>
				<td>D0 3F</td>
				<td class="fit">BNE $C9A1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C962</td>
				<td>A5 DD</td>
				<td class="fit">LDA $DD</td><td rowspan="3"><p>Load .A with the index to the first file
entry from ENTIND ($DD) and compare it
to the second file's index in ENTIND+1
($DE). If not equal, this is not a
concatenate so branch to COP10 ($C9A1) .</p>
</td></tr>
				<tr><td></td><td class="fit">C964</td>
				<td>C5 DE</td>
				<td class="fit">CMP $DE</td></tr>
				<tr><td></td><td class="fit">C966</td>
				<td>D0 39</td>
				<td class="fit">BNE $C9A1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C968</td>
				<td>A5 D8</td>
				<td class="fit">LDA $D8</td><td rowspan="3"><p>Load .A with the first file's sector
link from ENTSEC ($D8) and compare it
to the second file's link in ENTSEC+1
($D9). If not equal, this is not a
concatenate so branch to COP10 ($C9A1) .</p>
</td></tr>
				<tr><td></td><td class="fit">C96A</td>
				<td>C5 D9</td>
				<td class="fit">CMP $D9</td></tr>
				<tr><td></td><td class="fit">C96C</td>
				<td>D0 33</td>
				<td class="fit">BNE $C9A1</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Concatenate files</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C96E</td>
				<td>20 CC CA</td>
				<td class="fit">JSR $CACC</td><td rowspan="1"><p>JSR to CHKIN ($CACC) to check if input
file exists.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C971</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Set F2PTR ($0279) to $01 and JSR to
OPIRFL ($C9FA) to open the internal read
channel, read in the directory file, and
locate the named file</p>
</td></tr>
				<tr><td></td><td class="fit">C973</td>
				<td>8D 79 02</td>
				<td class="fit">STA $0279</td></tr>
				<tr><td></td><td class="fit">C976</td>
				<td>20 FA C9</td>
				<td class="fit">JSR $C9FA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C979</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="2"><p>JSR to TYPFIL ($D125) to determine the
file type. If $00, a scratched file so
branch to COP01 (filetype mismatch) .</p>
</td></tr>
				<tr><td></td><td class="fit">C97C</td>
				<td>F0 04</td>
				<td class="fit">BEQ $C982</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C97E</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td><td rowspan="2"><p>Compare the file typeto $02. If not
equal, it is not a deleted program file
so branch to COP05 tocontinue.</p>
</td></tr>
				<tr><td></td><td class="fit">C980</td>
				<td>D0 05</td>
				<td class="fit">BNE $C987</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">COP01</td><td class="fit">C982</td>
				<td>A9 64</td>
				<td class="fit">LDA #$64</td><td rowspan="2"><p>Bad file name. Load  .A with $64 to
indicate a file type mismatch and JSR
to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">C984</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">COP05</td><td class="fit">C987</td>
				<td>A9 12</td>
				<td class="fit">LDA #$12</td><td rowspan="2"><p>Set secondary address, SA ($83) to $12
(#18, the internal write channel)</p>
</td></tr>
				<tr><td></td><td class="fit">C989</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C98B</td>
				<td>AD 3C 02</td>
				<td class="fit">LDA $023C</td><td rowspan="2"><p>Move the active buffer pointer from
LINTAB+IRSA ($023C) to LINTAB+IWSA
($023D) .</p>
</td></tr>
				<tr><td></td><td class="fit">C98E</td>
				<td>8D 3D 02</td>
				<td class="fit">STA $023D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C991</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Deactivate the internal read channel by
storing $FF in LINTAB+IRSA ($023C) .</p>
</td></tr>
				<tr><td></td><td class="fit">C993</td>
				<td>8D 3C 02</td>
				<td class="fit">STA $023C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C996</td>
				<td>20 2A DA</td>
				<td class="fit">JSR $DA2A</td><td rowspan="1"><p>JSR to APPEND ($DA2A) to copy first file</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C999</td>
				<td>A2 02</td>
				<td class="fit">LDX #$02</td><td rowspan="2"><p>Load .X with $02 and JSR to CY10 ($C9B9)
to copy second file behind the first.</p>
</td></tr>
				<tr><td></td><td class="fit">C99B</td>
				<td>20 B9 C9</td>
				<td class="fit">JSR $C9B9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C99E</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Exit routine with a JMP to ENDCMD ($C194)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Copy file</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">COP10</td><td class="fit">C9A1</td>
				<td>20 A7 C9</td>
				<td class="fit">JSR $C9A7</td><td rowspan="1"><p>JSR to CY ($C9A7) to do copy.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9A4</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Exit routine with a JMP to ENDCMD ($C194)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CY</td><td class="fit">C9A7</td>
				<td>20 E7 CA</td>
				<td class="fit">JSR $CAE7</td><td rowspan="1"><p>JSR to CHKIO ($CAE7) to check if file
exists.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9AA</td>
				<td>A5 E2</td>
				<td class="fit">LDA $E2</td><td rowspan="3"><p>Get drive number from FILDRV ($E2). AND
it with $01 (mask off default bit). and
store it in DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">C9AC</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">C9AE</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9B0</td>
				<td>20 86 D4</td>
				<td class="fit">JSR $D486</td><td rowspan="1"><p>JSR to OPNIWR ($D486) to open internal
write channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9B3</td>
				<td>20 E4 D6</td>
				<td class="fit">JSR $D6E4</td><td rowspan="1"><p>JSR to ADDFIL ($D6E4) to add the new
file name to the directory and rewrite
the directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9B6</td>
				<td>AE 77 02</td>
				<td class="fit">LDX $0277</td><td rowspan="1"><p>Load .X with pointer from F1CNT ($0277) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CY10</td><td class="fit">C9B9</td>
				<td>8E 79 02</td>
				<td class="fit">STX $0279</td><td rowspan="1"><p>Store .X in F2CNT ($0278).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9BC</td>
				<td>20 FA C9</td>
				<td class="fit">JSR $C9FA</td><td rowspan="1"><p>JSR to OPIRFL ($C9FA) to open internal
read channel and read in one or two
blocks of the directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9BF</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="2"><p>Set secondary address, SA ($83) to $11,
to set up the internal read channel.</p>
</td></tr>
				<tr><td></td><td class="fit">C9C1</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9C3</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9C6</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="1"><p>JSR to TYPFIL (SD125) to determine if
the file is a relative file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9C9</td>
				<td>D0 03</td>
				<td class="fit">BNE $C9CE</td><td rowspan="1"><p>If not a relative file (Z flag not set
on return). branch to CY10A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9CB</td>
				<td>20 53 CA</td>
				<td class="fit">JSR $CA53</td><td rowspan="1"><p>JSR to CYEXT ($CA53) to open copy the
relative file records.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CY10A</td><td class="fit">C9CE</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td><td rowspan="2"><p>Store $08 (EOI signal) into EOIFLG($F8).</p>
</td></tr>
				<tr><td></td><td class="fit">C9D0</td>
				<td>85 F8</td>
				<td class="fit">STA $F8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9D2</td>
				<td>4C D8 C9</td>
				<td class="fit">JMP $C9D8</td><td rowspan="1"><p>JMP to CY20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CY15</td><td class="fit">C9D5</td>
				<td>20 9B CF</td>
				<td class="fit">JSR $CF9B</td><td rowspan="1"><p>JSR to PIBYTE ($CF9B) to write out last
byte to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CY20</td><td class="fit">C9D8</td>
				<td>20 35 CA</td>
				<td class="fit">JSR $CA35</td><td rowspan="1"><p>JSR to GIBYTE ($CA35) to get a byte from
the internal read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9DB</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80 (the last record flag)
and JSR to TSTFLG ($DDA6) to see if this
is the last record.</p>
</td></tr>
				<tr><td></td><td class="fit">C9DD</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9E0</td>
				<td>F0 F3</td>
				<td class="fit">BEQ $C9D5</td><td rowspan="2"><p>On return if Z flag is set (test failed;
this is not the last record) branch to
CY15 to do some more.
Last record done so JSR to TYPFIL ($D125)
to get file type.</p>
</td></tr>
				<tr><td></td><td class="fit">C9E2</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9E5</td>
				<td>F0 03</td>
				<td class="fit">BEQ $C9EA</td><td rowspan="1"><p>On return if Z flag is set branch to
CY30 to do some more.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9E7</td>
				<td>20 9B CF</td>
				<td class="fit">JSR $CF9B</td><td rowspan="1"><p>JSR to PIBYTE ($CF9B) to write out last
byte to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CY30</td><td class="fit">C9EA</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="4"><p>Check if there are more files to copy
by loading .X from F2PTR ($0279) ,
incrementing it by 1, and comparing it
to F2CNT ($0278). If the carry bit is
clear, there are more files to copy so
branch back to CY10.</p>
</td></tr>
				<tr><td></td><td class="fit">C9ED</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">C9EE</td>
				<td>EC 78 02</td>
				<td class="fit">CPX $0278</td></tr>
				<tr><td></td><td class="fit">C9F1</td>
				<td>90 C6</td>
				<td class="fit">BCC $C9B9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">C9F3</td>
				<td>A9 12</td>
				<td class="fit">LDA #$12</td><td rowspan="3"><p>Since no more files to copy, set the SA
($83) to $12 (internal write channel)
and JMP to CLSCHN ($DB02) to close the
copy channel and file.</p>
</td></tr>
				<tr><td></td><td class="fit">C9F5</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
				<tr><td></td><td class="fit">C9F7</td>
				<td>4C 02 DB</td>
				<td class="fit">JMP $DB02</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open internal read channel to read file</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPIRFL</td><td class="fit">C9FA</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="4"><p>Load .X with the file pointer F2PTR
($0279) and use this as an index to load
.A with the drive number of the file to
be read from FILDRV,X ($E2,X).</p>
<p>AND this
drive number with $01 to mask off the
default drive bit, and store the value
in DRVNUM ($7F) to set the drive number.</p>
</td></tr>
				<tr><td></td><td class="fit">C9FD</td>
				<td>B5 E2</td>
				<td class="fit">LDA $E2,X</td></tr>
				<tr><td></td><td class="fit">C9FF</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">CA01</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA03</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="2"><p>Set the current TRACK ($80) to 18 ($12),
the directory track.</p>
</td></tr>
				<tr><td></td><td class="fit">CA06</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA08</td>
				<td>B5 D8</td>
				<td class="fit">LDA $D8,X</td><td rowspan="2"><p>Set the current SECTOR ($81) to the
sector containing the directory entry
for this file from ENTSEC,X ($D8,X).
the directory track.</p>
</td></tr>
				<tr><td></td><td class="fit">CA0A</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA0C</td>
				<td>20 75 D4</td>
				<td class="fit">JSR $D475</td><td rowspan="1"><p>JSR to OPNIRD ($D475) to open the
internal read channel to read the
directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA0F</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="2"><p>Load .X with the file pointer F2PTR
($0279) and use this as an index to load
.A with the pointer to the start of the
entry from ENTIND,X ($DD,X).</p>
</td></tr>
				<tr><td></td><td class="fit">CA12</td>
				<td>B5 DD</td>
				<td class="fit">LDA $DD,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA14</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td><td rowspan="1"><p>JSR to SETPNT ($D4C8) to set the track
sector pointers from the entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA17</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="4"><p>Load .X with the file pointer F2PTR
($0279) and use this as an index to load
.A with the file's pattern mask from
PATTYP,X ($E7,X).</p>
<p>AND this value with
$07 (the file type mask) and use it to
set the file type in TYPE ($024A) .</p>
</td></tr>
				<tr><td></td><td class="fit">CA1A</td>
				<td>B5 E7</td>
				<td class="fit">LDA $E7,X</td></tr>
				<tr><td></td><td class="fit">CA1C</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">CA1E</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA21</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set the record length, REC ($0258) to
$00 since this is not a relative file.</p>
</td></tr>
				<tr><td></td><td class="fit">CA23</td>
				<td>8D 58 02</td>
				<td class="fit">STA $0258</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA26</td>
				<td>20 A0 D9</td>
				<td class="fit">JSR $D9A0</td><td rowspan="1"><p>JSR to OPREAD ($D9A0) to open a read
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA29</td>
				<td>A0 01</td>
				<td class="fit">LDY #$01</td><td rowspan="2"><p>Load .Y with $01 and JSR to TYPFIL
($D125) to get the file type.</p>
</td></tr>
				<tr><td></td><td class="fit">CA2B</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA2E</td>
				<td>F0 01</td>
				<td class="fit">BEQ $CA31</td><td rowspan="1"><p>If Z flag set on return (indicates that
this is not a relative file) branch to
OPIR10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA30</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment ,Y by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPIR10</td><td class="fit">CA31</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer the value in .Y into .A</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA32</td>
				<td>4C C8 D4</td>
				<td class="fit">JMP $D4C8</td><td rowspan="1"><p>Exit with a JMP to SETPNT ($D4C8) to set
the track &amp; sector pointers from the
directory entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GIBYTE</td><td class="fit">CA35</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="2"><p>Get byte from internal read channel:
Set the secondary address, SA ($83) to
$11 (#17) the internal read channel.</p>
</td></tr>
				<tr><td></td><td class="fit">CA37</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GCBYTE</td><td class="fit">CA39</td>
				<td>20 9B D3</td>
				<td class="fit">JSR $D39B</td><td rowspan="1"><p>Get byte from any channel:
JSR to GBYTE ($D39B) to get the next
byte from the read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA3C</td>
				<td>85 85</td>
				<td class="fit">STA $85</td><td rowspan="1"><p>Store the byte in DATA ($85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA3E</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="2"><p>Load .X with the logical file index
LINDX ($82) and use this as an index to
load .A with the channel status flag,
CHNRDY,X</p>
</td></tr>
				<tr><td></td><td class="fit">CA40</td>
				<td>B5 F2</td>
				<td class="fit">LDA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA42</td>
				<td>29 08</td>
				<td class="fit">AND #$08</td><td rowspan="2"><p>EOR .A with $08, the not EOI send code
and store the result in EOIFLG ($F8) .</p>
</td></tr>
				<tr><td></td><td class="fit">CA44</td>
				<td>85 F8</td>
				<td class="fit">STA $F8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA46</td>
				<td>D0 0A</td>
				<td class="fit">BNE $CA52</td><td rowspan="1"><p>If .A &lt;&gt; $00 (EOI was sent!), branch to
GIB20 and exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA48</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="2"><p>JSR to TYPFIL (SD125) to get the file
type. If Z flag set on return (indicates
this is not a relative file). branch to
GIB20 and exit.</p>
</td></tr>
				<tr><td></td><td class="fit">CA4B</td>
				<td>F0 05</td>
				<td class="fit">BEQ $CA52</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA4D</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80 (the last record flag)
and JSR to SETFLG ($DD97) .</p>
</td></tr>
				<tr><td></td><td class="fit">CA4F</td>
				<td>20 97 DD</td>
				<td class="fit">JSR $DD97</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GIB20</td><td class="fit">CA52</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Copy relative records</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CYEXT</td><td class="fit">CA53</td>
				<td>20 D3 D1</td>
				<td class="fit">JSR $D1D3</td><td rowspan="1"><p>JSR to SETDRN ($D1D3) to set drive #.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA56</td>
				<td>20 CB E1</td>
				<td class="fit">JSR $E1CB</td><td rowspan="1"><p>JSR to SSEND ($E1CB) to position side
sector and BUFTAB to the end of the
last record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA59</td>
				<td>A5 D6</td>
				<td class="fit">LDA $D6</td><td rowspan="4"><p>Save side sector index, SSIND ($D6) and
the side sector number, SSNUM ($D5) onto
the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">CA5B</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">CA5C</td>
				<td>A5 D5</td>
				<td class="fit">LDA $D5</td></tr>
				<tr><td></td><td class="fit">CA5E</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA5F</td>
				<td>A9 12</td>
				<td class="fit">LDA #$12</td><td rowspan="2"><p>Set the secondary address, SA ($83) to
$12, the internal write channel .</p>
</td></tr>
				<tr><td></td><td class="fit">CA61</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA63</td>
				<td>20 07 D1</td>
				<td class="fit">JSR $D107</td><td rowspan="1"><p>JSR to FNDWCH ($D107) to find an unused
write channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA66</td>
				<td>20 D3 D1</td>
				<td class="fit">JSR $D1D3</td><td rowspan="1"><p>JSR to SETDRN ($D1D3) to set drive #.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA69</td>
				<td>20 CB E1</td>
				<td class="fit">JSR $E1CB</td><td rowspan="1"><p>JSR to SSEND ($E1CB) to position side
sector and BUFTAB to th eend of the
last record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA6C</td>
				<td>20 9C E2</td>
				<td class="fit">JSR $E29C</td><td rowspan="1"><p>JSR to POSBUF ($E2C9) to position the
proper data blocks into the buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA6F</td>
				<td>A5 D6</td>
				<td class="fit">LDA $D6</td><td rowspan="2"><p>Set Rl ($87) to the current value of
the side sector index, SSIND ($D6) .</p>
</td></tr>
				<tr><td></td><td class="fit">CA71</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA73</td>
				<td>A5 D5</td>
				<td class="fit">LDA $D5</td><td rowspan="2"><p>Set RO ($86) to the current value of
the side sector number, SSNUM ($D5) .</p>
</td></tr>
				<tr><td></td><td class="fit">CA75</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA77</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Zero R2 ($88) and the low bytes of the
record pointer RECPTR ($D4) and the
relative file pointer ($D7) .</p>
</td></tr>
				<tr><td></td><td class="fit">CA79</td>
				<td>85 88</td>
				<td class="fit">STA $88</td></tr>
				<tr><td></td><td class="fit">CA7B</td>
				<td>85 D4</td>
				<td class="fit">STA $D4</td></tr>
				<tr><td></td><td class="fit">CA7D</td>
				<td>85 D7</td>
				<td class="fit">STA $D7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA7F</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Restore the original values of the side
side sector number, SSNUM ($D5) and the
sector index, SSIND ($D6) from the stack</p>
</td></tr>
				<tr><td></td><td class="fit">CA80</td>
				<td>85 D5</td>
				<td class="fit">STA $D5</td></tr>
				<tr><td></td><td class="fit">CA82</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">CA83</td>
				<td>85 D6</td>
				<td class="fit">STA $D6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA85</td>
				<td>4C 3B E3</td>
				<td class="fit">JMP $E33B</td><td rowspan="1"><p>Terminate the routine with a JMP to
ADDR1 ($E33B).</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Rename file in the directory</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RENAME</td><td class="fit">CA88</td>
				<td>20 20 C3</td>
				<td class="fit">JSR $C320</td><td rowspan="1"><p>JSR to ALLDRS ($C320) to set up all the
drives given in the command string.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA8B</td>
				<td>A5 E3</td>
				<td class="fit">LDA $E3</td><td rowspan="3"><p>Load .A with the drive specified for the
second file from FILDRV+1 ($E3). AND it
with $01 to mask off the default drive
bit, and store the result back in
FILDRV+1 ($E3).</p>
</td></tr>
				<tr><td></td><td class="fit">CA8D</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">CA8F</td>
				<td>85 E3</td>
				<td class="fit">STA $E3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA91</td>
				<td>C5 E2</td>
				<td class="fit">CMP $E2</td><td rowspan="2"><p>Compare the second drive number (in .A)
with the first one in FILDRV ($E2). If
equal, branch to RN10.</p>
</td></tr>
				<tr><td></td><td class="fit">CA93</td>
				<td>F0 02</td>
				<td class="fit">BEQ $CA97</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA95</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td><td rowspan="1"><p>OR the drive number in .A with $80 to
set bit 7. This will force a search of
both drives for the named file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RN10</td><td class="fit">CA97</td>
				<td>85 E2</td>
				<td class="fit">STA $E2</td><td rowspan="1"><p>Store the value in .A into FILDRV ($E2)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA99</td>
				<td>20 4F C4</td>
				<td class="fit">JSR $C44F</td><td rowspan="1"><p>JSR to LOOKUP ($C44F) to look up both
file names in the directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA9C</td>
				<td>20 E7 CA</td>
				<td class="fit">JSR $CAE7</td><td rowspan="1"><p>JSR to CHKIO ($CAE7) to check for the
existance of the files named.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CA9F</td>
				<td>A5 E3</td>
				<td class="fit">LDA $E3</td><td rowspan="3"><p>Load the value from FILDRV+1 ($E3), AND
it with $01 to mask off the default
drive bit, and use the result to set the
currently active drive, DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">CAA1</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">CAA3</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAA5</td>
				<td>A5 D9</td>
				<td class="fit">LDA $D9</td><td rowspan="2"><p>Set the active sector number, SECTOR
($81) using the directory sector in
which the second file name was found
(from ENTSEC+1; $D9).</p>
</td></tr>
				<tr><td></td><td class="fit">CAA7</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAA9</td>
				<td>20 57 DE</td>
				<td class="fit">JSR $DE57</td><td rowspan="1"><p>JSR to RDAB ($DE57) to read the
directory sector specified in TRACK ($80)
and SECTOR ($81) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAAC</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAAF</td>
				<td>A5 DE</td>
				<td class="fit">LDA $DE</td><td rowspan="4"><p>Load .A with the pointer to the entry in
the buffer from ENTIND+1 ($DE). add $03
(so it points to the first character in
the file name), and JSR to SETPNT ($D4C8)
to set the pointers to the file name.</p>
</td></tr>
				<tr><td></td><td class="fit">CAB1</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">CAB2</td>
				<td>69 03</td>
				<td class="fit">ADC #$03</td></tr>
				<tr><td></td><td class="fit">CAB4</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAB7</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to store the
active buffer number in .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CABA</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="4"><p>Transfer the buffer number to .Y. load
.X from the file table FILTBL ($027A),
.A with $10 (the number of characters
in a file name) and JSR to TRNAME ($C66E)
to transfer the file name from the
command string to the buffer containing
the file entry.</p>
</td></tr>
				<tr><td></td><td class="fit">CABB</td>
				<td>AE 7A 02</td>
				<td class="fit">LDX $027A</td></tr>
				<tr><td></td><td class="fit">CABE</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td></tr>
				<tr><td></td><td class="fit">CAC0</td>
				<td>20 6E C6</td>
				<td class="fit">JSR $C66E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAC3</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write out the
revised directory sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAC6</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAC9</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate the routine with a JMP to
ENDCMD ($C194) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CHKIN</td><td class="fit">CACC</td>
				<td>A5 E8</td>
				<td class="fit">LDA $E8</td><td rowspan="3"><p>Check existance of input file:
Load .A with the first file type from
PATTYP+1 ($E8). AND it with the file
type mask ($07) and store it in TYPE
($024A) .</p>
</td></tr>
				<tr><td></td><td class="fit">CACE</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">CAD0</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAD3</td>
				<td>AE 78 02</td>
				<td class="fit">LDX $0278</td><td rowspan="1"><p>Load .X from F2CNT ($0278).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CK10</td><td class="fit">CAD6</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement .X by 1 and compare it with
the value of F1CNT ($0277).</p>
</td></tr>
				<tr><td></td><td class="fit">CAD7</td>
				<td>EC 77 02</td>
				<td class="fit">CPX $0277</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CADA</td>
				<td>90 0A</td>
				<td class="fit">BCC $CAE6</td><td rowspan="1"><p>If the carry is clear, the file has been
found so branch to CK10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CADC</td>
				<td>BD 80 02</td>
				<td class="fit">LDA $0280,X</td><td rowspan="2"><p>Load .A with the file's track link from
FILTRK f X ($0280, X). If link is NOT $00,
branch to CK10.</p>
</td></tr>
				<tr><td></td><td class="fit">CADF</td>
				<td>D0 F5</td>
				<td class="fit">BNE $CAD6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAE1</td>
				<td>A9 62</td>
				<td class="fit">LDA #$62</td><td rowspan="2"><p>Since the file has not been found, load
.A with $62 and exit with a JMP to
CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">CAE3</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CK20</td><td class="fit">CAE6</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CHKIO</td><td class="fit">CAE7</td>
				<td>20 CC CA</td>
				<td class="fit">JSR $CACC</td><td rowspan="1"><p>Check existance of I/O file:
JSR to CHKIN ($CACC) to check for the
existance of the input file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CK25</td><td class="fit">CAEA</td>
				<td>BD 80 02</td>
				<td class="fit">LDA $0280,X</td><td rowspan="2"><p>Load .A with the file's track link from
FILTRK,X ($0280, X). If link equals $00,
branch to CK30.</p>
</td></tr>
				<tr><td></td><td class="fit">CAED</td>
				<td>F0 05</td>
				<td class="fit">BEQ $CAF4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAEF</td>
				<td>A9 63</td>
				<td class="fit">LDA #$63</td><td rowspan="2"><p>The file already exists so load .A with
$62 and exit with a JMP to CMDERR ($C1C8)</p>
</td></tr>
				<tr><td></td><td class="fit">CAF1</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CK30</td><td class="fit">CAF4</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement .X (file counter). If more
files exist, branch back to CK25.
CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">CAF5</td>
				<td>10 F3</td>
				<td class="fit">BPL $CAEA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAF7</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Memory access commands (M-R, M-W, AND M-E)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MEM</td><td class="fit">CAF8</td>
				<td>AD 01 02</td>
				<td class="fit">LDA $0201</td><td rowspan="3"><p>Check that the second character in the
command is a &quot;-&quot; by: loading .A with
the character from CMDBUF + 1 ($0201) ,
and comparing it with $2D (&quot;-&quot;). If not
equal, branch to MEMERR ($CB4B).</p>
</td></tr>
				<tr><td></td><td class="fit">CAFB</td>
				<td>C9 2D</td>
				<td class="fit">CMP #$2D</td></tr>
				<tr><td></td><td class="fit">CAFD</td>
				<td>D0 4C</td>
				<td class="fit">BNE $CB4B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CAFF</td>
				<td>AD 03 02</td>
				<td class="fit">LDA $0203</td><td rowspan="4"><p>Set up address specified in command by
moving the characters from CMDBUF+3
($0202) and CMDBUF+4 ($0203) to TEMP
($6F) and TEMP+1 ($70) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB02</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">CB04</td>
				<td>AD 04 02</td>
				<td class="fit">LDA $0204</td></tr>
				<tr><td></td><td class="fit">CB07</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB09</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Set .Y to $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB0B</td>
				<td>AD 02 02</td>
				<td class="fit">LDA $0202</td><td rowspan="1"><p>Load .A with the third character of the
command (R,W,E) from CMDBUF+2 ($0202) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB0E</td>
				<td>C9 52</td>
				<td class="fit">CMP #$52</td><td rowspan="2"><p>Compare .A with &quot;R&quot;. If equal, branch
to MEMRD ($CB20) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB10</td>
				<td>F0 0E</td>
				<td class="fit">BEQ $CB20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB12</td>
				<td>20 58 F2</td>
				<td class="fit">JSR $F258</td><td rowspan="1"><p>JSR to KILLP ($F258) to kill protection,
NOTE: this does nothing on the 1541!</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB15</td>
				<td>C9 57</td>
				<td class="fit">CMP #$57</td><td rowspan="2"><p>Compare .A with &quot;W&quot;. If equal, branch
to MEMWRT ($CB50) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB17</td>
				<td>F0 37</td>
				<td class="fit">BEQ $CB50</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB19</td>
				<td>C9 45</td>
				<td class="fit">CMP #$45</td><td rowspan="2"><p>Compare .A with &quot;E&quot;. If NOT equal,
branch to MEMERR ($CB4B).</p>
</td></tr>
				<tr><td></td><td class="fit">CB1B</td>
				<td>D0 2E</td>
				<td class="fit">BNE $CB4B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MEMEX</td><td class="fit">CB1D</td>
				<td>6C 6F 00</td>
				<td class="fit">JMP ($006F)</td><td rowspan="1"><p>Do indirect jump using the pointer set
up in TEMP ($006F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MEMRD</td><td class="fit">CB20</td>
				<td>B1 6F</td>
				<td class="fit">LDA ($6F),Y</td><td rowspan="2"><p>Load .A with the contents of (TEMP) ,Y
($6F) ,Y and store the value in DATA($85)</p>
</td></tr>
				<tr><td></td><td class="fit">CB22</td>
				<td>85 85</td>
				<td class="fit">STA $85</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB24</td>
				<td>AD 74 02</td>
				<td class="fit">LDA $0274</td><td rowspan="3"><p>Compare the command string length, CMDSIZ
($0274), with $06. If it is less than or
equal to 6 (normally 5). branch to M30.</p>
</td></tr>
				<tr><td></td><td class="fit">CB27</td>
				<td>C9 06</td>
				<td class="fit">CMP #$06</td></tr>
				<tr><td></td><td class="fit">CB29</td>
				<td>90 1A</td>
				<td class="fit">BCC $CB45</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Multi-byte memory read:</h1>
<pre><code>Note: Previously undocumented command!!
      PRINT#15,&quot;M-R&quot;;CHR$(LO); CHR$(HI); CHR$(HOW MANY)</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MRMULT</td><td class="fit">CB2B</td>
				<td>AE 05 02</td>
				<td class="fit">LDX $0205</td><td rowspan="1"><p>Load .X with the 6th character in the
command string from CMDBUF+5 ($0205).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB2E</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="1"><p>Decrement .X (now $00 if only one to
read) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB2F</td>
				<td>F0 14</td>
				<td class="fit">BEQ $CB45</td><td rowspan="1"><p>If the result is $00, all done so branch
to M30.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB31</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer the value in .X to .A and clear
the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">CB32</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB33</td>
				<td>65 6F</td>
				<td class="fit">ADC $6F</td><td rowspan="1"><p>Add the lo byte of the memory pointer
in TEMP ($6F). This value is the lo
byte of the last character to be sent.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB35</td>
				<td>E6 6F</td>
				<td class="fit">INC $6F</td><td rowspan="1"><p>Increment the lo byte pointer in TEMP
($6F) so it points to the second memory
location to be read.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB37</td>
				<td>8D 49 02</td>
				<td class="fit">STA $0249</td><td rowspan="1"><p>Store the value in .A into LSTCHR+ERRCHN
($0249) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB3A</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="2"><p>Load .A with the current value of TEMP
($6A). the lo byte of the second memory
location to be read and store this value
in CB+2 ($A5) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB3C</td>
				<td>85 A5</td>
				<td class="fit">STA $A5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB3E</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td><td rowspan="2"><p>Load .A with the current value of TEMP+1
($70). the hi byte of the second memory
location to be read and store this value
in CB+3 ($A6) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB40</td>
				<td>85 A6</td>
				<td class="fit">STA $A6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB42</td>
				<td>4C 43 D4</td>
				<td class="fit">JMP $D443</td><td rowspan="1"><p>Continue memory read with a JMP to GE20
($D443) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">M30</td><td class="fit">CB45</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB48</td>
				<td>4C 3A D4</td>
				<td class="fit">JMP $D43A</td><td rowspan="1"><p>Terminate memory read with a JMP to
GE15 ($D43A).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MEMERR</td><td class="fit">CB4B</td>
				<td>A9 31</td>
				<td class="fit">LDA #$31</td><td rowspan="2"><p>Load .A with $31 to indicate a bad
command and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">CB4D</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MEMWRT</td><td class="fit">CB50</td>
				<td>B9 06 02</td>
				<td class="fit">LDA $0206,Y</td><td rowspan="2"><p>Move byte from CMDBUF+6,Y ($0206, Y) to
memory at TEMP,Y ($BF,Y).</p>
</td></tr>
				<tr><td></td><td class="fit">CB53</td>
				<td>91 6F</td>
				<td class="fit">STA ($6F),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB55</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="2"><p>Increment .Y and compare .Y with the
number of bytes to do, CMDBUF+5 ($0205).</p>
</td></tr>
				<tr><td></td><td class="fit">CB56</td>
				<td>CC 05 02</td>
				<td class="fit">CPY $0205</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB59</td>
				<td>90 F5</td>
				<td class="fit">BCC $CB50</td><td rowspan="1"><p>If more to do, branch back to M10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB5B</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate memory write with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>User commands</h1>
<pre><code>Note: U0 restores pointer to JMP table</code></pre>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>User jump commands</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">USER</td><td class="fit">CB5C</td>
				<td>AC 01 02</td>
				<td class="fit">LDY $0201</td><td rowspan="1"><p>Load .Y with the second byte of the
command string from CMDBUF+1 ($0201) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB5F</td>
				<td>C0 30</td>
				<td class="fit">CPY #$30</td><td rowspan="2"><p>Compare .Y to $30. If not equal, this
is NOT a U0 command so branch to US10.</p>
</td></tr>
				<tr><td></td><td class="fit">CB61</td>
				<td>D0 09</td>
				<td class="fit">BNE $CB6C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">USRINT</td><td class="fit">CB63</td>
				<td>A9 EA</td>
				<td class="fit">LDA #$EA</td><td rowspan="4"><p>Restore normal user jump address ($FFEA)
storing $EA in USRJMP ($6B) and $FF in
USRJMP+1 ($6C) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB65</td>
				<td>85 6B</td>
				<td class="fit">STA $6B</td></tr>
				<tr><td></td><td class="fit">CB67</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td></tr>
				<tr><td></td><td class="fit">CB69</td>
				<td>85 6C</td>
				<td class="fit">STA $6C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB6B</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">US10</td><td class="fit">CB6C</td>
				<td>20 72 CB</td>
				<td class="fit">JSR $CB72</td><td rowspan="1"><p>JSR to USREXC ($CB72) to execute the
code according to the jump table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB6F</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C194) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">USREXC</td><td class="fit">CB72</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="5"><p>Decrement .Y, transfer the value to .A,
AND it with $0F to convert it to hex,
multiply it by two (ASL). and transfer
the result back into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">CB73</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">CB74</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">CB76</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">CB77</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB78</td>
				<td>B1 6B</td>
				<td class="fit">LDA ($6B),Y</td><td rowspan="2"><p>Transfer the lo byte of the user jump
address from the table at (USRJMP) ,Y
to IP ($75) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB7A</td>
				<td>85 75</td>
				<td class="fit">STA $75</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB7C</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB7D</td>
				<td>B1 6B</td>
				<td class="fit">LDA ($6B),Y</td><td rowspan="2"><p>Transfer the hi byte of the user jump
address from the table at (USRJMP) ,Y
to IP + 1 ($76) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB7F</td>
				<td>85 76</td>
				<td class="fit">STA $76</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB81</td>
				<td>6C 75 00</td>
				<td class="fit">JMP ($0075)</td><td rowspan="1"><p>Do an indirect jump to the user code
through the vector at IP ($0076) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open direct access buffer in response to an OPEN &quot;#&quot; command</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPNBLK</td><td class="fit">CB84</td>
				<td>AD 8E 02</td>
				<td class="fit">LDA $028E</td><td rowspan="2"><p>Use the previous drive number, LSTDRV
($028E) to set the current drive number
DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">CB87</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB89</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="2"><p>Save the current secondary address, SA
($83) on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">CB8B</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB8C</td>
				<td>20 3D C6</td>
				<td class="fit">JSR $C63D</td><td rowspan="1"><p>JSR to AUTOI ($C63D) to initialize the
disk. This is necessary for proper
channel assignment.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB8F</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Restore the original secondary address ,
SA ($83) by pulling it off the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">CB90</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB92</td>
				<td>AE 74 02</td>
				<td class="fit">LDX $0274</td><td rowspan="2"><p>Load .X with the command string length
CMDSIZ ($0274). Decrement .X by 1.</p>
</td></tr>
				<tr><td></td><td class="fit">CB95</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB96</td>
				<td>D0 0D</td>
				<td class="fit">BNE $CBA5</td><td rowspan="1"><p>If .X not egual to zero, a specific
buffer number has been requested (e .g. #1)
so branch to OB10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB98</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>No specific buffer requested so get any
available buffer by loading .A with $01
and doing a JSR to GETRCH ($D1E2).</p>
</td></tr>
				<tr><td></td><td class="fit">CB9A</td>
				<td>20 E2 D1</td>
				<td class="fit">JSR $D1E2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CB9D</td>
				<td>4C F1 CB</td>
				<td class="fit">JMP $CBF1</td><td rowspan="1"><p>On return, JMP to OB30.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OB05</td><td class="fit">CBA0</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td><td rowspan="2"><p>Load .A with $70 to indicate that no
channel is available and JMP to CMDERR
($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">CBA2</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OB10</td><td class="fit">CBA5</td>
				<td>A0 01</td>
				<td class="fit">LDY #$01</td><td rowspan="2"><p>Specific buffer requested so load .Y
with $01 and JSR to BP05 ($CC7C) to
check the block parameters.</p>
</td></tr>
				<tr><td></td><td class="fit">CBA7</td>
				<td>20 7C CC</td>
				<td class="fit">JSR $CC7C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBAA</td>
				<td>AE 85 02</td>
				<td class="fit">LDX $0285</td><td rowspan="3"><p>Load .X with the number of the buffer
requested from FILSEC ($0285) and check
it against $05 (the highest numbered
buffer available). If too large, branch
to OB05 and abort the command.</p>
</td></tr>
				<tr><td></td><td class="fit">CBAD</td>
				<td>E0 05</td>
				<td class="fit">CPX #$05</td></tr>
				<tr><td></td><td class="fit">CBAF</td>
				<td>B0 EF</td>
				<td class="fit">BCS $CBA0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBB1</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Set TEMP ($6F) and TEMP+1 ($70) to $00
and set the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">CBB3</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">CBB5</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">CBB7</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OB15</td><td class="fit">CBB8</td>
				<td>26 6F</td>
				<td class="fit">ROL $6F</td><td rowspan="4"><p>Loop to shift a 1 into the bit position
in TEMP or TEMP+1 that corresponds to
the buffer requested.</p>
<p>For example:</p>
<pre><code>TEMP+1 (00000000) TEMP (00000001) = buffer 0
TEMP+1 (00000000) TEMP (00000100) = buffer 2
TEMP+1 (00000001) TEMP (00000000) = buffer 8</code></pre>
</td></tr>
				<tr><td></td><td class="fit">CBBA</td>
				<td>26 70</td>
				<td class="fit">ROL $70</td></tr>
				<tr><td></td><td class="fit">CBBC</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">CBBD</td>
				<td>10 F9</td>
				<td class="fit">BPL $CBB8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBBF</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="3"><p>Load .A with the value in TEMP ($6F)
and AND it with the value in BUFUSE
($024F) which indicates which buffers
are already in use. If the result is
NOT $00, the buffer requested is already
in use so branch to OB05 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">CBC1</td>
				<td>2D 4F 02</td>
				<td class="fit">AND $024F</td></tr>
				<tr><td></td><td class="fit">CBC4</td>
				<td>D0 DA</td>
				<td class="fit">BNE $CBA0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBC6</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td><td rowspan="3"><p>Load .A with the value in TEMP+1 ($70)
and AND it with the value in BUFUSE+1
($0250) which indicates which buffers
are already in use. If the result is
NOT $00, the buffer requested is already
in use so branch to OB05 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">CBC8</td>
				<td>2D 50 02</td>
				<td class="fit">AND $0250</td></tr>
				<tr><td></td><td class="fit">CBCB</td>
				<td>D0 D3</td>
				<td class="fit">BNE $CBA0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBCD</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="6"><p>Mark the buffer requested as in use by
ORing the value in TEMP with the value
in BUFUSE and the value in TEMP+1 with
the value in BUFUSE+1.</p>
</td></tr>
				<tr><td></td><td class="fit">CBCF</td>
				<td>0D 4F 02</td>
				<td class="fit">ORA $024F</td></tr>
				<tr><td></td><td class="fit">CBD2</td>
				<td>8D 4F 02</td>
				<td class="fit">STA $024F</td></tr>
				<tr><td></td><td class="fit">CBD5</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td></tr>
				<tr><td></td><td class="fit">CBD7</td>
				<td>0D 50 02</td>
				<td class="fit">ORA $0250</td></tr>
				<tr><td></td><td class="fit">CBDA</td>
				<td>8D 50 02</td>
				<td class="fit">STA $0250</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBDD</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set up the channel by loading .A with
$00 and doing a JSR to GETRCH ($D1E2)
to find an unused read channel.</p>
</td></tr>
				<tr><td></td><td class="fit">CBDF</td>
				<td>20 E2 D1</td>
				<td class="fit">JSR $D1E2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBE2</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel* from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBE4</td>
				<td>AD 85 02</td>
				<td class="fit">LDA $0285</td><td rowspan="2"><p>Use .X as an index to move the sector
link from FILSEC ($0285) to BUFO. X ($A7 , X)</p>
</td></tr>
				<tr><td></td><td class="fit">CBE7</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBE9</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the sector link from .A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBEA</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>Use .X as an index to move the current
drive number from DRVNUM($7F) to JOBS,X
($00, X) and to LSTJOB,X ($025B,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">CBEC</td>
				<td>95 00</td>
				<td class="fit">STA $00,X</td></tr>
				<tr><td></td><td class="fit">CBEE</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OB30</td><td class="fit">CBF1</td>
				<td>A6 83</td>
				<td class="fit">LDX $83</td><td rowspan="1"><p>Load .X with the current secondary
address, SA ($83) </p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBF3</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td><td rowspan="3"><p>Load .A with the current value from the
logical index table, LINTAB,X ($022B,X) .
OR this value with $40 to indicate that
it is read/write mode and store the
result back in LINTAB,X.</p>
</td></tr>
				<tr><td></td><td class="fit">CBF6</td>
				<td>09 40</td>
				<td class="fit">ORA #$40</td></tr>
				<tr><td></td><td class="fit">CBF8</td>
				<td>9D 2B 02</td>
				<td class="fit">STA $022B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBFB</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the current channel#, LINDX
($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CBFD</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Load .A with $FF and store this value
as the channel's last character pointer
LSTCHR,Y ($0244, Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">CBFF</td>
				<td>99 44 02</td>
				<td class="fit">STA $0244,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC02</td>
				<td>A9 89</td>
				<td class="fit">LDA #$89</td><td rowspan="2"><p>Load .A with $89 and store this value
in CHNRDY,Y ($00F2,Y) to indicate that
the channel is a random access one and
is ready.</p>
</td></tr>
				<tr><td></td><td class="fit">CC04</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC07</td>
				<td>B9 A7 00</td>
				<td class="fit">LDA $00A7,Y</td><td rowspan="2"><p>Load .A with the channel number from
BUF0,Y ($00A7,Y) and store it in
CHNDAT,Y($023E,Y) as the first character</p>
</td></tr>
				<tr><td></td><td class="fit">CC0A</td>
				<td>99 3E 02</td>
				<td class="fit">STA $023E,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC0D</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the sector value in .A by 2
and transfer the result into .X</p>
</td></tr>
				<tr><td></td><td class="fit">CC0E</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC0F</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Set the buffer table value BUFTAB,X
($99, X) to $01.</p>
</td></tr>
				<tr><td></td><td class="fit">CC11</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC13</td>
				<td>A9 0E</td>
				<td class="fit">LDA #$0E</td><td rowspan="2"><p>Set the file type value FILTYP,Y ($EC,Y)
to $0E to indicate a direct access file
type.</p>
</td></tr>
				<tr><td></td><td class="fit">CC15</td>
				<td>99 EC 00</td>
				<td class="fit">STA $00EC,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC18</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C1C4) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Block commands (B-A; B-F; B-R; B-W; B-E; B-P)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLOCK</td><td class="fit">CC1B</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Zero .X and .Y. Load .A with $2D (&quot;-&quot;)
and JSR to PARSE ($C268) to locate the
sub-command (separated from the command
with a &quot;-&quot;) .</p>
</td></tr>
				<tr><td></td><td class="fit">CC1D</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
				<tr><td></td><td class="fit">CC1F</td>
				<td>A9 2D</td>
				<td class="fit">LDA #$2D</td></tr>
				<tr><td></td><td class="fit">CC21</td>
				<td>20 68 C2</td>
				<td class="fit">JSR $C268</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC24</td>
				<td>D0 0A</td>
				<td class="fit">BNE $CC30</td><td rowspan="1"><p>On return branch to BLK40 if Z flag is
not set (&quot;-&quot; was found).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLK10</td><td class="fit">CC26</td>
				<td>A9 31</td>
				<td class="fit">LDA #$31</td><td rowspan="2"><p>Load .A with $31 to indicate a bad
command and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">CC28</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLK30</td><td class="fit">CC2B</td>
				<td>A9 30</td>
				<td class="fit">LDA #$30</td><td rowspan="2"><p>Load .A with $30 to indicate a bad
syntax and JMP to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">CC2D</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLK40</td><td class="fit">CC30</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer the value in .X to .A. If not
$00, branch to BLK30.</p>
</td></tr>
				<tr><td></td><td class="fit">CC31</td>
				<td>D0 F8</td>
				<td class="fit">BNE $CC2B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC33</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td><td rowspan="1"><p>Load .X with $05 (the number of block
commands - 1) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC35</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td><td rowspan="1"><p>Load .A with the first character in the
sub-command from CMDBUF,Y ($0200, Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLK50</td><td class="fit">CC38</td>
				<td>DD 5D CC</td>
				<td class="fit">CMP $CC5D,X</td><td rowspan="5"><p>Loop to compare the first character in
the sub-command with the characters in
the command table BCTAB,X ($CC5D,X). If
a match is found. branch to BLK60. If NO
MATCH is found, branch to BLK10.</p>
</td></tr>
				<tr><td></td><td class="fit">CC3B</td>
				<td>F0 05</td>
				<td class="fit">BEQ $CC42</td></tr>
				<tr><td></td><td class="fit">CC3D</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">CC3E</td>
				<td>10 F8</td>
				<td class="fit">BPL $CC38</td></tr>
				<tr><td></td><td class="fit">CC40</td>
				<td>30 E4</td>
				<td class="fit">BMI $CC26</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLK60</td><td class="fit">CC42</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the pointer to the command in
the command table from .X to .A. OR this
value with $80 and store it as the
command number in CMDNUM ($022A) .</p>
</td></tr>
				<tr><td></td><td class="fit">CC43</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td></tr>
				<tr><td></td><td class="fit">CC45</td>
				<td>8D 2A 02</td>
				<td class="fit">STA $022A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC48</td>
				<td>20 6F CC</td>
				<td class="fit">JSR $CC6F</td><td rowspan="1"><p>JSR to BLKPAR ($CC6F) to parse the
block parameters.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC4B</td>
				<td>AD 2A 02</td>
				<td class="fit">LDA $022A</td><td rowspan="3"><p>Load .A with the command number from
CMDNUM ($022A), multiply it by 2 (ASL) ,
and transfer the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">CC4E</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">CC4F</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC50</td>
				<td>BD 64 CC</td>
				<td class="fit">LDA $CC64,X</td><td rowspan="4"><p>Use .X as an index into the jump table
BCJMP,X ($CC63) to set up a jump vector
to the ROM routine at TEMP ($6F/70) .</p>
</td></tr>
				<tr><td></td><td class="fit">CC53</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">CC55</td>
				<td>BD 63 CC</td>
				<td class="fit">LDA $CC63,X</td></tr>
				<tr><td></td><td class="fit">CC58</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC5A</td>
				<td>6C 6F 00</td>
				<td class="fit">JMP ($006F)</td><td rowspan="1"><p>Do an indirect JMP to the appropriate
ROM routine via the vector at TEMP($6F).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC5D</td>
				<td>41 46 52 57 45 50</td>
				<td class="fit"></td><td rowspan="1"><p>Block sub-command table ($CC5D-$CC62)
.BYTE &quot;AFRWEP&quot;</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC63</td>
				<td>03 CD F5 CC 56 CD 73 CD A3 CD BD CD</td>
				<td class="fit"></td><td rowspan="1"><p>Block jump table ($CC63-$CC6E)</p>
<pre><code>Address | Bytes     | Function       |Func address
--------|-----------|----------------|------------
$CC63/4 | $03,$CD   | BLOCK-ALLOCATE |$CD03
$CC65/6 | $F5,$CC   | BLOCK-FREE     |$CCF5
$CC67/8 | $56,$CD   | BLOCK-READ     |$CD56
$CC69/A | $73,$CD   | BLOCK-WRITE    |$CD73
$CC6B/C | $A3,$CD   | BLOCK-EXECUTE  |$CDA3
$CC6D/E | $BD,$CD   | BLOCK-POINTER  |$CDBD</code></pre>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Parse the block parameters</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKPAR</td><td class="fit">CC6F</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Zero .X and .Y. Load .A with $3A ( &quot; : &quot; )
and JSR to PARSE ($C268) to find the
colon, if any.</p>
</td></tr>
				<tr><td></td><td class="fit">CC71</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
				<tr><td></td><td class="fit">CC73</td>
				<td>A9 3A</td>
				<td class="fit">LDA #$3A</td></tr>
				<tr><td></td><td class="fit">CC75</td>
				<td>20 68 C2</td>
				<td class="fit">JSR $C268</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC78</td>
				<td>D0 02</td>
				<td class="fit">BNE $CC7C</td><td rowspan="1"><p>On return branch to BP05 if Z flag is
not set (&quot;:&quot; found; .Y=&quot;:&quot;-position+1)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC7A</td>
				<td>A0 03</td>
				<td class="fit">LDY #$03</td><td rowspan="1"><p>Load .Y with $03 (start of parameters)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BP05</td><td class="fit">CC7C</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td><td rowspan="1"><p>Load .A with the .Yth character from
the command string.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC7F</td>
				<td>C9 20</td>
				<td class="fit">CMP #$20</td><td rowspan="2"><p>Compare the character in .A with $20,
(a space). If equal, branch to BP10.</p>
</td></tr>
				<tr><td></td><td class="fit">CC81</td>
				<td>F0 08</td>
				<td class="fit">BEQ $CC8B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC83</td>
				<td>C9 1D</td>
				<td class="fit">CMP #$1D</td><td rowspan="2"><p>Compare the character in .A with $29,
(a skip chr). If equal, branch to BP10.</p>
</td></tr>
				<tr><td></td><td class="fit">CC85</td>
				<td>F0 04</td>
				<td class="fit">BEQ $CC8B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC87</td>
				<td>C9 2C</td>
				<td class="fit">CMP #$2C</td><td rowspan="2"><p>Compare the character in .A with $2C,
(a comma). If NOT equal, branch to BP20</p>
</td></tr>
				<tr><td></td><td class="fit">CC89</td>
				<td>D0 07</td>
				<td class="fit">BNE $CC92</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BP10</td><td class="fit">CC8B</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y. Compare .Y to the length
of the command string in CMDSIZ ($0274) ,
If more left, branch back to BP05.</p>
</td></tr>
				<tr><td></td><td class="fit">CC8C</td>
				<td>CC 74 02</td>
				<td class="fit">CPY $0274</td></tr>
				<tr><td></td><td class="fit">CC8F</td>
				<td>90 EB</td>
				<td class="fit">BCC $CC7C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC91</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>If no more, exit with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BP20</td><td class="fit">CC92</td>
				<td>20 A1 CC</td>
				<td class="fit">JSR $CCA1</td><td rowspan="1"><p>JSR to ASCHEX ($CCA1) to convert ASCII
values into hex and store the results
in tables.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC95</td>
				<td>EE 77 02</td>
				<td class="fit">INC $0277</td><td rowspan="1"><p>Increment the number of parameters
processed F1CNT ($0277) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC98</td>
				<td>AC 79 02</td>
				<td class="fit">LDY $0279</td><td rowspan="1"><p>Load .Y with the value in F2PTR ($0279)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC9B</td>
				<td>E0 04</td>
				<td class="fit">CPX #$04</td><td rowspan="2"><p>Compare the value in .X (the original
value of F1CNT ($0277) to $04 (the
maximun number of files - 1). If the
value in .X &lt;= $04, branch to BP10.</p>
</td></tr>
				<tr><td></td><td class="fit">CC9D</td>
				<td>90 EC</td>
				<td class="fit">BCC $CC8B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CC9F</td>
				<td>B0 8A</td>
				<td class="fit">BCS $CC2B</td><td rowspan="1"><p>If .X was &gt; $04. the syntax is bad so
branch to BLK30 ($CC2B) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert ASCII to HEX</h1>
<p>It stores the converted values in the FILTRK ($0280)
and FILSEC ($0285) tables</p>
<p>On entry: .Y = pointer into CMD buffer</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ASCHEX</td><td class="fit">CCA1</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Zero TEMP($6F) r TEMP+1 ($70), and TEMP+3
($72) as a work area.</p>
</td></tr>
				<tr><td></td><td class="fit">CCA3</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">CCA5</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">CCA7</td>
				<td>85 72</td>
				<td class="fit">STA $72</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCA9</td>
				<td>A2 FF</td>
				<td class="fit">LDX #$FF</td><td rowspan="1"><p>Load .X with $FF.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AH10</td><td class="fit">CCAB</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td><td rowspan="1"><p>Load .A with the command string byte
from CMDBUF,Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCAE</td>
				<td>C9 40</td>
				<td class="fit">CMP #$40</td><td rowspan="2"><p>Test if the character in .A is numeric
by comparing it to $40. If non-numeric,
branch to AH20.</p>
</td></tr>
				<tr><td></td><td class="fit">CCB0</td>
				<td>B0 18</td>
				<td class="fit">BCS $CCCA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCB2</td>
				<td>C9 30</td>
				<td class="fit">CMP #$30</td><td rowspan="2"><p>Test if the character in .A is ASCII
by comparing it to $30. If it is not an
ASCII digit, branch to AH20.</p>
</td></tr>
				<tr><td></td><td class="fit">CCB4</td>
				<td>90 14</td>
				<td class="fit">BCC $CCCA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCB6</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="2"><p>AND the ASCII digit with $0F to mask
off the higher order bits and save this
new value on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">CCB8</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCB9</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td><td rowspan="4"><p>Shift the values already in the table
one position (TEMP+1 goes into TEMP+2;
TEMP goes into TEMP+1) .</p>
</td></tr>
				<tr><td></td><td class="fit">CCBB</td>
				<td>85 71</td>
				<td class="fit">STA $71</td></tr>
				<tr><td></td><td class="fit">CCBD</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td></tr>
				<tr><td></td><td class="fit">CCBF</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCC1</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the new value off the stack and
store it in TEMP.</p>
</td></tr>
				<tr><td></td><td class="fit">CCC2</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCC4</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y and compare it to the
command length stored in CMDSIZ ($0274) .
If more command left, branch back to
AH10.
Convert the values in the TEMP table
into a single hex byte:</p>
</td></tr>
				<tr><td></td><td class="fit">CCC5</td>
				<td>CC 74 02</td>
				<td class="fit">CPY $0274</td></tr>
				<tr><td></td><td class="fit">CCC8</td>
				<td>90 E1</td>
				<td class="fit">BCC $CCAB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AH20</td><td class="fit">CCCA</td>
				<td>8C 79 02</td>
				<td class="fit">STY $0279</td><td rowspan="3"><p>Save the .Y pointer to the command
string into F2PTR ($0279). clear the
the carry flag, and load .A with $00.</p>
</td></tr>
				<tr><td></td><td class="fit">CCCD</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">CCCE</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AH30</td><td class="fit">CCD0</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="1"><p>Increment .X by 1 (index into TEMP) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCD1</td>
				<td>E0 03</td>
				<td class="fit">CPX #$03</td><td rowspan="2"><p>Compare .X to $03 to see if we're done
yet. If done, branch to AH40.</p>
</td></tr>
				<tr><td></td><td class="fit">CCD3</td>
				<td>B0 0F</td>
				<td class="fit">BCS $CCE4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCD5</td>
				<td>B4 6F</td>
				<td class="fit">LDY $6F,X</td><td rowspan="1"><p>Load .Y from TEMP,Y ($6F,Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AH35</td><td class="fit">CCD7</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement .Y by 1. If Y&lt;0 branch to AH30</p>
</td></tr>
				<tr><td></td><td class="fit">CCD8</td>
				<td>30 F6</td>
				<td class="fit">BMI $CCD0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCDA</td>
				<td>7D F2 CC</td>
				<td class="fit">ADC $CCF2,X</td><td rowspan="2"><p>Add (with carry) the value from DECTAB,X
($CCF2,X) to .A. This adds 1, 10 or 100.
If there is no carry, branch to AH35.</p>
</td></tr>
				<tr><td></td><td class="fit">CCDD</td>
				<td>90 F8</td>
				<td class="fit">BCC $CCD7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCDF</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="3"><p>Since there is a carry, clear the carry,
increment TEMP+3, and branch back to
AH35 .</p>
</td></tr>
				<tr><td></td><td class="fit">CCE0</td>
				<td>E6 72</td>
				<td class="fit">INC $72</td></tr>
				<tr><td></td><td class="fit">CCE2</td>
				<td>D0 F3</td>
				<td class="fit">BNE $CCD7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AH40</td><td class="fit">CCE4</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save the contents of .A (the hex number)
onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCE5</td>
				<td>AE 77 02</td>
				<td class="fit">LDX $0277</td><td rowspan="1"><p>Load .X with the command segment counter
from F1CNT ($0277) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCE8</td>
				<td>A5 72</td>
				<td class="fit">LDA $72</td><td rowspan="2"><p>Load .A with the carry bit (thousands)
from TEMP+3 ($72) and store it in the
table, FILTRK,X ($0280, X).</p>
</td></tr>
				<tr><td></td><td class="fit">CCEA</td>
				<td>9D 80 02</td>
				<td class="fit">STA $0280,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCED</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the hex number off the stack and
store it in the table, FILSEC,X ($0285 ,X)</p>
</td></tr>
				<tr><td></td><td class="fit">CCEE</td>
				<td>9D 85 02</td>
				<td class="fit">STA $0285,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCF1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DECTAB</td><td class="fit">CCF2</td>
				<td>01 0A 64</td>
				<td class="fit"></td><td rowspan="1"><p>The decimal conversion table:
Byte $01 = 1
Byte $0A = 10
Byte $64 = 100</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Free (de-allocate) block in the BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKFRE</td><td class="fit">CCF5</td>
				<td>20 F5 CD</td>
				<td class="fit">JSR $CDF5</td><td rowspan="1"><p>JSR to BLKTST ($CDF5) to test for legal
block and set up track &amp; sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCF8</td>
				<td>20 5F EF</td>
				<td class="fit">JSR $EF5F</td><td rowspan="1"><p>JSR to FRETS ($EF5F) to free the block
in the BAM and mark the BAM as changed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCFB</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
(SC194) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CCFE</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Unused code: LDA #$01 / STA WBAM($02F9)</p>
</td></tr>
				<tr><td></td><td class="fit">CD00</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKALC</td><td class="fit">CD03</td>
				<td>20 F5 CD</td>
				<td class="fit">JSR $CDF5</td><td rowspan="1"><p>Allocate a sector (block) in the BAM:
JSR to BLKTST ($CDF5) to test for legal
block and set up track &amp; sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD06</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Load .A with the current sector pointer
SECTOR ($81) and save this on the stack</p>
</td></tr>
				<tr><td></td><td class="fit">CD08</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD09</td>
				<td>20 FA F1</td>
				<td class="fit">JSR $F1FA</td><td rowspan="1"><p>JSR to GETSEC ($F1FA) to set the BAM and
find the next available sector on this
track.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD0C</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $CD19</td><td rowspan="1"><p>If Z flag is set on return to indicate
that the desired sector is in use and
there is no greater sector available on
this track, branch to BA15.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD0E</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the requested sector from the stack
and compare it to the current contents
of SECTOR ($81). if not equal, the
requested sector is already in use so
branch to BA30.</p>
</td></tr>
				<tr><td></td><td class="fit">CD0F</td>
				<td>C5 81</td>
				<td class="fit">CMP $81</td></tr>
				<tr><td></td><td class="fit">CD11</td>
				<td>D0 19</td>
				<td class="fit">BNE $CD2C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD13</td>
				<td>20 90 EF</td>
				<td class="fit">JSR $EF90</td><td rowspan="2"><p>Requested sector is available so JSR to
WUSED ($EF90, to allocate the sector in
the TM A ^ and terminate the command with
a JMP to ENDCMD ($C194).</p>
</td></tr>
				<tr><td></td><td class="fit">CD16</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BA15</td><td class="fit">CD19</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the desired sector'off the stack,
it is of no further use since that
sector is already in use.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BA20</td><td class="fit">CD1A</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="6"><p>Set the desired sector, SECTOR ($81) to
$00, increment the desired track, TRACK
($80) by 1, and check if we have reached
the maximum track count of 3 5 (taken
from MAXTRK $FECB). If we have gone all
the way, branch to BA40.</p>
</td></tr>
				<tr><td></td><td class="fit">CD1C</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
				<tr><td></td><td class="fit">CD1E</td>
				<td>E6 80</td>
				<td class="fit">INC $80</td></tr>
				<tr><td></td><td class="fit">CD20</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">CD22</td>
				<td>CD D7 FE</td>
				<td class="fit">CMP $FED7</td></tr>
				<tr><td></td><td class="fit">CD25</td>
				<td>B0 0A</td>
				<td class="fit">BCS $CD31</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD27</td>
				<td>20 FA F1</td>
				<td class="fit">JSR $F1FA</td><td rowspan="1"><p>JSR to GETSEC ($F1FA) to set the BAM and
find the next available sector on this
track.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD2A</td>
				<td>F0 EE</td>
				<td class="fit">BEQ $CD1A</td><td rowspan="1"><p>If Z flag is set on return, no greater
sector is available on this track so
branch back to BA20 to try another track</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BA30</td><td class="fit">CD2C</td>
				<td>A9 65</td>
				<td class="fit">LDA #$65</td><td rowspan="2"><p>Requested block is not available so load
.A with $65 to indicate NO BLOCK ERROR
and JMP to CMDER2 ($E645).</p>
</td></tr>
				<tr><td></td><td class="fit">CD2E</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BA40</td><td class="fit">CD31</td>
				<td>A9 65</td>
				<td class="fit">LDA #$65</td><td rowspan="2"><p>No free sectors are available so load
.A with $65 to indicate NO BLOCK ERROR
and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">CD33</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>B-R Sub to test parameters</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKRD2</td><td class="fit">CD36</td>
				<td>20 F2 CD</td>
				<td class="fit">JSR $CDF2</td><td rowspan="1"><p>JSR to BKOTST ($CDF2) to test block
parameters and set track &amp; sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD39</td>
				<td>4C 60 D4</td>
				<td class="fit">JMP $D460</td><td rowspan="1"><p>JMP to DRTRD ($D460) to read block</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETSIM</td><td class="fit">CD3C</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>B-R Sub to get byte w/o increment:
JSR to GETPRE ($D12F) set parameters.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD3F</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="1"><p>Load .A with the value in (BUFTAB,X) ,
($99, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD41</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>B-R Sub to do read</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKRD3</td><td class="fit">CD42</td>
				<td>20 36 CD</td>
				<td class="fit">JSR $CD36</td><td rowspan="1"><p>JSR to BLKRD2 ($CD36) to test parameters</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD45</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and JSR to SETPNT ($D4C8) to set
the track and sector pointers.</p>
</td></tr>
				<tr><td></td><td class="fit">CD47</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD4A</td>
				<td>20 3C CD</td>
				<td class="fit">JSR $CD3C</td><td rowspan="1"><p>JSR to GETSIM ($CD3C) to read block. On
return .Y is the LINDX.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD4D</td>
				<td>99 44 02</td>
				<td class="fit">STA $0244,Y</td><td rowspan="1"><p>Store the byte in .A into LSTCHR,Y
($0244, Y) as the last character.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD50</td>
				<td>A9 89</td>
				<td class="fit">LDA #$89</td><td rowspan="2"><p>Store $89 in CHNRDT, Y ($F2. Y) to indicate
that it is a random access channel and
is now ready.</p>
</td></tr>
				<tr><td></td><td class="fit">CD52</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD55</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Block read a sector</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKRD</td><td class="fit">CD56</td>
				<td>20 42 CD</td>
				<td class="fit">JSR $CD42</td><td rowspan="1"><p>JSR to BLKRD3 ($CD42) to set up to read
the requested sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD59</td>
				<td>20 EC D3</td>
				<td class="fit">JSR $D3EC</td><td rowspan="1"><p>JSR to RNGET1 ($D3EC) to read in the
sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD5C</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C194) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>U1: Block read of a sector</h1>
<pre><code>Note: The only real difference between
      a B-R command and a Ul (preferred) is
      that the Ul command move the last byte
      into the data buffer and stores $FF as
      the last byte read.</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UBLKRD</td><td class="fit">CD5F</td>
				<td>20 6F CC</td>
				<td class="fit">JSR $CC6F</td><td rowspan="1"><p>JSR to BLKPAR ($CC6F) to parse the block
parameters.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD62</td>
				<td>20 42 CD</td>
				<td class="fit">JSR $CD42</td><td rowspan="1"><p>JSR to BLKRD3 ($CD42) to set up to read
the requested sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD65</td>
				<td>B9 44 02</td>
				<td class="fit">LDA $0244,Y</td><td rowspan="2"><p>Move the last character read from
LSTCHR,Y ($0244, Y) to CHNDAT,Y ($023E f Y)</p>
</td></tr>
				<tr><td></td><td class="fit">CD68</td>
				<td>99 3E 02</td>
				<td class="fit">STA $023E,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD6B</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF in LSTCHR,Y ($0244, Y) as the
last character to be read.</p>
</td></tr>
				<tr><td></td><td class="fit">CD6D</td>
				<td>99 44 02</td>
				<td class="fit">STA $0244,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD70</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C194) which ends with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Block-write of a sector</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKWT</td><td class="fit">CD73</td>
				<td>20 F2 CD</td>
				<td class="fit">JSR $CDF2</td><td rowspan="1"><p>JSR to BKOTST ($CDF2) to test the buffer
and block parameters and set up the
drive, track, and sector pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD76</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="1"><p>JSR to GETPNT ($D4E8) to read the active
buffer pointers. On exit, .A points into
the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD79</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="2"><p>Transfer .A to .Y and decrement .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">CD7A</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD7B</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td><td rowspan="2"><p>If the value in .A is greater than $02,
branch to BW10</p>
</td></tr>
				<tr><td></td><td class="fit">CD7D</td>
				<td>B0 02</td>
				<td class="fit">BCS $CD81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD7F</td>
				<td>A0 01</td>
				<td class="fit">LDY #$01</td><td rowspan="1"><p>Load .Y with $01.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BW10</td><td class="fit">CD81</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="1"><p>Load .A with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD83</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td><td rowspan="1"><p>JSR to SETPNT ($D4C8) to set the buffer
pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD86</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Transfer the value in .Y to .A and JSR
to PUTBYT ($CFF1) to put the byte in .A
into the active buffer of LINDX.</p>
</td></tr>
				<tr><td></td><td class="fit">CD87</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD8A</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer the value of .X to .A and save
it on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">CD8B</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BW20</td><td class="fit">CD8C</td>
				<td>20 64 D4</td>
				<td class="fit">JSR $D464</td><td rowspan="1"><p>JSR to DRTWRT ($D464) to write out the
block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD8F</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pop the value off the stack and transfer
it back into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">CD90</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD91</td>
				<td>20 EE D3</td>
				<td class="fit">JSR $D3EE</td><td rowspan="1"><p>JSR to RNGET2 ($D3EE) to set the channel
ready status and last character.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD94</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
/(SC194) which ends with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>U2: Block write of a sector</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UBLKWT</td><td class="fit">CD97</td>
				<td>20 6F CC</td>
				<td class="fit">JSR $CC6F</td><td rowspan="1"><p>JSR to BLKPAR ($CC6F) to parse the block
parameters .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD9A</td>
				<td>20 F2 CD</td>
				<td class="fit">JSR $CDF2</td><td rowspan="1"><p>JSR to BKOTST ($CDF2) to test the buffer
and block parameters and set up the
drive, track, and sector pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CD9D</td>
				<td>20 64 D4</td>
				<td class="fit">JSR $D464</td><td rowspan="1"><p>JSR to DRTWRT ($D464) to write out the
block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDA0</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C194) which ends with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Block execute a sector</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKEXC</td><td class="fit">CDA3</td>
				<td>20 58 F2</td>
				<td class="fit">JSR $F258</td><td rowspan="1"><p>JSR to KILLP ($F258) to kill the disk
protection. Does nothing on the 1541!</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDA6</td>
				<td>20 36 CD</td>
				<td class="fit">JSR $CD36</td><td rowspan="1"><p>JSR to BLKRD2 ($CC6F) to read the sector</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDA9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in TEMP ($6F) as the lo byte
of the JMP address)</p>
</td></tr>
				<tr><td></td><td class="fit">CDAB</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDAD</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="3"><p>Load .X from JOBNUM ($F9) and use it as
an index to load the hi byte of the JMP
address from BUFIND,X ($FEE0,X) and
store it in TEMP+1 ($70).</p>
</td></tr>
				<tr><td></td><td class="fit">CDAF</td>
				<td>BD E0 FE</td>
				<td class="fit">LDA $FEE0,X</td></tr>
				<tr><td></td><td class="fit">CDB2</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDB4</td>
				<td>20 BA CD</td>
				<td class="fit">JSR $CDBA</td><td rowspan="1"><p>JSR to BE10 ($CDBA) to execute the
block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDB7</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C194) which ends with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BE10</td><td class="fit">CDBA</td>
				<td>6C 6F 00</td>
				<td class="fit">JMP ($006F)</td><td rowspan="1"><p>JMP (TEMP) Used by block execute,</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set the buffer pointer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKPTR</td><td class="fit">CDBD</td>
				<td>20 D2 CD</td>
				<td class="fit">JSR $CDD2</td><td rowspan="1"><p>JSR to BUFTST ($CDD2)to test for
allocated buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDC0</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="5"><p>Load the buffer number of the channel
requested from JUBNUM ($F9). multiply
it by two (ASL). and transfer the result
into .X.</p>
<p>Load .A with the new buffer
pointer value from FILSEC+1 ($0286) and
store it in the buffer table BUFTAB,X
($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">CDC2</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">CDC3</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">CDC4</td>
				<td>AD 86 02</td>
				<td class="fit">LDA $0286</td></tr>
				<tr><td></td><td class="fit">CDC7</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDC9</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>JSR to GETPRE ($D12F) to set up pointers</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDCC</td>
				<td>20 EE D3</td>
				<td class="fit">JSR $D3EE</td><td rowspan="1"><p>JSR to RNGET2 ($D3EE) to ready the
channel for I/O</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDCF</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C194) which ends with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BUFTST</td><td class="fit">CDD2</td>
				<td>A6 D3</td>
				<td class="fit">LDX $D3</td><td rowspan="2"><p>Test whether a buffer has been allocated
for the secondary address given in SA.
Load .X with the file stream 1 pointer,
F1PTR ($D3) and then increment the
original pointer F1PTR ($D3).</p>
</td></tr>
				<tr><td></td><td class="fit">CDD4</td>
				<td>E6 D3</td>
				<td class="fit">INC $D3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDD6</td>
				<td>BD 85 02</td>
				<td class="fit">LDA $0285,X</td><td rowspan="1"><p>Load .A with that file's secondary
address from FILSEC,X ($0285, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDD9</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="5"><p>Transfer the secondary address to .Y.</p>
<p>Decrement it by 2 (to eliminate the
reserved secondary addresses and 1)
and compare the result with $0C (#12).</p>
<p>If the original SA was between 2 and 14,
it passes the test so branch to BT20.</p>
</td></tr>
				<tr><td></td><td class="fit">CDDA</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">CDDB</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">CDDC</td>
				<td>C0 0C</td>
				<td class="fit">CPY #$0C</td></tr>
				<tr><td></td><td class="fit">CDDE</td>
				<td>90 05</td>
				<td class="fit">BCC $CDE5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BT15</td><td class="fit">CDE0</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td><td rowspan="2"><p>Load .A with $70 to indicate no channel
is available and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">CDE2</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BT20</td><td class="fit">CDE5</td>
				<td>85 83</td>
				<td class="fit">STA $83</td><td rowspan="1"><p>Store the original secondary address
(in .A) into SA ($83) as the active SA.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDE7</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="2"><p>JSR to FNDRCH ($D0EB)to find an unused
read channel. If none available, branch
to BT15.</p>
</td></tr>
				<tr><td></td><td class="fit">CDEA</td>
				<td>B0 F4</td>
				<td class="fit">BCS $CDE0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDEC</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="2"><p>JSR to GETACT ($DF93) to get the active
buffer number. On return, store the
active buffer number in JOBNUM ($F9) .
read channel. If none available, branch</p>
</td></tr>
				<tr><td></td><td class="fit">CDEF</td>
				<td>85 F9</td>
				<td class="fit">STA $F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDF1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test all block parameters: buffer allocated and legal block.</h1>
<p>If OK, set up drive, track, and sector values.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BKOTST</td><td class="fit">CDF2</td>
				<td>20 D2 CD</td>
				<td class="fit">JSR $CDD2</td><td rowspan="1"><p>JSR to BUFTST($CDD2) to test if buffer
is allocated for this secondary address.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BLKTST</td><td class="fit">CDF5</td>
				<td>A6 D3</td>
				<td class="fit">LDX $D3</td><td rowspan="1"><p>Set the drive number, track, and sector
values requested for a block operation
and test to see that these are valid.
Load .X with the channel number from
F1PTR ($D3)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDF7</td>
				<td>BD 85 02</td>
				<td class="fit">LDA $0285,X</td><td rowspan="3"><p>Load .A with the drive number desired
from FILSEC,X($0285,X).</p>
<p>AND it with $01
to mask off the default drive bit, and
store the result as the current drive
number, DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">CDFA</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">CDFC</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CDFE</td>
				<td>BD 87 02</td>
				<td class="fit">LDA $0287,X</td><td rowspan="2"><p>Move the desired sector from FILSEC+2,X
($0287, X) to SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">CE01</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE03</td>
				<td>BD 86 02</td>
				<td class="fit">LDA $0286,X</td><td rowspan="2"><p>Move the desired track from FILSEC+1,X
($0286, X) to TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">CE06</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE08</td>
				<td>20 5F D5</td>
				<td class="fit">JSR $D55F</td><td rowspan="1"><p>JSR to TSCHK ($D55F) to test whether the
track and sector values are legal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE0B</td>
				<td>4C 00 C1</td>
				<td class="fit">JMP $C100</td><td rowspan="1"><p>JMP to SETLDS to turn on drive active
LED. Do RTS from there.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find relative file</h1>
<pre><code>Inputs: (all 1 byte)        |outputs: (all 1 byte)
----------------------------|---------------------
RECL - record # (lo byte)   |SSNUM - side sector #
RECH - record # (hi byte)   |SSIND - index into SS
RS - record size            |RELPTR - pointer into
RECPTR - pointer into record|         sector</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDREL</td><td class="fit">CE0E</td>
				<td>20 2C CE</td>
				<td class="fit">JSR $CE2C</td><td rowspan="1"><p>JSR to MULPLY($CE2C) to find total bytes
TOTAL = REC# x RS + RECPTR</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE11</td>
				<td>20 6E CE</td>
				<td class="fit">JSR $CE6E</td><td rowspan="1"><p>JSR to DIV254 to divide by 254. The
result is the record's location (in
sectors) from the start of the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE14</td>
				<td>A5 90</td>
				<td class="fit">LDA $90</td><td rowspan="2"><p>Save the remainder (in .A) into RELPTR
($D7). This points into the last sector.</p>
</td></tr>
				<tr><td></td><td class="fit">CE16</td>
				<td>85 D7</td>
				<td class="fit">STA $D7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE18</td>
				<td>20 71 CE</td>
				<td class="fit">JSR $CE71</td><td rowspan="1"><p>JSR to DIV120 to divide by 120. The
result points into the side sector file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE1B</td>
				<td>E6 D7</td>
				<td class="fit">INC $D7</td><td rowspan="2"><p>Increment the pointer into the sector,
RELPTR ($D7) by two to bypass the two
link bytes at the start of the sector.</p>
</td></tr>
				<tr><td></td><td class="fit">CE1D</td>
				<td>E6 D7</td>
				<td class="fit">INC $D7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE1F</td>
				<td>A5 8B</td>
				<td class="fit">LDA $8B</td><td rowspan="2"><p>Move the quotient of the division by 120
from RESULT ($8B) to SSNUM ($D5).</p>
</td></tr>
				<tr><td></td><td class="fit">CE21</td>
				<td>85 D5</td>
				<td class="fit">STA $D5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE23</td>
				<td>A5 90</td>
				<td class="fit">LDA $90</td><td rowspan="5"><p>Load .A with the remainder of the
division from ACCUM+1 ($90). multiply
it by two (ASL) because each side sector
pointer occupies two bytes (t &amp; s). add
$10 (#16) to skip the initial link table
in the sector, and store the resulting
side sector index (points into the
sector holding the side sectors) into
SSIND ($D6) .</p>
</td></tr>
				<tr><td></td><td class="fit">CE25</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">CE26</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">CE27</td>
				<td>69 10</td>
				<td class="fit">ADC #$10</td></tr>
				<tr><td></td><td class="fit">CE29</td>
				<td>85 D6</td>
				<td class="fit">STA $D6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE2B</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Calculate a record's location in bytes</h1>
<p>TOTAL = REC# x RS + RECPTR</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MULPLY</td><td class="fit">CE2C</td>
				<td>20 D9 CE</td>
				<td class="fit">JSR $CED9</td><td rowspan="2"><p>JSR to ZERRES ($CED9) to zero the RESULT
area ($8B-$8D) .</p>
</td></tr>
				<tr><td></td><td class="fit">CE2F</td>
				<td>85 92</td>
				<td class="fit">STA $92</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE31</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Zero ACCUM+3 ($92) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE33</td>
				<td>B5 B5</td>
				<td class="fit">LDA $B5,X</td><td rowspan="2"><p>Load .X with the LINDX ($82) and use it
to move the lo byte of the record number
from RECL,X ($B5) to ACCUM+1 ($90).</p>
</td></tr>
				<tr><td></td><td class="fit">CE35</td>
				<td>85 90</td>
				<td class="fit">STA $90</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE37</td>
				<td>B5 BB</td>
				<td class="fit">LDA $BB,X</td><td rowspan="2"><p>Move the hi byte of the record number
from RECH,X ($BB) to ACCUM+2 ($91) .</p>
</td></tr>
				<tr><td></td><td class="fit">CE39</td>
				<td>85 91</td>
				<td class="fit">STA $91</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE3B</td>
				<td>D0 04</td>
				<td class="fit">BNE $CE41</td><td rowspan="1"><p>If the hi byte of the record number is
not $00. branch to MUL25.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE3D</td>
				<td>A5 90</td>
				<td class="fit">LDA $90</td><td rowspan="2"><p>If the lo byte of the record number is
$00. branch to MUL50 to adjust for
record #0 (the first record) .</p>
</td></tr>
				<tr><td></td><td class="fit">CE3F</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $CE4C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MUL25</td><td class="fit">CE41</td>
				<td>A5 90</td>
				<td class="fit">LDA $90</td><td rowspan="5"><p>Load .A with the lo byte of the record
size from ACCUM+1 ($90). set the carry
flag, subtract $01, and store the result
back in ACCUM+1. If the carry flag is
still set, branch to MULT50.</p>
</td></tr>
				<tr><td></td><td class="fit">CE43</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">CE44</td>
				<td>E9 01</td>
				<td class="fit">SBC #$01</td></tr>
				<tr><td></td><td class="fit">CE46</td>
				<td>85 90</td>
				<td class="fit">STA $90</td></tr>
				<tr><td></td><td class="fit">CE48</td>
				<td>B0 02</td>
				<td class="fit">BCS $CE4C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE4A</td>
				<td>C6 91</td>
				<td class="fit">DEC $91</td><td rowspan="1"><p>Decrement the hi byte of the record size
in ACCUM+2 ($91) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MUL50</td><td class="fit">CE4C</td>
				<td>B5 C7</td>
				<td class="fit">LDA $C7,X</td><td rowspan="2"><p>Copy the record size from RS,X ($C7,X)
to TEMP ($6F) .</p>
</td></tr>
				<tr><td></td><td class="fit">CE4E</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MUL100</td><td class="fit">CE50</td>
				<td>46 6F</td>
				<td class="fit">LSR $6F</td><td rowspan="2"><p>Do an LSR on TEMP ($6F). If the carry
flag is clear, branch to MUL200 (no add
this time) .</p>
</td></tr>
				<tr><td></td><td class="fit">CE52</td>
				<td>90 03</td>
				<td class="fit">BCC $CE57</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE54</td>
				<td>20 ED CE</td>
				<td class="fit">JSR $CEED</td><td rowspan="1"><p>JSR to ADDRES ($CEED) to add.
RESULT = RESULT + ACCUM+1, 2, 3</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MUL200</td><td class="fit">CE57</td>
				<td>20 E5 CE</td>
				<td class="fit">JSR $CEE5</td><td rowspan="1"><p>JSR to ACCX2 ($CEE5) to multiply the
ACCUM+1, 2, 3 by two.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE5A</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="2"><p>Test TEMP to see if done, if not branch
back to MUL100.</p>
</td></tr>
				<tr><td></td><td class="fit">CE5C</td>
				<td>D0 F2</td>
				<td class="fit">BNE $CE50</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE5E</td>
				<td>A5 D4</td>
				<td class="fit">LDA $D4</td><td rowspan="8"><p>Add the byte pointer to the result.</p>
</td></tr>
				<tr><td></td><td class="fit">CE60</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">CE61</td>
				<td>65 8B</td>
				<td class="fit">ADC $8B</td></tr>
				<tr><td></td><td class="fit">CE63</td>
				<td>85 8B</td>
				<td class="fit">STA $8B</td></tr>
				<tr><td></td><td class="fit">CE65</td>
				<td>90 06</td>
				<td class="fit">BCC $CE6D</td></tr>
				<tr><td></td><td class="fit">CE67</td>
				<td>E6 8C</td>
				<td class="fit">INC $8C</td></tr>
				<tr><td></td><td class="fit">CE69</td>
				<td>D0 02</td>
				<td class="fit">BNE $CE6D</td></tr>
				<tr><td></td><td class="fit">CE6B</td>
				<td>E6 8D</td>
				<td class="fit">INC $8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MUL400</td><td class="fit">CE6D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Divide routine</h1>
<p>RESULT ($83) = QUOTIENT ACCUM+1 ($90) = REMAINDER</p>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h2>Divide by 254 entry point</h2>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV254</td><td class="fit">CE6E</td>
				<td>A9 FE</td>
				<td class="fit">LDA #$FE</td><td rowspan="1"><p>Load .A with $FE (#254)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE70</td>
				<td>2C</td>
				<td class="fit"></td><td rowspan="1"><p>Byte $2C (skip over next instruction)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h2>Divide by 120 entry point</h2>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV120</td><td class="fit">CE71</td>
				<td>A9 78</td>
				<td class="fit">LDA #$78</td><td rowspan="1"><p>Load .A with $78 (#120)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE73</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td><td rowspan="1"><p>Store divisor into TEMP ($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE75</td>
				<td>A2 03</td>
				<td class="fit">LDX #$03</td><td rowspan="9"><p>Swap ACCUM+1 ,2. 3 with RESULT, 1,2</p>
</td></tr>
				<tr><td></td><td class="fit">CE77</td>
				<td>B5 8F</td>
				<td class="fit">LDA $8F,X</td></tr>
				<tr><td></td><td class="fit">CE79</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">CE7A</td>
				<td>B5 8A</td>
				<td class="fit">LDA $8A,X</td></tr>
				<tr><td></td><td class="fit">CE7C</td>
				<td>95 8F</td>
				<td class="fit">STA $8F,X</td></tr>
				<tr><td></td><td class="fit">CE7E</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">CE7F</td>
				<td>95 8A</td>
				<td class="fit">STA $8A,X</td></tr>
				<tr><td></td><td class="fit">CE81</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">CE82</td>
				<td>D0 F3</td>
				<td class="fit">BNE $CE77</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE84</td>
				<td>20 D9 CE</td>
				<td class="fit">JSR $CED9</td><td rowspan="1"><p>JSR to ZERRES ($CED9) to zero RESULT, 1,2</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV150</td><td class="fit">CE87</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="1"><p>Zero .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV200</td><td class="fit">CE89</td>
				<td>B5 90</td>
				<td class="fit">LDA $90,X</td><td rowspan="2"><p>Divide by 256 by moving the value in
ACCUM+1, X ($90, X) to ACCUM,X ($8F,X).</p>
</td></tr>
				<tr><td></td><td class="fit">CE8B</td>
				<td>95 8F</td>
				<td class="fit">STA $8F,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE8D</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Increment .X. If .X is not 4 yet, branch
back to DIV200.</p>
</td></tr>
				<tr><td></td><td class="fit">CE8E</td>
				<td>E0 04</td>
				<td class="fit">CPX #$04</td></tr>
				<tr><td></td><td class="fit">CE90</td>
				<td>90 F7</td>
				<td class="fit">BCC $CE89</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE92</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Zero the hi byte, ACCUM+3 ($92).
Check if this is a divide by 120 by
testing bit 7 of TEMP. If it is a divide
by 254, branch to DIV300.</p>
</td></tr>
				<tr><td></td><td class="fit">CE94</td>
				<td>85 92</td>
				<td class="fit">STA $92</td></tr>
				<tr><td></td><td class="fit">CE96</td>
				<td>24 6F</td>
				<td class="fit">BIT $6F</td></tr>
				<tr><td></td><td class="fit">CE98</td>
				<td>30 09</td>
				<td class="fit">BMI $CEA3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CE9A</td>
				<td>06 8F</td>
				<td class="fit">ASL $8F</td><td rowspan="5"><p>Do an ASL of ACCUM ($8F) to set the
carry flag if ACCUM &gt; 127.</p>
<p>Push the
processor status on the stack to save
the carry flag.</p>
<p>Do an LSR on ACCUM to
restore its original value. Pull the
processor status back off the stack and</p>
<p>JSR to ACC200 ($CEE6) to multiply the
value in the ACCUM, 1,2 by two so that
we have, in effect, divided by 128.</p>
<pre><code>X/128 = 2 * X/256</code></pre>
</td></tr>
				<tr><td></td><td class="fit">CE9C</td>
				<td>08</td>
				<td class="fit">PHP</td></tr>
				<tr><td></td><td class="fit">CE9D</td>
				<td>46 8F</td>
				<td class="fit">LSR $8F</td></tr>
				<tr><td></td><td class="fit">CE9F</td>
				<td>28</td>
				<td class="fit">PLP</td></tr>
				<tr><td></td><td class="fit">CEA0</td>
				<td>20 E6 CE</td>
				<td class="fit">JSR $CEE6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV300</td><td class="fit">CEA3</td>
				<td>20 ED CE</td>
				<td class="fit">JSR $CEED</td><td rowspan="1"><p>JSR to ADDRES ($CEED) to add the ACCUM
to the RESULT.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEA6</td>
				<td>20 E5 CE</td>
				<td class="fit">JSR $CEE5</td><td rowspan="1"><p>JSR to ACCX2 ($CEE5) to multiply the
ACCUM by two.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEA9</td>
				<td>24 6F</td>
				<td class="fit">BIT $6F</td><td rowspan="2"><p>Check if this is a divide by 120 by
testing bit 7 of TEMP. If it is a divide
by 254, branch to DIV400.</p>
</td></tr>
				<tr><td></td><td class="fit">CEAB</td>
				<td>30 03</td>
				<td class="fit">BMI $CEB0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEAD</td>
				<td>20 E2 CE</td>
				<td class="fit">JSR $CEE2</td><td rowspan="1"><p>JSR to ACCX4 ($CEE2) to multiply the
ACCUM by four. A= 4 * (2 * A) = 8 * A</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV400</td><td class="fit">CEB0</td>
				<td>A5 8F</td>
				<td class="fit">LDA $8F</td><td rowspan="8"><p>Add in the remainder from ACCUM ($8F)
to ACCUM+1. If a carry is produced,
increment ACCUM+2 and, if necessary,
ACCUM+3.</p>
</td></tr>
				<tr><td></td><td class="fit">CEB2</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">CEB3</td>
				<td>65 90</td>
				<td class="fit">ADC $90</td></tr>
				<tr><td></td><td class="fit">CEB5</td>
				<td>85 90</td>
				<td class="fit">STA $90</td></tr>
				<tr><td></td><td class="fit">CEB7</td>
				<td>90 06</td>
				<td class="fit">BCC $CEBF</td></tr>
				<tr><td></td><td class="fit">CEB9</td>
				<td>E6 91</td>
				<td class="fit">INC $91</td></tr>
				<tr><td></td><td class="fit">CEBB</td>
				<td>D0 02</td>
				<td class="fit">BNE $CEBF</td></tr>
				<tr><td></td><td class="fit">CEBD</td>
				<td>E6 92</td>
				<td class="fit">INC $92</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV500</td><td class="fit">CEBF</td>
				<td>A5 92</td>
				<td class="fit">LDA $92</td><td rowspan="3"><p>Test if remainder is less than 256 by
ORing ACCUM+3 and ACCUM+2. If the result
is not zero, the remainder is too large
so branch to DIV to crunch some more.</p>
</td></tr>
				<tr><td></td><td class="fit">CEC1</td>
				<td>05 91</td>
				<td class="fit">ORA $91</td></tr>
				<tr><td></td><td class="fit">CEC3</td>
				<td>D0 C2</td>
				<td class="fit">BNE $CE87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEC5</td>
				<td>A5 90</td>
				<td class="fit">LDA $90</td><td rowspan="6"><p>Test if remainder is less than divisor
subtracting the divisor, TEMP ($6F) from
the remainder in ACCUM+1 ($90). If the
remainder is smaller, branch to DIV600.</p>
</td></tr>
				<tr><td></td><td class="fit">CEC7</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">CEC8</td>
				<td>E5 6F</td>
				<td class="fit">SBC $6F</td></tr>
				<tr><td></td><td class="fit">CECA</td>
				<td>90 0C</td>
				<td class="fit">BCC $CED8</td></tr>
				<tr><td></td><td class="fit">CECC</td>
				<td>E6 8B</td>
				<td class="fit">INC $8B</td></tr>
				<tr><td></td><td class="fit">CECE</td>
				<td>D0 06</td>
				<td class="fit">BNE $CED6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CED0</td>
				<td>E6 8C</td>
				<td class="fit">INC $8C</td><td rowspan="3"><p>Since the remainder is too large, add 1
to the RESULT.</p>
</td></tr>
				<tr><td></td><td class="fit">CED2</td>
				<td>D0 02</td>
				<td class="fit">BNE $CED6</td></tr>
				<tr><td></td><td class="fit">CED4</td>
				<td>E6 8D</td>
				<td class="fit">INC $8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIV600</td><td class="fit">CED6</td>
				<td>85 90</td>
				<td class="fit">STA $90</td><td rowspan="1"><p>Store the new, smaller remainder in
ACCUM+1 ($90) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CED8</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Zero the RESULT area</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ZERRES</td><td class="fit">CED9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Load .A with $00 and store in RESULT
($8B), RESULT+1 ($8C). and RESULT+2 ($8D)</p>
</td></tr>
				<tr><td></td><td class="fit">CEDB</td>
				<td>85 8B</td>
				<td class="fit">STA $8B</td></tr>
				<tr><td></td><td class="fit">CEDD</td>
				<td>85 8C</td>
				<td class="fit">STA $8C</td></tr>
				<tr><td></td><td class="fit">CEDF</td>
				<td>85 8D</td>
				<td class="fit">STA $8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEE1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Multiply ACCUM by 4</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACCX4</td><td class="fit">CEE2</td>
				<td>20 E5 CE</td>
				<td class="fit">JSR $CEE5</td><td rowspan="1"><p>JSR ACCX2 ($CEE5)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Multiply ACCUM by 2</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACCX2</td><td class="fit">CEE5</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Clear the carry flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACC200</td><td class="fit">CEE6</td>
				<td>26 90</td>
				<td class="fit">ROL $90</td><td rowspan="3"><p>Do a ROL on ACCUM+1 ( $90 ). ACCUM+2 ( $91 ) ,
and ACCUM+2 ($92) .</p>
</td></tr>
				<tr><td></td><td class="fit">CEE8</td>
				<td>26 91</td>
				<td class="fit">ROL $91</td></tr>
				<tr><td></td><td class="fit">CEEA</td>
				<td>26 92</td>
				<td class="fit">ROL $92</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEEC</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Add ACCUM to RESULT</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDRES</td><td class="fit">CEED</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Load .X with $FD.</p>
</td></tr>
				<tr><td></td><td class="fit">CEEE</td>
				<td>A2 FD</td>
				<td class="fit">LDX #$FD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADD100</td><td class="fit">CEF0</td>
				<td>B5 8E</td>
				<td class="fit">LDA $8E,X</td><td rowspan="3"><p>Add RESULT+3,X ($8E,X) and ACCUM+4,X
($93) and store the result in RESULT+3,</p>
</td></tr>
				<tr><td></td><td class="fit">CEF2</td>
				<td>75 93</td>
				<td class="fit">ADC $93,X</td></tr>
				<tr><td></td><td class="fit">CEF4</td>
				<td>95 8E</td>
				<td class="fit">STA $8E,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEF6</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment .X. If not $00 yet, branch
back to ADD100.</p>
</td></tr>
				<tr><td></td><td class="fit">CEF7</td>
				<td>D0 F7</td>
				<td class="fit">BNE $CEF0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEF9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Initialize LRU (least recently used) table</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LRUINT</td><td class="fit">CEFA</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="1"><p>Load .X with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LRUILP</td><td class="fit">CEFC</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer .X to .A. Store the value in
.A into LRUTBL,X ($FA,X).</p>
</td></tr>
				<tr><td></td><td class="fit">CEFD</td>
				<td>95 FA</td>
				<td class="fit">STA $FA,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CEFF</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Increment .X and compare it to $04, the
command channel number. If not yet
equal, branch back to LRUILP.</p>
</td></tr>
				<tr><td></td><td class="fit">CF00</td>
				<td>E0 04</td>
				<td class="fit">CPX #$04</td></tr>
				<tr><td></td><td class="fit">CF02</td>
				<td>D0 F8</td>
				<td class="fit">BNE $CEFC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF04</td>
				<td>A9 06</td>
				<td class="fit">LDA #$06</td><td rowspan="2"><p>Load .A with $06, the BAM logical index
for the floating BAM, and store this
value into LRUTBL,X ($FA,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">CF06</td>
				<td>95 FA</td>
				<td class="fit">STA $FA,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF08</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Update LRU (least recently used) table</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LRUUPD</td><td class="fit">CF09</td>
				<td>A0 04</td>
				<td class="fit">LDY #$04</td><td rowspan="2"><p>Load .Y with $04, the command channel
number. Load .X from LINDX ($82) the
current channel number.</p>
</td></tr>
				<tr><td></td><td class="fit">CF0B</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LRULP1</td><td class="fit">CF0D</td>
				<td>B9 FA 00</td>
				<td class="fit">LDA $00FA,Y</td><td rowspan="2"><p>Load .A with the value from LRUTBL,Y
($00FA,Y). Store the current channel
number (from .X) into LRUTBL,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">CF10</td>
				<td>96 FA</td>
				<td class="fit">STX $FA,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF12</td>
				<td>C5 82</td>
				<td class="fit">CMP $82</td><td rowspan="2"><p>Compare the value in .A with the current
channel number in LINDX ($82). If they
are equal, branch to LRUEXT to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">CF14</td>
				<td>F0 07</td>
				<td class="fit">BEQ $CF1D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF16</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement .Y the channel counter. If no
more channels to do (Y&lt;0) branch to
LRUINT ($CEFA) since no match was found.</p>
</td></tr>
				<tr><td></td><td class="fit">CF17</td>
				<td>30 E1</td>
				<td class="fit">BMI $CEFA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF19</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="2"><p>Transfer .A to .X and JMP to LRULPl
.A into LRUTBL,X ($FA,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">CF1A</td>
				<td>4C 0D CF</td>
				<td class="fit">JMP $CF0D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LRUEXT</td><td class="fit">CF1D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Double buffer: switch the active and inactive buffers.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBLBUF</td><td class="fit">CF1E</td>
				<td>20 09 CF</td>
				<td class="fit">JSR $CF09</td><td rowspan="1"><p>JSR to LRUUPD ($CF09) to update the LRU
(least recently used) table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF21</td>
				<td>20 B7 DF</td>
				<td class="fit">JSR $DFB7</td><td rowspan="1"><p>JSR to GETINA ($DFB7) to get the LINDX
channel's inactive buffer number (in .A)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF24</td>
				<td>D0 46</td>
				<td class="fit">BNE $CF6C</td><td rowspan="1"><p>On return, if there is an inactive
buffer, branch to DBL15.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF26</td>
				<td>20 D3 D1</td>
				<td class="fit">JSR $D1D3</td><td rowspan="1"><p>There is no inactive buffer so make one I
JSR to SETDRN ($D1D3) to set the drive
number to the one in LSTJOB.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF29</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td><td rowspan="2"><p>JSR to GETBUF ($D28E) to get a free
buffer number. If no buffers available,
branch to DBL30 and abort.</p>
</td></tr>
				<tr><td></td><td class="fit">CF2C</td>
				<td>30 48</td>
				<td class="fit">BMI $CF76</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF2E</td>
				<td>20 C2 DF</td>
				<td class="fit">JSR $DFC2</td><td rowspan="1"><p>JSR to PUTINA ($DFC2) to store the new
buffer number as the inactive buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF31</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="4"><p>Save the current values of TRACK ($80)
and SECTOR ($81) on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">CF33</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">CF34</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td></tr>
				<tr><td></td><td class="fit">CF36</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF37</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Load .A with $01 and JSR to DRDBYT
($D4F6) to direct read .A bytes. Store
the byte read as the current SECTOR ($81)</p>
</td></tr>
				<tr><td></td><td class="fit">CF39</td>
				<td>20 F6 D4</td>
				<td class="fit">JSR $D4F6</td></tr>
				<tr><td></td><td class="fit">CF3C</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF3E</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Load .A with $00 and JSR to DRDBYT
($D4F6) to direct read .A bytes. Store
the byte read as the current TRACK($80).</p>
</td></tr>
				<tr><td></td><td class="fit">CF40</td>
				<td>20 F6 D4</td>
				<td class="fit">JSR $D4F6</td></tr>
				<tr><td></td><td class="fit">CF43</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF45</td>
				<td>F0 1F</td>
				<td class="fit">BEQ $CF66</td><td rowspan="1"><p>If the TRACK byte was $00 (last sector
in the file), branch to DBL10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF47</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="2"><p>JSR to TYPFIL ($D125) to determine the
file type we are working on. If it is a
relative file, branch to DBL05.</p>
</td></tr>
				<tr><td></td><td class="fit">CF4A</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $CF57</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF4C</td>
				<td>20 AB DD</td>
				<td class="fit">JSR $DDAB</td><td rowspan="2"><p>JSR to TSTWRT ($DDAB) to see if we are
writing this file or just reading it.
If just reading, branch to DBL05 to read
ahead.</p>
</td></tr>
				<tr><td></td><td class="fit">CF4F</td>
				<td>D0 06</td>
				<td class="fit">BNE $CF57</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF51</td>
				<td>20 8C CF</td>
				<td class="fit">JSR $CF8C</td><td rowspan="2"><p>We are writing so JSR to TGLBUF ($CF8C)
to toggle the buffers. On return, JMP
to DBL08.</p>
</td></tr>
				<tr><td></td><td class="fit">CF54</td>
				<td>4C 5D CF</td>
				<td class="fit">JMP $CF5D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBL05</td><td class="fit">CF57</td>
				<td>20 8C CF</td>
				<td class="fit">JSR $CF8C</td><td rowspan="1"><p>JSR to TGLBUF ($CF8C) to toggle the
inactive and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF5A</td>
				<td>20 57 DE</td>
				<td class="fit">JSR $DE57</td><td rowspan="1"><p>JSR to RDAB ($DE57) to read in the next
sector of the file (into active buffer) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBL08</td><td class="fit">CF5D</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the old SECTOR($81) and TRACK ($80)
values from the stack and restore them.</p>
</td></tr>
				<tr><td></td><td class="fit">CF5E</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
				<tr><td></td><td class="fit">CF60</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">CF61</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF63</td>
				<td>4C 6F CF</td>
				<td class="fit">JMP $CF6F</td><td rowspan="1"><p>JMP to DBL20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBL10</td><td class="fit">CF66</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the old SECTOR($81) and TRACK ($80)
values from the stack and restore them.</p>
</td></tr>
				<tr><td></td><td class="fit">CF67</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
				<tr><td></td><td class="fit">CF69</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">CF6A</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBL15</td><td class="fit">CF6C</td>
				<td>20 8C CF</td>
				<td class="fit">JSR $CF8C</td><td rowspan="1"><p>JSR to TGLBUF ($CF8C) to toggle the
inactive and active buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBL20</td><td class="fit">CF6F</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="3"><p>JSR to GETACT ($DF93) to get the active
buffer number (in .A). Transfer the
active buffer number into .X and JMP to
WATJOB ($D599) to wait until job is done</p>
</td></tr>
				<tr><td></td><td class="fit">CF72</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">CF73</td>
				<td>4C 99 D5</td>
				<td class="fit">JMP $D599</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBL30</td><td class="fit">CF76</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td><td rowspan="2"><p>No buffers to steal so load .A with $70
to indicate a NO CHANNEL error and JMP
to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">CF78</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up double buffering</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBSET</td><td class="fit">CF7B</td>
				<td>20 09 CF</td>
				<td class="fit">JSR $CF09</td><td rowspan="1"><p>JSR to LRUUPD ($CF09) to update the LRU
(least recently used) table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF7E</td>
				<td>20 B7 DF</td>
				<td class="fit">JSR $DFB7</td><td rowspan="1"><p>JSR to GETINA ($DFB7) to get the number
of the inactive buffer (in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF81</td>
				<td>D0 08</td>
				<td class="fit">BNE $CF8B</td><td rowspan="1"><p>If there is an inactive buffer, branch
to DBS10 to exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF83</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td><td rowspan="2"><p>JSR to GETBUF ($DF93) to find an unused
buffer. If no buffers available, branch
to DBL30 ($CF76) to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">CF86</td>
				<td>30 EE</td>
				<td class="fit">BMI $CF76</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF88</td>
				<td>20 C2 DF</td>
				<td class="fit">JSR $DFC2</td><td rowspan="1"><p>JSR to PUTINA ($DFC2) to set the buffer
found as the inactive buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBS10</td><td class="fit">CF8B</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Toggle the inactive &amp; active buffers</h1>
<p>Input: LINDX = current channel #</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TGLBUF</td><td class="fit">CF8C</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="4"><p>Load .X with the channel number from
LINDX ($82) and use it as an index to
load .A with the buffer number from
BUF0,X ($A7). EOR this number with $80
to change its active/ inactive state and
store the modified value back in BUF0,X,</p>
</td></tr>
				<tr><td></td><td class="fit">CF8E</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td></tr>
				<tr><td></td><td class="fit">CF90</td>
				<td>49 80</td>
				<td class="fit">EOR #$80</td></tr>
				<tr><td></td><td class="fit">CF92</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF94</td>
				<td>B5 AE</td>
				<td class="fit">LDA $AE,X</td><td rowspan="3"><p>Load .A with the buffer number from
BUF1,X ($AE). EOR this number with $80
to change its active/inactive state and
store the modified value back in BUF1,X,</p>
</td></tr>
				<tr><td></td><td class="fit">CF96</td>
				<td>49 80</td>
				<td class="fit">EOR #$80</td></tr>
				<tr><td></td><td class="fit">CF98</td>
				<td>95 AE</td>
				<td class="fit">STA $AE,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF9A</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write byte to internal write channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PIBYTE</td><td class="fit">CF9B</td>
				<td>A2 12</td>
				<td class="fit">LDX #$12</td><td rowspan="2"><p>Load .X with $12 (#18) the secondary
address of the internal write channel
and use it to set the current secondary
address SA ($83) .</p>
</td></tr>
				<tr><td></td><td class="fit">CF9D</td>
				<td>86 83</td>
				<td class="fit">STX $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CF9F</td>
				<td>20 07 D1</td>
				<td class="fit">JSR $D107</td><td rowspan="1"><p>JSR to FNDWCH ($D107) to find an unused
write channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFA2</td>
				<td>20 00 C1</td>
				<td class="fit">JSR $C100</td><td rowspan="1"><p>JSR to SETLED ($C100) to turn on the
drive active LED.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFA5</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="2"><p>JSR to TYPFIL ($D125) to determine the
current file type. If NOT a relative
file, branch to PBYTE ($CFAF) .</p>
</td></tr>
				<tr><td></td><td class="fit">CFA8</td>
				<td>90 05</td>
				<td class="fit">BCC $CFAF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFAA</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Load .A with $20 (the overflow flag bit)
and JSR to CLRFLG ($DD9D) to clear the
overflow flag.</p>
</td></tr>
				<tr><td></td><td class="fit">CFAC</td>
				<td>20 9D DD</td>
				<td class="fit">JSR $DD9D</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write byte to any channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PBYTE</td><td class="fit">CFAF</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="4"><p>Load .A with the current secondary
address from SA ($83). Compare the SA
with $0F (#15) to see if we are using
the command channel. If SA=$0F, this is
the command channel so branch to L42
($CFD8). If not, branch to L40 ($CFBF).</p>
</td></tr>
				<tr><td></td><td class="fit">CFB1</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td></tr>
				<tr><td></td><td class="fit">CFB3</td>
				<td>F0 23</td>
				<td class="fit">BEQ $CFD8</td></tr>
				<tr><td></td><td class="fit">CFB5</td>
				<td>D0 08</td>
				<td class="fit">BNE $CFBF</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Main routine to write to a channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUT</td><td class="fit">CFB7</td>
				<td>A5 84</td>
				<td class="fit">LDA $84</td><td rowspan="4"><p>Check if this is the command channel or
a data channel by loading the original
secondary address from ORGSA ($84) ,
ANDing it with $8F, and comparing the
result with $0F (#15). If less than 15,
this is a data channel so branch to L42.</p>
</td></tr>
				<tr><td></td><td class="fit">CFB9</td>
				<td>29 8F</td>
				<td class="fit">AND #$8F</td></tr>
				<tr><td></td><td class="fit">CFBB</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td></tr>
				<tr><td></td><td class="fit">CFBD</td>
				<td>B0 19</td>
				<td class="fit">BCS $CFD8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L40</td><td class="fit">CFBF</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="2"><p>JSR to TYPFIL ($D125) to determine the
file type. If we are NOT working on a
sequential file, branch to L41.</p>
</td></tr>
				<tr><td></td><td class="fit">CFC2</td>
				<td>B0 05</td>
				<td class="fit">BCS $CFC9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFC4</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="2"><p>Since this is a sequential file, load
.A with the data byte from DATA ($85)
and JMP to WRTBYT ($D19D) to write the
byte to the channel.</p>
</td></tr>
				<tr><td></td><td class="fit">CFC6</td>
				<td>4C 9D D1</td>
				<td class="fit">JMP $D19D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L41</td><td class="fit">CFC9</td>
				<td>D0 03</td>
				<td class="fit">BNE $CFCE</td><td rowspan="1"><p>If Z flag not set, we are writing to a
true random access file (USR) so branch
to L46.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFCB</td>
				<td>4C AB E0</td>
				<td class="fit">JMP $E0AB</td><td rowspan="1"><p>We are writing to a relative (REL) file
so JMP to WRTREL ($E0AB) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L46</td><td class="fit">CFCE</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="2"><p>Since this is a USR file, load .A with
the data byte from DATA ($85) and JSR
to PUTBYT ($CFF1) to write it to the
channel .</p>
</td></tr>
				<tr><td></td><td class="fit">CFD0</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFD3</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="2"><p>To prepare to write the next byte: load
.Y with the channel number from LINDX
($82) and JMP to RNGET2 ($D3EE).</p>
</td></tr>
				<tr><td></td><td class="fit">CFD5</td>
				<td>4C EE D3</td>
				<td class="fit">JMP $D3EE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L42</td><td class="fit">CFD8</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>Since this is the command channel, set
LINDX ($82) to $04 (the command channel
number) .</p>
</td></tr>
				<tr><td></td><td class="fit">CFDA</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFDC</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="3"><p>Test if command buffer is full by doing
a JSR to GETPNT ($D4E8) to get the
position of the last byte written and
comparing it to $2A. If they are equal,
the buffer is full so branch to L50.</p>
</td></tr>
				<tr><td></td><td class="fit">CFDF</td>
				<td>C9 2A</td>
				<td class="fit">CMP #$2A</td></tr>
				<tr><td></td><td class="fit">CFE1</td>
				<td>F0 05</td>
				<td class="fit">BEQ $CFE8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFE3</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="2"><p>Since there is space, load .A with the
command message byte from DATA ($85) and
JSR to PUTBYT ($CFF1) to write it to the
command channel.</p>
</td></tr>
				<tr><td></td><td class="fit">CFE5</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L50</td><td class="fit">CFE8</td>
				<td>A5 F8</td>
				<td class="fit">LDA $F8</td><td rowspan="2"><p>Test if this is the last byte of the
message by checking the EOIFLG ($F8) .
If it is zero, this is the last byte so
branch to L45.</p>
</td></tr>
				<tr><td></td><td class="fit">CFEA</td>
				<td>F0 01</td>
				<td class="fit">BEQ $CFED</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFEC</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate command with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L45</td><td class="fit">CFED</td>
				<td>EE 55 02</td>
				<td class="fit">INC $0255</td><td rowspan="1"><p>Increment CMDWAT ($0255) to set the
command-waiting flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFF0</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate command with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUTBYT</td><td class="fit">CFF1</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Put byte in .A into the active buffer
of the channel in LINDX:
Save byte in .A onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFF2</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="2"><p>JSR to GETACT ($DF93) to get the active
buffer number (in .A). If there is an
active buffer, branch to PUTB1.</p>
</td></tr>
				<tr><td></td><td class="fit">CFF5</td>
				<td>10 06</td>
				<td class="fit">BPL $CFFD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFF7</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>No active buffer so pull the data byte
off the stack, load .A with $61 to
indicate a FILE NOT OPEN error, and JMP
to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">CFF8</td>
				<td>A9 61</td>
				<td class="fit">LDA #$61</td></tr>
				<tr><td></td><td class="fit">CFFA</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUTB1</td><td class="fit">CFFD</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by 2 (ASL)
and transfer this value to .X</p>
</td></tr>
				<tr><td></td><td class="fit">CFFE</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">CFFF</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the data byte off the stack and
store it in the buffer at (BUFTAB,X)
($99, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D000</td>
				<td>81 99</td>
				<td class="fit">STA ($99,X)</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D002</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td><td rowspan="1"><p>Increment the buffer pointer BUFTAB,X</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>NOTE: Z flag is set if this data byte
      was stored in the last position
      in the buffer!</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D004</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Initialize drive(s): (Disk command)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INTDRV</td><td class="fit">D005</td>
				<td>20 D1 C1</td>
				<td class="fit">JSR $C1D1</td><td rowspan="1"><p>JSR to SIMPRS ($C1D1) to parse the
disk command.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D008</td>
				<td>20 42 D0</td>
				<td class="fit">JSR $D042</td><td rowspan="1"><p>JSR to INITDR ($D042) to initialize the
drive (s) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ID20</td><td class="fit">D00B</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate command with a JMP to ENDCMD
($C194) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Initialize drive given in DRVNUM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ITRIAL</td><td class="fit">D00E</td>
				<td>20 0F F1</td>
				<td class="fit">JSR $F10F</td><td rowspan="1"><p>JSR to BAM2A ($F10F) to get the current
BAM pointer in .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D011</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="4"><p>Transfer the BAM pointer to .Y and use
it as an index to load the BAM LINDX
from BUF0,Y ($A7,Y) into .X. If there
is a valid buffer number for the BAM
(not $FF). branch to IT30.</p>
</td></tr>
				<tr><td></td><td class="fit">D012</td>
				<td>B6 A7</td>
				<td class="fit">LDX $A7,Y</td></tr>
				<tr><td></td><td class="fit">D014</td>
				<td>E0 FF</td>
				<td class="fit">CPX #$FF</td></tr>
				<tr><td></td><td class="fit">D016</td>
				<td>D0 14</td>
				<td class="fit">BNE $D02C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D018</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="4"><p>No buffer so we had better get one!
Save the BAM pointer in .A on the stack
and JSR to GETBUF ($D28E) to find an
unused buffer. If a buffer is available,
branch to IT20.</p>
</td></tr>
				<tr><td></td><td class="fit">D019</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td></tr>
				<tr><td></td><td class="fit">D01C</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D01D</td>
				<td>10 05</td>
				<td class="fit">BPL $D024</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D01F</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td><td rowspan="2"><p>No buffer available so load .A with $70
to indicate a NO CHANNEL error and JSR
to CMDER3 ($E648) .</p>
</td></tr>
				<tr><td></td><td class="fit">D021</td>
				<td>20 48 E6</td>
				<td class="fit">JSR $E648</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IT20</td><td class="fit">D024</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="5"><p>Pull the BAM pointer from the stack and
transfer it to .Y. Transfer the new
buffer number from .X to .A, OR it with
$80 (to indicate an inactive status) ,
and store the result in BUF0,Y ($00A7,Y)
to allocate the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D025</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">D026</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">D027</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td></tr>
				<tr><td></td><td class="fit">D029</td>
				<td>99 A7 00</td>
				<td class="fit">STA $00A7,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IT30</td><td class="fit">D02C</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the buffer number from .X to
.A, AND it with $0F to mask off the
inactive status bit, and store it in
JOBNUM ($F9) .</p>
</td></tr>
				<tr><td></td><td class="fit">D02D</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">D02F</td>
				<td>85 F9</td>
				<td class="fit">STA $F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D031</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="4"><p>Set SECTOR ($81) to $00 and TRACK ($80)
to $12 (#18) to prepare to read the BAM.</p>
</td></tr>
				<tr><td></td><td class="fit">D033</td>
				<td>86 81</td>
				<td class="fit">STX $81</td></tr>
				<tr><td></td><td class="fit">D035</td>
				<td>AE 85 FE</td>
				<td class="fit">LDX $FE85</td></tr>
				<tr><td></td><td class="fit">D038</td>
				<td>86 80</td>
				<td class="fit">STX $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D03A</td>
				<td>20 D3 D6</td>
				<td class="fit">JSR $D6D3</td><td rowspan="1"><p>JSR to SETH ($D6D3) to set up the seek
image of the BAM header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D03D</td>
				<td>A9 B0</td>
				<td class="fit">LDA #$B0</td><td rowspan="2"><p>Load .A with $B0 (the job code for a
SEEK) and JMP to DOJOB ($D58C) to do the
seek to track 18. Does an RTS when done.</p>
</td></tr>
				<tr><td></td><td class="fit">D03F</td>
				<td>4C 8C D5</td>
				<td class="fit">JMP $D58C</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Initialize drive</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INITDR</td><td class="fit">D042</td>
				<td>20 D1 F0</td>
				<td class="fit">JSR $F0D1</td><td rowspan="1"><p>JSR to CLNBAM ($F0D1) to zero the track
numbers for the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D045</td>
				<td>20 13 D3</td>
				<td class="fit">JSR $D313</td><td rowspan="1"><p>JSR to CLDCHN ($D313) to allocate a
channel for the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D048</td>
				<td>20 0E D0</td>
				<td class="fit">JSR $D00E</td><td rowspan="2"><p>JSR to ITRIAL ($D00E) to allocate a
buffer for the BAM and seek track 18.</p>
</td></tr>
				<tr><td></td><td class="fit">D04B</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D04D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in MDIRTY,X ($0251) to
indicate that the BAM for drive .X is
NOT DIRTY (BAM in memory matches BAM on
the diskette) .</p>
</td></tr>
				<tr><td></td><td class="fit">D04F</td>
				<td>9D 51 02</td>
				<td class="fit">STA $0251,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D052</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="7"><p>Set the master ID for the diskette in
DSKID,X ($12/3 for drive 0) from the
track 18 header values ($16/17) read
during the seek to track 18</p>
</td></tr>
				<tr><td></td><td class="fit">D053</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D054</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D055</td>
				<td>A5 16</td>
				<td class="fit">LDA $16</td></tr>
				<tr><td></td><td class="fit">D057</td>
				<td>95 12</td>
				<td class="fit">STA $12,X</td></tr>
				<tr><td></td><td class="fit">D059</td>
				<td>A5 17</td>
				<td class="fit">LDA $17</td></tr>
				<tr><td></td><td class="fit">D05B</td>
				<td>95 13</td>
				<td class="fit">STA $13,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D05D</td>
				<td>20 86 D5</td>
				<td class="fit">JSR $D586</td><td rowspan="1"><p>JSR to DOREAD ($D586) to read the BAM
into the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D060</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="8"><p>Load the disk version (#65 for 4040/1541)
from the $0X02 position in the BAM and
store it in DSKVER,X ($0101 drive number),</p>
</td></tr>
				<tr><td></td><td class="fit">D062</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D063</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D064</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td></tr>
				<tr><td></td><td class="fit">D066</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
				<tr><td></td><td class="fit">D068</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td></tr>
				<tr><td></td><td class="fit">D06A</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td></tr>
				<tr><td></td><td class="fit">D06C</td>
				<td>9D 01 01</td>
				<td class="fit">STA $0101,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D06F</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Zero WPSW,X ($1C,X) to clear the write
protect switch and NODRV,X ($FF,X) to
clear the drive-not-active flag.</p>
</td></tr>
				<tr><td></td><td class="fit">D071</td>
				<td>95 1C</td>
				<td class="fit">STA $1C,X</td></tr>
				<tr><td></td><td class="fit">D073</td>
				<td>95 FF</td>
				<td class="fit">STA $FF,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NFCALC</td><td class="fit">D075</td>
				<td>20 3A EF</td>
				<td class="fit">JSR $EF3A</td><td rowspan="1"><p>Count the number of free blocks in BAM
JSR to SETBPT ($EF3A) to set the bit map
pointer and read in the BAM if necessary</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D078</td>
				<td>A0 04</td>
				<td class="fit">LDY #$04</td><td rowspan="3"><p>Initialize .Y to $04 and zero .A and .X
(.X will be the hi byte of the count).</p>
</td></tr>
				<tr><td></td><td class="fit">D07A</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">D07C</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NUMF1</td><td class="fit">D07D</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="3"><p>Clear carry and add (BMPNT) ,Y; ($6D),Y
to the value in .A. If no carry, branch
to NUMF2.</p>
</td></tr>
				<tr><td></td><td class="fit">D07E</td>
				<td>71 6D</td>
				<td class="fit">ADC ($6D),Y</td></tr>
				<tr><td></td><td class="fit">D080</td>
				<td>90 01</td>
				<td class="fit">BCC $D083</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D082</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="1"><p>Increment .X (the hi byte of the count) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NUMF2</td><td class="fit">D083</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="6"><p>Increment .Y four times so it points to
the start of the next track byte in the
BAM. Compare .Y to $48 (the directory
track location). If .Y=$48, branch to
NUMF2 to skip the directory track.</p>
</td></tr>
				<tr><td></td><td class="fit">D084</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">D085</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">D086</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">D087</td>
				<td>C0 48</td>
				<td class="fit">CPY #$48</td></tr>
				<tr><td></td><td class="fit">D089</td>
				<td>F0 F8</td>
				<td class="fit">BEQ $D083</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D08B</td>
				<td>C0 90</td>
				<td class="fit">CPY #$90</td><td rowspan="2"><p>Compare .Y to $90 to see if we are done.
If there is more to do, branch to NUMF1.</p>
</td></tr>
				<tr><td></td><td class="fit">D08D</td>
				<td>D0 EE</td>
				<td class="fit">BNE $D07D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D08F</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="6"><p>All done. Save the lo byte of the count
on the stack and transfer the hi byte
from .X to .A. Load .X with the current
drive number from DRVNUM ($7F) and store
the hi byte of the count (in .A) into
NDBH,X ($02FC,X). Pull the lo byte of
the count off the stack and save it in
NDBL,X ($02FA,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D090</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">D091</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td></tr>
				<tr><td></td><td class="fit">D093</td>
				<td>9D FC 02</td>
				<td class="fit">STA $02FC,X</td></tr>
				<tr><td></td><td class="fit">D096</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">D097</td>
				<td>9D FA 02</td>
				<td class="fit">STA $02FA,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D09A</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Start reading ahead</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STRRD</td><td class="fit">D09B</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>Use the values in TRACK and SECTOR to
read a data block. Use the track and
sector pointers to set up the next one.
JSR to SETHDR ($D6D0) to set up the
header image using TRACK ($80) and
SECTOR ($8i) values.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D09E</td>
				<td>20 C3 D0</td>
				<td class="fit">JSR $D0C3</td><td rowspan="1"><p>JSR to RDBUF ($D0C3) to read the first
block into the data buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0A1</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
read job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0A4</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="2"><p>JSR to GETBYT ($D137) to get the first
byte from the data buffer (track link)
and store it in TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">D0A7</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0A9</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="2"><p>JSR to GETBYT ($D137) to get the second
byte from the data buffer (sector link)
and store it in SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">D0AC</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0AE</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Start double buffering: (reading ahead)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STRDBL</td><td class="fit">D0AF</td>
				<td>20 9B D0</td>
				<td class="fit">JSR $D09B</td><td rowspan="1"><p>JSR to STRRD ($D09B) to read in a data
block and set up the next one.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0B2</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Check the current TRACK ($80) value. If
not $00. we are not at the end of the
file so branch to STR1.</p>
</td></tr>
				<tr><td></td><td class="fit">D0B4</td>
				<td>D0 01</td>
				<td class="fit">BNE $D0B7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0B6</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STR1</td><td class="fit">D0B7</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to set up buffers
and pointers for double buffering and
set TRACK and SECTOR for the next block,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0BA</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>JSR to SETHDR ($D6D0) to set up the
header image using TRACK ($80) and
SECTOR ($81) values.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0BD</td>
				<td>20 C3 D0</td>
				<td class="fit">JSR $D0C3</td><td rowspan="1"><p>JSR to RDBUF ($D0C3) to read the next
block into the data buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0C0</td>
				<td>4C 1E CF</td>
				<td class="fit">JMP $CF1E</td><td rowspan="1"><p>JMP to DBLBUF ($CF1E) to set up buffers
and pointers for double buffering and
set TRACK and SECTOR for the next block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDBUF</td><td class="fit">D0C3</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Start a read job of TRACK and SECTOR
Load .A with $80. the job code for a
read, and branch to STRTIT ($D0C9) .</p>
</td></tr>
				<tr><td></td><td class="fit">D0C5</td>
				<td>D0 02</td>
				<td class="fit">BNE $D0C9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTBUF</td><td class="fit">D0C7</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="1"><p>Start a write job of TRACK and SECTOR
Load .A with $90, the job code for a
write.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STRTIT</td><td class="fit">D0C9</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td><td rowspan="1"><p>Store command desired (in .A) as the
current command in CMD ($024D) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0CC</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="2"><p>JSR to GETACT ($DF93) to get the active
buffer number (in .A). Transfer the
active buffer number into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D0CF</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0D0</td>
				<td>20 06 D5</td>
				<td class="fit">JSR $D506</td><td rowspan="1"><p>JSR to SETLJB ($D506) to set up drive
number (from the last job). check for
legal track &amp; sector, and, if all OK,
do the job. On return .A=job number and
. X=buf fer number.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0D3</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="6"><p>Transfer buffer number from .X to .A and
save it on the stack. Multiply the
buffer number by two (ASL) and transfer
the result into .X and use it as an
index to store $00 in the buffer table
pointer BUFTAB,X ($99, X)</p>
</td></tr>
				<tr><td></td><td class="fit">D0D4</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">D0D5</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D0D6</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D0D7</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">D0D9</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0DB</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="3"><p>JSR to TYPFIL ($D125) to get the file
type. Compare the file type to $04. If
this is not a sequential file, branch to
WRTC1.</p>
</td></tr>
				<tr><td></td><td class="fit">D0DE</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td></tr>
				<tr><td></td><td class="fit">D0E0</td>
				<td>B0 06</td>
				<td class="fit">BCS $D0E8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0E2</td>
				<td>F6 B5</td>
				<td class="fit">INC $B5,X</td><td rowspan="3"><p>Since this is a sequential file,
increment the lo byte of the block count
in NBKL,X ($B5,X) and, if necessary, the
hi byte in NBKH,X ($BB,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D0E4</td>
				<td>D0 02</td>
				<td class="fit">BNE $D0E8</td></tr>
				<tr><td></td><td class="fit">D0E6</td>
				<td>F6 BB</td>
				<td class="fit">INC $BB,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTC1</td><td class="fit">D0E8</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original buffer number off the
stack and transfer it back into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D0E9</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0EA</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find the assigned read channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDRCH</td><td class="fit">D0EB</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="3"><p>Compare the current secondary address
from SA ($83) with $13 (#19) the
highest allowable secondary address+1.
If too large, branch to FNDC20.</p>
</td></tr>
				<tr><td></td><td class="fit">D0ED</td>
				<td>C9 13</td>
				<td class="fit">CMP #$13</td></tr>
				<tr><td></td><td class="fit">D0EF</td>
				<td>90 02</td>
				<td class="fit">BCC $D0F3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0F1</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="1"><p>AND the secondary address with $0F</p>
<pre><code>Note: This masks off the high order bits
      of the internal channel sec adr's:

        Internal read  $11 (17) -&gt; $01
        Internal write $12 (18) -&gt; $02</code></pre>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDC20</td><td class="fit">D0F3</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td><td rowspan="2"><p>Compare the sec addr in .A with $0F(15),
the command channel sec addr. If they
are not equal, branch to FNDC25.</p>
</td></tr>
				<tr><td></td><td class="fit">D0F5</td>
				<td>D0 02</td>
				<td class="fit">BNE $D0F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D0F7</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td><td rowspan="1"><p>Load .A with $10, the sec addr error
value.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDC25</td><td class="fit">D0F9</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="4"><p>Transfer the sec addr from .A to .X,
set the carry flag, and load the
channel number from LINTAB,X ($022B,X).</p>
<p>If bit 7 is set, no channel has been
assigned for this sec addr, so branch to
FNDC30 to exit (with carry bit set).</p>
</td></tr>
				<tr><td></td><td class="fit">D0FA</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">D0FB</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td></tr>
				<tr><td></td><td class="fit">D0FE</td>
				<td>30 06</td>
				<td class="fit">BMI $D106</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D100</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="4"><p>AND the current channel number with $0F
and store the result as the current
channel number in LINDX ($82). Transfer
the channel number into .X and clear the
carry bit.</p>
</td></tr>
				<tr><td></td><td class="fit">D102</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
				<tr><td></td><td class="fit">D104</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D105</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDC30</td><td class="fit">D106</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find the assigned write channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDWCH</td><td class="fit">D107</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="3"><p>Compare the current secondary address
from SA ($83) with $13 (#19) the
highest allowable secondary address+1.
If too large. branch to FNDW13.</p>
</td></tr>
				<tr><td></td><td class="fit">D109</td>
				<td>C9 13</td>
				<td class="fit">CMP #$13</td></tr>
				<tr><td></td><td class="fit">D10B</td>
				<td>90 02</td>
				<td class="fit">BCC $D10F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D10D</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="1"><p>AND the secondary address with $0F</p>
<pre><code>Note: This masks off the high order bits
      of the internal channel sec adr's:

        Internal read  $11 (17) -&gt; $01
        Internal write $12 (18) -&gt; $02</code></pre>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDW13</td><td class="fit">D10F</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="2"><p>Transfer the sec addr from .A to .X,
and load the channel number assigned to
this sec addr from LINTAB,X ($022B,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D110</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D113</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="1"><p>Transfer this channel number to .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D114</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="1"><p>Do an ASL of the channel number in .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D115</td>
				<td>90 0A</td>
				<td class="fit">BCC $D121</td><td rowspan="1"><p>If a channel has been assigned for this
sec addr (bit 7 of LINTAB,X is not set)
branch to FNDW15.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D117</td>
				<td>30 0A</td>
				<td class="fit">BMI $D123</td><td rowspan="1"><p>If no channel assigned has been assigned
for this secondary address (bit 6 also
set). branch to FNDW20 and abort.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDW10</td><td class="fit">D119</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="6"><p>Transfer the original sec addr from .Y
to .A, AND it with $0F to mask off any
high order bits, and store it in LINDX
($82) as the currently active channel.
Transfer the channel number to .X, clear
the carry flag, and terminate with RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D11A</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">D11C</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
				<tr><td></td><td class="fit">D11E</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D11F</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">D120</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDW15</td><td class="fit">D121</td>
				<td>30 F6</td>
				<td class="fit">BMI $D119</td><td rowspan="1"><p>If bit 6 of LINTAB,X is set (indicates
an inactive channel), branch to FNDW10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDW20</td><td class="fit">D123</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="2"><p>Abort by setting the carry flag and
terminate the routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D124</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get current file type</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TYPFIL</td><td class="fit">D125</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D127</td>
				<td>B5 EC</td>
				<td class="fit">LDA $EC,X</td><td rowspan="1"><p>Load .A with the file type from the
file type table, FILTYP,X ($EC,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D129</td>
				<td>4A</td>
				<td class="fit">LSR</td><td rowspan="3"><p>Divide the file type by 2 (LSR). AND
it with $07 to mask off higher order
bits, and compare the result with $04
'(set the Z flag if it is a REL file!).</p>
</td></tr>
				<tr><td></td><td class="fit">D12A</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">D12C</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D12E</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set buffer pointers</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETPRE</td><td class="fit">D12F</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D132</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by 2 (ASL)
and transfer the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D133</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D134</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D136</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Read one byte from the active buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETBYT</td><td class="fit">D137</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>If last data byte in buffer, set Z flag.
JSR to GETPRE to set buffer pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D13A</td>
				<td>B9 44 02</td>
				<td class="fit">LDA $0244,Y</td><td rowspan="1"><p>Load .A with the pointer to the last
character read from LSTCHR,Y ($0244, Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D13D</td>
				<td>F0 12</td>
				<td class="fit">BEQ $D151</td><td rowspan="1"><p>If pointer is zero, branch to GETB1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D13F</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="2"><p>Load the data byte from (BUFTAB,X)
($99, X) and save it on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D141</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D142</td>
				<td>B5 99</td>
				<td class="fit">LDA $99,X</td><td rowspan="3"><p>Load the pointer from BUFTAB,X ($99, X)
and compare it to the pointer to the
last character read in LSTCHR,Y. If the
pointers are not equal, branch to GETB2.</p>
</td></tr>
				<tr><td></td><td class="fit">D144</td>
				<td>D9 44 02</td>
				<td class="fit">CMP $0244,Y</td></tr>
				<tr><td></td><td class="fit">D147</td>
				<td>D0 04</td>
				<td class="fit">BNE $D14D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D149</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF in BUFTAB,X ($99, X)</p>
</td></tr>
				<tr><td></td><td class="fit">D14B</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETB2</td><td class="fit">D14D</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the data byte off the stack and
increment BUFTAB,X ($99, X). This will
set the Z flag if this is the last byte.</p>
</td></tr>
				<tr><td></td><td class="fit">D14E</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D150</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETB1</td><td class="fit">D151</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="1"><p>Load the data byte from (BUFTAB,X)
($99, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D153</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td><td rowspan="1"><p>Increment BUFTAB,X ($99, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D155</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Read byte from file</h1>
<p>The next file will be read if necessary
and CHNRDY($F2) will be set to EOI if
we have read the last character in file.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDBYT</td><td class="fit">D156</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="5"><p>JSR to GETBYT to read a byte from the
active buffer. On return, if Z flag is
not set, we did not read the last byte
in the buffer so branch to RD3 and RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D159</td>
				<td>D0 36</td>
				<td class="fit">BNE $D191</td></tr>
				<tr><td></td><td class="fit">D15B</td>
				<td>85 85</td>
				<td class="fit">STA $85</td></tr>
				<tr><td></td><td class="fit">D15D</td>
				<td>B9 44 02</td>
				<td class="fit">LDA $0244,Y</td></tr>
				<tr><td></td><td class="fit">D160</td>
				<td>F0 08</td>
				<td class="fit">BEQ $D16A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D162</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="1"><p>We read the last byte so load .A with
$80, the EOI flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD01</td><td class="fit">D164</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td><td rowspan="1"><p>Store the channel status (in .A) into
CHNRDY,Y ($00F2,Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D167</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the byte from DATA ($85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D169</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit from routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD1</td><td class="fit">D16A</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to begin double
buffering.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D16D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to SETPNT
($D4C8) to set up the buffer pointers</p>
</td></tr>
				<tr><td></td><td class="fit">D16F</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D172</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="1"><p>JSR to GETBYT ($D137) to read the first
byte from the active buffer (track link)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D175</td>
				<td>C9 00</td>
				<td class="fit">CMP #$00</td><td rowspan="2"><p>Compare the track link to $00. If it is
$00, there is no next block so branch
to RD4.</p>
</td></tr>
				<tr><td></td><td class="fit">D177</td>
				<td>F0 19</td>
				<td class="fit">BEQ $D192</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D179</td>
				<td>85 80</td>
				<td class="fit">STA $80</td><td rowspan="1"><p>There is another block in this file so
store the track link in TRACK ($80).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D17B</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="2"><p>JSR to GETBYT ($D137) to read the next
byte from the active buff er (sector link)
and store it in SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">D17E</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D180</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to begin double
buffering.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D183</td>
				<td>20 D3 D1</td>
				<td class="fit">JSR $D1D3</td><td rowspan="1"><p>JSR to SETDRN ($D1D3) to set up the
drive number.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D186</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>JSR to SETHDR ($D6D0) to set up the
next header image.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D189</td>
				<td>20 C3 D0</td>
				<td class="fit">JSR $D0C3</td><td rowspan="1"><p>JSR to RDBUF ($D0C3) to read in the next
block in the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D18C</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active &amp; inactive buffers &amp; read ahead.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D18F</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the byte from DATA ($85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD3</td><td class="fit">D191</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit from routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD4</td><td class="fit">D192</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="1"><p>JSR to GETBYTE ($D137) to get the next
byte .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D195</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="2"><p>Load .Y with the current channel number
from LINDX ($82) and store the new
character as the pointer to the last
character read from the data buffer
LSTCHR,Y ($0244, Y).</p>
</td></tr>
				<tr><td></td><td class="fit">D197</td>
				<td>99 44 02</td>
				<td class="fit">STA $0244,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D19A</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the byte from DATA ($85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D19C</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit from routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write character to the active channel</h1>
<p>If this fills the buffer, write the
data buffer out to disk.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTBYT</td><td class="fit">D19D</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td><td rowspan="1"><p>JSR to PUTBYT ($CFF1) to write the byte
to the active channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1A0</td>
				<td>F0 01</td>
				<td class="fit">BEQ $D1A3</td><td rowspan="1"><p>If Z flag is set on return, the buffer
is full so branch to WRTO.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1A2</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit from routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRT0</td><td class="fit">D1A3</td>
				<td>20 D3 D1</td>
				<td class="fit">JSR $D1D3</td><td rowspan="1"><p>JSR to SETDRN ($D1D3) to set the current
drive number from the one in LSTJOB.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1A6</td>
				<td>20 1E F1</td>
				<td class="fit">JSR $F11E</td><td rowspan="1"><p>JSR to NXTTS ($F11E) to get the next
available track and sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1A9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="1"><p>Load .A with $00 and JSR to SETPNT
($D4C8) to set up the buffer pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1AB</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td><td rowspan="3"><p>Load .A with the next available track
from TRACK ($80) and JSR to PUTBYT
($CFF1) to store the track link.</p>
</td></tr>
				<tr><td></td><td class="fit">D1AE</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">D1B0</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1B3</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Load .A with the next available sector
from SECTOR ($81) and JSR to PUTBYT
($CFF1) to store the sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">D1B5</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1B8</td>
				<td>20 C7 D0</td>
				<td class="fit">JSR $D0C7</td><td rowspan="1"><p>JSR to WRTBUF ($D0C7) to write out the
buffer to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1BB</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers and set up
the next inactive buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1BE</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>JSR to SETHDR ($D6D0) to set up the
header image for the next block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1C1</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Load .A with $02 (to bypass the track
and sector link) and JMP to SETPNT to
set up the pointers to the next buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D1C3</td>
				<td>4C C8 D4</td>
				<td class="fit">JMP $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INCPTR</td><td class="fit">D1C6</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td><td rowspan="1"><p>Increment the pointer of the active
buffer by .A
Store the value from .A in TEMP ($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1C8</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="1"><p>JSR to GETPNT ($D4E8) to get the active
buffer pointer (in .A).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1CB</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="4"><p>Clear the carry flag and add the value
from TEMP ($6F). Store the result into
BUFTAB,X ($99', X) and into DIRBUF ($94).</p>
</td></tr>
				<tr><td></td><td class="fit">D1CC</td>
				<td>65 6F</td>
				<td class="fit">ADC $6F</td></tr>
				<tr><td></td><td class="fit">D1CE</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
				<tr><td></td><td class="fit">D1D0</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1D2</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set drive number</h1>
<p>Sets DRVNUM to the same drive as was
used on the last job for the active
buffer.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETDRN</td><td class="fit">D1D3</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($D4E8) to get the active
buffer number (in .A).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1D6</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="2"><p>Transfer the buffer number to .X and use
it as an index to load the last job
number from LSTJOB,X ($025B) into .A.</p>
</td></tr>
				<tr><td></td><td class="fit">D1D7</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1DA</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the job number with $01 to mask off
all but the drive number bit and store
the result as the current drive number
in DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">D1DC</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1DE</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open a new write channel</h1>
<p>.A = number of buffers needed</p>
<p>The routine allocates a buffer number
and sets the logical file index, LINDX.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETWCH</td><td class="fit">D1DF</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="1"><p>Set the carry flag to indicate that we
want a write channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1E0</td>
				<td>B0 01</td>
				<td class="fit">BCS $D1E3</td><td rowspan="1"><p>Branch to GETR2 .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open a new read channel</h1>
<p>.A = number of buffers needed</p>
<p>The routine allocates a buffer number
and sets the channel*, LINDX.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETRCH</td><td class="fit">D1E2</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Clear the carry flag to indicate that we
want a read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETR2</td><td class="fit">D1E3</td>
				<td>08</td>
				<td class="fit">PHP</td><td rowspan="1"><p>Save the processor status (the carry
flag) onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1E4</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td><td rowspan="1"><p>Save the number of buffer needed (in .A)
into TEMP ($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1E6</td>
				<td>20 27 D2</td>
				<td class="fit">JSR $D227</td><td rowspan="1"><p>JSR to FRECHN ($D227) to free any
channels associated with this secondary
address .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1E9</td>
				<td>20 7F D3</td>
				<td class="fit">JSR $D37F</td><td rowspan="1"><p>JSR to FNDLNX ($D37F) to find the next
free logical index (channel) to use and
allocate it.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1EC</td>
				<td>85 82</td>
				<td class="fit">STA $82</td><td rowspan="1"><p>Store the new channel number in LINDX
as the current channel number.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1EE</td>
				<td>A6 83</td>
				<td class="fit">LDX $83</td><td rowspan="1"><p>Load .X with the current secondary
address from SA ($83) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1F0</td>
				<td>28</td>
				<td class="fit">PLP</td><td rowspan="2"><p>Pull the processor status off the stack
and if carry flag is clear (read) ,
branch to GETR55.</p>
</td></tr>
				<tr><td></td><td class="fit">D1F1</td>
				<td>90 02</td>
				<td class="fit">BCC $D1F5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETR52</td><td class="fit">D1F3</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td><td rowspan="1"><p>OR the channel number in .A with $80 to
set bit 7 to indicate a write file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETR55</td><td class="fit">D1F5</td>
				<td>9D 2B 02</td>
				<td class="fit">STA $022B,X</td><td rowspan="1"><p>Store the channel number (in .A) into
the logical index table, LINTAB,X
($022B,X) .
NOTE: Bit 7 set for a write channel</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1F8</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td><td rowspan="2"><p>AND the channel number in .A with $3F
to mask off the write channel bit and
transfer the result to .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D1FA</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D1FB</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="4"><p>De-allocate any buffers associated with
this channel by storing $FF in BUF0,Y
($00A7,Y), in BUF1,Y ($00AE,Y), and in
SS,Y ($00CD,Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">D1FD</td>
				<td>99 A7 00</td>
				<td class="fit">STA $00A7,Y</td></tr>
				<tr><td></td><td class="fit">D200</td>
				<td>99 AE 00</td>
				<td class="fit">STA $00AE,Y</td></tr>
				<tr><td></td><td class="fit">D203</td>
				<td>99 CD 00</td>
				<td class="fit">STA $00CD,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETR3</td><td class="fit">D206</td>
				<td>C6 6F</td>
				<td class="fit">DEC $6F</td><td rowspan="2"><p>Decrement the value in TEMP ($6F). This
is the number of buffers to allocate.
If there are no more to allocate ($FF) ,
branch to GETR4 and exit.</p>
</td></tr>
				<tr><td></td><td class="fit">D208</td>
				<td>30 1C</td>
				<td class="fit">BMI $D226</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D20A</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td><td rowspan="2"><p>JSR to GETBUF ($D28E) to allocate a new
buffer. If a buffer was allocated,
branch to GETR5 .</p>
</td></tr>
				<tr><td></td><td class="fit">D20D</td>
				<td>10 08</td>
				<td class="fit">BPL $D217</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETERR</td><td class="fit">D20F</td>
				<td>20 5A D2</td>
				<td class="fit">JSR $D25A</td><td rowspan="1"><p>No buffers available, so JSR to RELBUF
($D25A) to release any buffers allocated</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D212</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td><td rowspan="2"><p>Load .A with $70 to indicate a NO
CHANNEL error and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">D214</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETR5</td><td class="fit">D217</td>
				<td>99 A7 00</td>
				<td class="fit">STA $00A7,Y</td><td rowspan="1"><p>Store the buffer number (in .A) into
BUF0,Y ($00A7,Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D21A</td>
				<td>C6 6F</td>
				<td class="fit">DEC $6F</td><td rowspan="2"><p>Decrement the value in TEMP ($6F). This
is the number of buffers to allocate.
If there are no more to allocate ($FF) ,
branch to GETR4 and exit.</p>
</td></tr>
				<tr><td></td><td class="fit">D21C</td>
				<td>30 08</td>
				<td class="fit">BMI $D226</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D21E</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td><td rowspan="2"><p>JSR to GETBUF ($D28E) to allocate a new
buffer. If a buffer was NOT allocated,
branch to GETERR and abort.</p>
</td></tr>
				<tr><td></td><td class="fit">D221</td>
				<td>30 EC</td>
				<td class="fit">BMI $D20F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D223</td>
				<td>99 AE 00</td>
				<td class="fit">STA $00AE,Y</td><td rowspan="1"><p>Store the buffer number (in .A) into
BUF1,Y ($00AE,Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETR4</td><td class="fit">D226</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Free channel associated with SA</h1>
<p>Read and write channels are freed. The
command channel is not freed.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRECHN</td><td class="fit">D227</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="3"><p>Load .A with the secondary address from
SA ($83). Compare it with $0F (#15), the
command channel secondary address. If
the secondary address is not $0F, branch
to FRECO.</p>
</td></tr>
				<tr><td></td><td class="fit">D229</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td></tr>
				<tr><td></td><td class="fit">D22B</td>
				<td>D0 01</td>
				<td class="fit">BNE $D22E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D22D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Since we are not to free the command
channel, simply exit with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRECO</td><td class="fit">D22E</td>
				<td>A6 83</td>
				<td class="fit">LDX $83</td><td rowspan="1"><p>Free data channel associated with SA:
Load .X with the secondary address from
SA ($83) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D230</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td><td rowspan="3"><p>Load .A with the channel number
associated with this secondary address
from LINTAB,X ($022B,X). If it is $FF,
there is no associated channel so branch
to FRE25 and exit.</p>
</td></tr>
				<tr><td></td><td class="fit">D233</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">D235</td>
				<td>F0 22</td>
				<td class="fit">BEQ $D259</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D237</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td><td rowspan="2"><p>AND the channel number with $3F to mask
off the higher order bits and store the
result as the current channel in LINDX
($82) .</p>
</td></tr>
				<tr><td></td><td class="fit">D239</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D23B</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Free the channel by storing $FF into
LINTAB,X ($022B,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D23D</td>
				<td>9D 2B 02</td>
				<td class="fit">STA $022B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D240</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="3"><p>Load .X with the channel number from
LINDX ($82) and store $00 as the channel
status (free) inCHNRDY,X ($F2,Y).</p>
</td></tr>
				<tr><td></td><td class="fit">D242</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">D244</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D246</td>
				<td>20 5A D2</td>
				<td class="fit">JSR $D25A</td><td rowspan="1"><p>JSR to RELBUF ($D25A) to release buffers</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELINX</td><td class="fit">D249</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="2"><p>Load .X with the channel number from
LINDX ($82) and .A with $01.</p>
</td></tr>
				<tr><td></td><td class="fit">D24B</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REL15</td><td class="fit">D24D</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement .X, the channel number. If
it is $FF (no lower channel numbers) ,
branch to REL10.</p>
</td></tr>
				<tr><td></td><td class="fit">D24E</td>
				<td>30 03</td>
				<td class="fit">BMI $D253</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D250</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="1"><p>Do an ASL on the value in .A. Note that
the bit set shifts left one position
each time through the loop.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D251</td>
				<td>D0 FA</td>
				<td class="fit">BNE $D24D</td><td rowspan="1"><p>If .A &lt;&gt; f branch to REL15 (always).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REL10</td><td class="fit">D253</td>
				<td>0D 56 02</td>
				<td class="fit">ORA $0256</td><td rowspan="2"><p>OR the value in the accumulator with
LINUSE ($0256) to free the channel
(bit = 1 for free; bit = for used) .
Store the resulting value back in
LINUSE ($0256) .</p>
</td></tr>
				<tr><td></td><td class="fit">D256</td>
				<td>8D 56 02</td>
				<td class="fit">STA $0256</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRE25</td><td class="fit">D259</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELBUF</td><td class="fit">D25A</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Release buffers associated with channel:
Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D25C</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="3"><p>Load .A with the buffer number for this
channel from BUF0,X ($A7,X). Compare the
buffer number with $FF (free). If it is
already free, branch to REL1.</p>
</td></tr>
				<tr><td></td><td class="fit">D25E</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">D260</td>
				<td>F0 09</td>
				<td class="fit">BEQ $D26B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D262</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="3"><p>Save the buffer number on the stack and
store $FF into BUF0,X ($A7,X) to free
this buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D263</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td></tr>
				<tr><td></td><td class="fit">D265</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D267</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the buffer number off the stack and
JSR to FREBUF ($D2F3) to free the buffer</p>
</td></tr>
				<tr><td></td><td class="fit">D268</td>
				<td>20 F3 D2</td>
				<td class="fit">JSR $D2F3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REL1</td><td class="fit">D26B</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D26D</td>
				<td>B5 AE</td>
				<td class="fit">LDA $AE,X</td><td rowspan="3"><p>Load .A with the buffer number for this
channel from BUFlfX ($AE,X). Compare the
buffer number with $FF (free). If it is
already free, branch to REL2 .</p>
</td></tr>
				<tr><td></td><td class="fit">D26F</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">D271</td>
				<td>F0 09</td>
				<td class="fit">BEQ $D27C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D273</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="3"><p>Save the buffer number on the stack and
store $FF into BUF1,X ($AE,X) to free
this buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D274</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td></tr>
				<tr><td></td><td class="fit">D276</td>
				<td>95 AE</td>
				<td class="fit">STA $AE,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D278</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the buffer number off the stack and
JSR to FREBUF ($D2F3) to free the buffer</p>
</td></tr>
				<tr><td></td><td class="fit">D279</td>
				<td>20 F3 D2</td>
				<td class="fit">JSR $D2F3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REL2</td><td class="fit">D27C</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D27E</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="3"><p>Load .A with the side sector for this
channel from SS f X ($CD,X). Compare the
side sector with $FF (free). If it is
already free, branch to REL3 .</p>
</td></tr>
				<tr><td></td><td class="fit">D280</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">D282</td>
				<td>F0 09</td>
				<td class="fit">BEQ $D28D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D284</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="3"><p>Save the side sector on the stack and
store $FF into SS,X ($CD,X) to free the
side sector pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">D285</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td></tr>
				<tr><td></td><td class="fit">D287</td>
				<td>95 CD</td>
				<td class="fit">STA $CD,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D289</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the side sector off the stack and
JSR to FREBUF ($D2F3) to free any buffer</p>
</td></tr>
				<tr><td></td><td class="fit">D28A</td>
				<td>20 F3 D2</td>
				<td class="fit">JSR $D2F3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REL3</td><td class="fit">D28D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get a free buffer number .Y=channel</h1>
<p>If successful, initialize JOBS &amp; LSTJOB
and return with buffer number in .A.</p>
<p>If not successful, .A = $FF; N flag set.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETBUF</td><td class="fit">D28E</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Save channel number by transferring it
from .Y to .A and pushing it on the
stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D28F</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D290</td>
				<td>A0 01</td>
				<td class="fit">LDY #$01</td><td rowspan="3"><p>Load .Y with $01 and JSR to FNDBUF
($D2BA) to find a free buffer (# in .X).
If one is found, branch to GBF1.</p>
</td></tr>
				<tr><td></td><td class="fit">D292</td>
				<td>20 BA D2</td>
				<td class="fit">JSR $D2BA</td></tr>
				<tr><td></td><td class="fit">D295</td>
				<td>10 0C</td>
				<td class="fit">BPL $D2A3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D297</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="3"><p>Decrement .Y and JSR to FNDBUF ($D2BA)
to find a free buffer (# in .X). If one
found, branch to GBF1.</p>
</td></tr>
				<tr><td></td><td class="fit">D298</td>
				<td>20 BA D2</td>
				<td class="fit">JSR $D2BA</td></tr>
				<tr><td></td><td class="fit">D29B</td>
				<td>10 06</td>
				<td class="fit">BPL $D2A3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D29D</td>
				<td>20 39 D3</td>
				<td class="fit">JSR $D339</td><td rowspan="3"><p>Can't find a free one so let's try to
steal one! JSR to STLBUF ($D339) to try
to steal an inactive one. On return,
buffer # in .A so transfer it to .X. If
we didn't get one, branch to GBF2.</p>
</td></tr>
				<tr><td></td><td class="fit">D2A0</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D2A1</td>
				<td>30 13</td>
				<td class="fit">BMI $D2B6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GBF1</td><td class="fit">D2A3</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="2"><p>Wait till any job using JOBS,X ($00, X)
is completed.</p>
</td></tr>
				<tr><td></td><td class="fit">D2A5</td>
				<td>30 FC</td>
				<td class="fit">BMI $D2A3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2A7</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>Clear the job queue by setting JOBS,X
($00, X) and LSTJOB, X ($025B,X) to the
current drive number using the value
from DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">D2A9</td>
				<td>95 00</td>
				<td class="fit">STA $00,X</td></tr>
				<tr><td></td><td class="fit">D2AB</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2AE</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the buffer number from .X to .A
multiply it by two (ASL). and transfer
the result to .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D2AF</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D2B0</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2B1</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Store a $02 on BUFTAB,Y ($0099, Y) so the
pointer points beyond the track and
sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">D2B3</td>
				<td>99 99 00</td>
				<td class="fit">STA $0099,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GBF2</td><td class="fit">D2B6</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Restore the original .Y value from the
stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D2B7</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2B8</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Transfer the buffer number from .X to .A
to set the N flag if not successful.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2B9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find a free buffer and set BUFUSE:</h1>
<p>On entry: .Y = index into BUFUSE:
Y=0 buffers 0-7; Y=1 buffers 8-15</p>
<p>If successful, .X = buffer number
If not successful, .X = $FF; N flag set</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDBUF</td><td class="fit">D2BA</td>
				<td>A2 07</td>
				<td class="fit">LDX #$07</td><td rowspan="1"><p>Load .X with $07 (for bit test)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FB1</td><td class="fit">D2BC</td>
				<td>B9 4F 02</td>
				<td class="fit">LDA $024F,Y</td><td rowspan="3"><p>Load .A with BUFUSE, Y ($024F,X). Each
bit indicates whether a buffer is free
(1) or in use (0).</p>
<p>AND this value in .A
with the bit mask, BMASK,X ($EFE9,X).</p>
<p>Each of these masks has just one bit
set. If the result of the AND is $00,
we have found a free buffer so branch
to FB2.</p>
</td></tr>
				<tr><td></td><td class="fit">D2BF</td>
				<td>3D E9 EF</td>
				<td class="fit">AND $EFE9,X</td></tr>
				<tr><td></td><td class="fit">D2C2</td>
				<td>F0 04</td>
				<td class="fit">BEQ $D2C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2C4</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement .X to try next buffer. If any
left, branch back to FBI.</p>
</td></tr>
				<tr><td></td><td class="fit">D2C5</td>
				<td>10 F5</td>
				<td class="fit">BPL $D2BC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2C7</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>No more buffers to try (.X=$FF) so exit
with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FB2</td><td class="fit">D2C8</td>
				<td>B9 4F 02</td>
				<td class="fit">LDA $024F,Y</td><td rowspan="3"><p>Found a free buffer so let's grab it!
Load .A with the value in BUFUSE, Y
($024F,Y), EOR it with the bit map for
the free buffer, BMASK,X ($EFE9,X), and
store the result back in BUFUSE, Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D2CB</td>
				<td>5D E9 EF</td>
				<td class="fit">EOR $EFE9,X</td></tr>
				<tr><td></td><td class="fit">D2CE</td>
				<td>99 4F 02</td>
				<td class="fit">STA $024F,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2D1</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the buffer number from .X to
.A and if .Y is $00, branch to FB3 .</p>
</td></tr>
				<tr><td></td><td class="fit">D2D2</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">D2D3</td>
				<td>30 03</td>
				<td class="fit">BMI $D2D8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2D5</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Since .Y is $01 (never happens on the
1541). we have to add 8 to the buffer
number. So: Clear the carry flag and add
$08 to the buffer number in .A.</p>
</td></tr>
				<tr><td></td><td class="fit">D2D6</td>
				<td>69 08</td>
				<td class="fit">ADC #$08</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FB3</td><td class="fit">D2D8</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the buffer number from .A to .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRI20</td><td class="fit">D2D9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Free the inactive buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREIAC</td><td class="fit">D2DA</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2DC</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="2"><p>Load .A with the buffer number from
BUF0,X ($A7,X). If bit 7 is set, branch
to FRI10.</p>
</td></tr>
				<tr><td></td><td class="fit">D2DE</td>
				<td>30 09</td>
				<td class="fit">BMI $D2E9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2E0</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="4"><p>Transfer the channel number from .X to
.A, clear the carry flag, add $07 (the
maximum number of channels +1). and
transfer the result back into .X. This
is the alternate buffer for this channel</p>
</td></tr>
				<tr><td></td><td class="fit">D2E1</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">D2E2</td>
				<td>69 07</td>
				<td class="fit">ADC #$07</td></tr>
				<tr><td></td><td class="fit">D2E4</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2E5</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="2"><p>Load .A with the buffer number from
BUF0,X ($A7,X). If bit 7 is NOT set,
this buffer is active too so exit to
FRI20 (above) .</p>
</td></tr>
				<tr><td></td><td class="fit">D2E7</td>
				<td>10 F0</td>
				<td class="fit">BPL $D2D9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRI10</td><td class="fit">D2E9</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td><td rowspan="2"><p>Compare the buffer number to $FF. If it
is $FF, the buffer is free already so
exit to FRI20 (above).</p>
</td></tr>
				<tr><td></td><td class="fit">D2EB</td>
				<td>F0 EC</td>
				<td class="fit">BEQ $D2D9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2ED</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save the buffer number on the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2EE</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Free the buffer by storing $FF into
BUF0,X ($A7,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D2F0</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2F2</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the buffer number off the stack.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Free buffer in BUFUSE</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREBUF</td><td class="fit">D2F3</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="3"><p>AND the buffer number with $0F to mask
off any higher order bits, transfer the
result into .Y and increment .Y by 1.</p>
</td></tr>
				<tr><td></td><td class="fit">D2F5</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">D2F6</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D2F7</td>
				<td>A2 10</td>
				<td class="fit">LDX #$10</td><td rowspan="1"><p>Load .X with $10 (#16) 2*8 bits</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREB1</td><td class="fit">D2F9</td>
				<td>6E 50 02</td>
				<td class="fit">ROR $0250</td><td rowspan="8"><p>Loop to ROR BUFUSE+1 ($0250) and BUFUSE
($024F) 16 times. Use .Y to count down
to 0. When .Y is zero, the bit that
corresponds to the buffer we want is
in the carry flag so we clear the carry
bit to free that buffer. We then keep
looping until .X has counted down all
the way from $10 to $FF. When .X reaches
$FF, the bits are all back in the right
places, so exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D2FC</td>
				<td>6E 4F 02</td>
				<td class="fit">ROR $024F</td></tr>
				<tr><td></td><td class="fit">D2FF</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">D300</td>
				<td>D0 01</td>
				<td class="fit">BNE $D303</td></tr>
				<tr><td></td><td class="fit">D302</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">D303</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">D304</td>
				<td>10 F3</td>
				<td class="fit">BPL $D2F9</td></tr>
				<tr><td></td><td class="fit">D306</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Clear all channels except the CMD one</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLRCHN</td><td class="fit">D307</td>
				<td>A9 0E</td>
				<td class="fit">LDA #$0E</td><td rowspan="2"><p>Set the current secondary address in SA
($83) to $0E (#14)</p>
</td></tr>
				<tr><td></td><td class="fit">D309</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLRC1</td><td class="fit">D30B</td>
				<td>20 27 D2</td>
				<td class="fit">JSR $D227</td><td rowspan="1"><p>JSR to FRECHN ($D227) to free the
channel whose secondary address is SA</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D30E</td>
				<td>C6 83</td>
				<td class="fit">DEC $83</td><td rowspan="2"><p>Decrement the value in SA ($83). If it-
is not $00. branch back to CLRC1.</p>
</td></tr>
				<tr><td></td><td class="fit">D310</td>
				<td>D0 F9</td>
				<td class="fit">BNE $D30B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D312</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Close all channels except the CMD one</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLDCHN</td><td class="fit">D313</td>
				<td>A9 0E</td>
				<td class="fit">LDA #$0E</td><td rowspan="2"><p>Set the current secondary address in SA
($83) to $0E (#14)</p>
</td></tr>
				<tr><td></td><td class="fit">D315</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSD</td><td class="fit">D317</td>
				<td>A6 83</td>
				<td class="fit">LDX $83</td><td rowspan="4"><p>Load .X with the secondary address from
SA ($83) and use it as an index to load
.A with the channel number from LINTAB,X
($022B,X). Compare the channel number
with $FF; if equal, no channel has been
assigned so branch to CLD2.</p>
</td></tr>
				<tr><td></td><td class="fit">D319</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td></tr>
				<tr><td></td><td class="fit">D31C</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">D31E</td>
				<td>F0 14</td>
				<td class="fit">BEQ $D334</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D320</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td><td rowspan="2"><p>AND the channel number with $3F to mask
off the higher order bits and store the
result in LINDX ($82) as the current
channel number.</p>
</td></tr>
				<tr><td></td><td class="fit">D322</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D324</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT to get the active buffer
number for this channel (returned in .A)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D327</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="2"><p>Transfer the buffer number to .X and
use it load .A with the last job number
for this buffer from LSTJOB,X ($025B / X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D328</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D32B</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="3"><p>AND the last job number with $01 and
compare it with the current drive number
in DRVNUM ($7F). If not equal, branch to
CLD2.</p>
</td></tr>
				<tr><td></td><td class="fit">D32D</td>
				<td>C5 7F</td>
				<td class="fit">CMP $7F</td></tr>
				<tr><td></td><td class="fit">D32F</td>
				<td>D0 03</td>
				<td class="fit">BNE $D334</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D331</td>
				<td>20 27 D2</td>
				<td class="fit">JSR $D227</td><td rowspan="1"><p>JSR to FRECHN ($D227) to free this
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D334</td>
				<td>C6 83</td>
				<td class="fit">DEC $83</td><td rowspan="2"><p>Decrement the secondary address in SA
($83) and if there are more to do (not
$FF yet). branch back to CLSD</p>
</td></tr>
				<tr><td></td><td class="fit">D336</td>
				<td>10 DF</td>
				<td class="fit">BPL $D317</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D338</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Steal an inactive buffer</h1>
<p>Scan the least recently used table and
steal the first inactive buffer found.</p>
<p>Returns the stolen buffer number in .A</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STLBUF</td><td class="fit">D339</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="3"><p>Save the value in TO ($6F) on the stack
and zero .Y (the index to LRUTBL) .</p>
</td></tr>
				<tr><td></td><td class="fit">D33B</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">D33C</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STL05</td><td class="fit">D33E</td>
				<td>B6 FA</td>
				<td class="fit">LDX $FA,Y</td><td rowspan="1"><p>Load .X (the channel index) with the
value from LRUTBL, Y ($FA,Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D340</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="2"><p>Load .A with the buffer status for this
channel from BUF0,X ($A7,X). If this
buffer is active (status &lt; 128). branch
to STL10.</p>
</td></tr>
				<tr><td></td><td class="fit">D342</td>
				<td>10 04</td>
				<td class="fit">BPL $D348</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D344</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td><td rowspan="2"><p>Compare the status to $FF (unused). If
not equal, it's inactive so branch to
STL30 to steal it!</p>
</td></tr>
				<tr><td></td><td class="fit">D346</td>
				<td>D0 16</td>
				<td class="fit">BNE $D35E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STL10</td><td class="fit">D348</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="4"><p>Transfer the channel number from .X to
.A, clear the carry flag, add $07 (the
maximum number of channels +1). and
transfer the result back into .X. Note
.X now points to the alternative buffer
for this channel.</p>
</td></tr>
				<tr><td></td><td class="fit">D349</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">D34A</td>
				<td>69 07</td>
				<td class="fit">ADC #$07</td></tr>
				<tr><td></td><td class="fit">D34C</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D34D</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="4"><p>Load .A with the buffer status for this
channel from BUF0,X ($A7,X). If this
buffer is active (status &lt; 128). branch
to STL3 0.</p>
</td></tr>
				<tr><td></td><td class="fit">D34F</td>
				<td>10 04</td>
				<td class="fit">BPL $D355</td></tr>
				<tr><td></td><td class="fit">D351</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">D353</td>
				<td>D0 09</td>
				<td class="fit">BNE $D35E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STL20</td><td class="fit">D355</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y and compare the new value
with #$05 (the maximum number of
channels +1). If there are still some
channels left to check, branch to STL05</p>
</td></tr>
				<tr><td></td><td class="fit">D356</td>
				<td>C0 05</td>
				<td class="fit">CPY #$05</td></tr>
				<tr><td></td><td class="fit">D358</td>
				<td>90 E4</td>
				<td class="fit">BCC $D33E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D35A</td>
				<td>A2 FF</td>
				<td class="fit">LDX #$FF</td><td rowspan="2"><p>No luck stealing a buffer so load .X
with $FF (indicates failure) and branch
to STL6 to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">D35C</td>
				<td>D0 1C</td>
				<td class="fit">BNE $D37A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STL30</td><td class="fit">D35E</td>
				<td>86 6F</td>
				<td class="fit">STX $6F</td><td rowspan="1"><p>Store the channel number (in .X) into
TO ($6F) temporarily.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D360</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td><td rowspan="2"><p>AND the buffer number in .A with $3F to
mask off any higher order bits and
transfer the result to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D362</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STL40</td><td class="fit">D363</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="2"><p>Check if the buffer is being used for
a job currently underway by loading .A
with the job queue byte for the buffer
from JOBS,X ($00, X). If bit 7 is set,
a job is in progress so branch back to
STL40 to wait for completion.</p>
</td></tr>
				<tr><td></td><td class="fit">D365</td>
				<td>30 FC</td>
				<td class="fit">BMI $D363</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D367</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td><td rowspan="2"><p>Compare the job queue value with $02 to
see if any errors occurred. If there
were no errors (job queue was $01) ,
branch to STL50 to steal the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D369</td>
				<td>90 08</td>
				<td class="fit">BCC $D373</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D36B</td>
				<td>A6 6F</td>
				<td class="fit">LDX $6F</td><td rowspan="2"><p>No luck so load .X with the value we
save into TO ($6F) and compare it to
$07 (the maximum number of channels+1) .</p>
</td></tr>
				<tr><td></td><td class="fit">D36D</td>
				<td>E0 07</td>
				<td class="fit">CPX #$07</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D36F</td>
				<td>90 D7</td>
				<td class="fit">BCC $D348</td><td rowspan="1"><p>If .X &lt; $07 we still need to check the
alternative buffer for this channel so
branch to STL10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D371</td>
				<td>B0 E2</td>
				<td class="fit">BCS $D355</td><td rowspan="1"><p>If .X &gt;= $07, we we rechecking the
alternative channel so branch back to
STL20 to check the next channel,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STL50</td><td class="fit">D373</td>
				<td>A4 6F</td>
				<td class="fit">LDY $6F</td><td rowspan="3"><p>We've found an inactive buffer, now to
steal it!
Load .Y with the channel number from TO
($6F) and store $FF into BUF0,Y ($A7,Y)
to steal it.</p>
</td></tr>
				<tr><td></td><td class="fit">D375</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td></tr>
				<tr><td></td><td class="fit">D377</td>
				<td>99 A7 00</td>
				<td class="fit">STA $00A7,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STL60</td><td class="fit">D37A</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the original value of TO off the
stack and restore it. Transfer the
buffer number from .X to .A (sets the
N flag if not successful) and terminate
routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D37B</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">D37D</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">D37E</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDLDX</td><td class="fit">D37F</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Find free LINDX and allocate in LINUSE
Load .Y with $00 and .A with $01.</p>
</td></tr>
				<tr><td></td><td class="fit">D381</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FND10</td><td class="fit">D383</td>
				<td>2C 56 02</td>
				<td class="fit">BIT $0256</td><td rowspan="2"><p>Test whether the same bit is set in
LINUSE ($0256) and the accumulator. If a
bit is set in LINUSE, the corresponding
channel is free. If the test indicates a
free channel, branch to FND30.</p>
</td></tr>
				<tr><td></td><td class="fit">D386</td>
				<td>D0 09</td>
				<td class="fit">BNE $D391</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D388</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="4"><p>Increment .Y (the counter) and do an ASL
on the value in the accumulator to shift
the test bit one place left. If more
tests are needed, branch to FND10.</p>
</td></tr>
				<tr><td></td><td class="fit">D389</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D38A</td>
				<td>D0 F7</td>
				<td class="fit">BNE $D383</td></tr>
				<tr><td></td><td class="fit">D38C</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D38E</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td><td rowspan="1"><p>No channel found so load .A with $70 to
to indicate a NO CHANNEL error and JMP
to CMDERR ($C1C8) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FND30</td><td class="fit">D391</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td><td rowspan="3"><p>EOR the bit mask (in .A) with $FF to
flip the bits, AND the flipped mask with
LINUSE to clear the appropriate bit, and
store the result back in LINUSE ($0256) .</p>
</td></tr>
				<tr><td></td><td class="fit">D393</td>
				<td>2D 56 02</td>
				<td class="fit">AND $0256</td></tr>
				<tr><td></td><td class="fit">D396</td>
				<td>8D 56 02</td>
				<td class="fit">STA $0256</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D399</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Transfer the channel number (LINDX) from
.Y to .A and exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D39A</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get next byte from a channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GBYTE</td><td class="fit">D39B</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D39E</td>
				<td>20 00 C1</td>
				<td class="fit">JSR $C100</td><td rowspan="1"><p>JSR to SETLDS ($C100) to turn on the
drive active light.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3A1</td>
				<td>20 AA D3</td>
				<td class="fit">JSR $D3AA</td><td rowspan="1"><p>JSR to GET ($D3AA) to get one byte from
any type of file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3A4</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="2"><p>Load .X with the current channel number
from LINDX ($82) and load .A with the
data byte from CHNDAT,X ($023E) .</p>
</td></tr>
				<tr><td></td><td class="fit">D3A6</td>
				<td>BD 3E 02</td>
				<td class="fit">LDA $023E,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3A9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get next byte from any type of file</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET</td><td class="fit">D3AA</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="3"><p>Load .X with the current channel number
from LINDX ($82) JSR to TYPFIL ($D125)
to determine the file type. If Z flag
not set on return, this is not a
relative file so branch to GET00.</p>
</td></tr>
				<tr><td></td><td class="fit">D3AC</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td></tr>
				<tr><td></td><td class="fit">D3AF</td>
				<td>D0 03</td>
				<td class="fit">BNE $D3B4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3B1</td>
				<td>4C 20 E1</td>
				<td class="fit">JMP $E120</td><td rowspan="1"><p>It is a relative file so JMP to RDREL
($E120) to do this type.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET00</td><td class="fit">D3B4</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="3"><p>Test if the current secondary address
from SA ($83) is $0F (the CMD channel).
If it is, branch to GETERC ($D414) .</p>
</td></tr>
				<tr><td></td><td class="fit">D3B6</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td></tr>
				<tr><td></td><td class="fit">D3B8</td>
				<td>F0 5A</td>
				<td class="fit">BEQ $D414</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3BA</td>
				<td>B5 F2</td>
				<td class="fit">LDA $F2,X</td><td rowspan="3"><p>Test if the last character we sent on
this channel was an EOI by checking if
the channel status in CHNRDY,X ($F2,X)
is $08. If the last character was NOT
an EOI, branch to GET1.</p>
</td></tr>
				<tr><td></td><td class="fit">D3BC</td>
				<td>29 08</td>
				<td class="fit">AND #$08</td></tr>
				<tr><td></td><td class="fit">D3BE</td>
				<td>D0 13</td>
				<td class="fit">BNE $D3D3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3C0</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="1"><p>Last character was EOI so JSR to TYPFIL
($D125) to determine the file type.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3C3</td>
				<td>C9 07</td>
				<td class="fit">CMP #$07</td><td rowspan="2"><p>If the file type is NOT $07, a random
access file, branch to GETO.</p>
</td></tr>
				<tr><td></td><td class="fit">D3C5</td>
				<td>D0 07</td>
				<td class="fit">BNE $D3CE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3C7</td>
				<td>A9 89</td>
				<td class="fit">LDA #$89</td><td rowspan="3"><p>This is a direct access file so we will
leave it active. Store an $89 (random
access file ready) as the channel status
in CHNRDY,X ($F2,X) and exit with a
JMP to RNDGET ($D3DE) to get the next-
character ready.</p>
</td></tr>
				<tr><td></td><td class="fit">D3C9</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
				<tr><td></td><td class="fit">D3CB</td>
				<td>4C DE D3</td>
				<td class="fit">JMP $D3DE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET0</td><td class="fit">D3CE</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Last character sent was EOI so set the
channel status as NOT READY by storing
a $00 in CHNRDY,X ($F2,X).</p>
</td></tr>
				<tr><td></td><td class="fit">D3D0</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3D2</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET1</td><td class="fit">D3D3</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="2"><p>Test if this is a LOAD by testing if
the secondary address in SA ($83) is a
$00. If it is a LOAD, branch to GET6 .</p>
</td></tr>
				<tr><td></td><td class="fit">D3D5</td>
				<td>F0 32</td>
				<td class="fit">BEQ $D409</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET2</td><td class="fit">D3D7</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="3"><p>It's not a LOAD. Maybe it's a random
access file. JSR to TYPFIL ($D125) to
determine the file type. If the file
type is less than $04, it is NOT a
random access file, so branch to SEQGET.</p>
</td></tr>
				<tr><td></td><td class="fit">D3DA</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td></tr>
				<tr><td></td><td class="fit">D3DC</td>
				<td>90 22</td>
				<td class="fit">BCC $D400</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RNDGET</td><td class="fit">D3DE</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>It is a random access file so JSR to
GETPRE ($D12F) to set up the right
pointers in .X and .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3E1</td>
				<td>B5 99</td>
				<td class="fit">LDA $99,X</td><td rowspan="3"><p>Load the pointer to the data byte into
.A from BUFTAB,X ($99, X). Compare this
value to the pointer to the last-
character pointer in LSTCHR,Y ($0244, Y)
to see if we are up to the last one yet.
If not, branch to RNGET1.</p>
</td></tr>
				<tr><td></td><td class="fit">D3E3</td>
				<td>D9 44 02</td>
				<td class="fit">CMP $0244,Y</td></tr>
				<tr><td></td><td class="fit">D3E6</td>
				<td>D0 04</td>
				<td class="fit">BNE $D3EC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3E8</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>We're at the last character so wrap the
pointer around to the start again by
storing $00 in BUFTAB,X ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">D3EA</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RNGET1</td><td class="fit">D3EC</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td><td rowspan="1"><p>Increment BUFTAB,X ($99, X) to point to
the next character.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RNGET2</td><td class="fit">D3EE</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="1"><p>Load .A with the data byte from
BUFTAB,X ($99, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RNGET4</td><td class="fit">D3F0</td>
				<td>99 3E 02</td>
				<td class="fit">STA $023E,Y</td><td rowspan="1"><p>Save the data byte in CHNDAT,Y ($023E,Y)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3F3</td>
				<td>B5 99</td>
				<td class="fit">LDA $99,X</td><td rowspan="3"><p>Load the pointer from EUFTAB,X and
compare it to the value in LSTCHR,Y
($0244, Y) to see if this is the last
character we're supposed to get. If NOT,
branch to RNGET3 .</p>
</td></tr>
				<tr><td></td><td class="fit">D3F5</td>
				<td>D9 44 02</td>
				<td class="fit">CMP $0244,Y</td></tr>
				<tr><td></td><td class="fit">D3F8</td>
				<td>D0 05</td>
				<td class="fit">BNE $D3FF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D3FA</td>
				<td>A9 81</td>
				<td class="fit">LDA #$81</td><td rowspan="2"><p>Since this is the last character, set
the channel status in CHNRDY,Y to $00
to indicate an EOI (end of information) .</p>
</td></tr>
				<tr><td></td><td class="fit">D3FC</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RNGET3</td><td class="fit">D3FF</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SEQGET</td><td class="fit">D400</td>
				<td>20 56 D1</td>
				<td class="fit">JSR $D156</td><td rowspan="1"><p>JSR to RDBYT ($D156) to read the next-
data byte.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET3</td><td class="fit">D403</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="2"><p>Load .X with the channel number from
LINDX ($82) and store the data byte in
CHNDAT,X ($00F2,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D405</td>
				<td>9D 3E 02</td>
				<td class="fit">STA $023E,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D408</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET6</td><td class="fit">D409</td>
				<td>AD 54 02</td>
				<td class="fit">LDA $0254</td><td rowspan="2"><p>Seems to be a LOAD. Test if it is a
directory listing by seeing if DIRLST
($0254) is a $00. If it is, this is not
a directory listing so branch to SEQGET.</p>
</td></tr>
				<tr><td></td><td class="fit">D40C</td>
				<td>F0 F2</td>
				<td class="fit">BEQ $D400</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D40E</td>
				<td>20 67 ED</td>
				<td class="fit">JSR $ED67</td><td rowspan="2"><p>It is a directory listing so JSR to
GETDIR ($ED67) to get a byte from the
directory and then JMP to GET3 .</p>
</td></tr>
				<tr><td></td><td class="fit">D411</td>
				<td>4C 03 D4</td>
				<td class="fit">JMP $D403</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get byte from the error channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETERC</td><td class="fit">D414</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="3"><p>JSR to GETPNT ($D4E8) to read the active
buffer pointer. If the buffer number is
NOT $D4, lo byte of the pointer to one
byte below error buffer, branch to GE10.</p>
</td></tr>
				<tr><td></td><td class="fit">D417</td>
				<td>C9 D4</td>
				<td class="fit">CMP #$D4</td></tr>
				<tr><td></td><td class="fit">D419</td>
				<td>D0 18</td>
				<td class="fit">BNE $D433</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D41B</td>
				<td>A5 95</td>
				<td class="fit">LDA $95</td><td rowspan="3"><p>Check if DIRBUF+1 ($95) equals $02, the
hi byte of the pointer to the error
buffer. If not, branch to GE10.</p>
</td></tr>
				<tr><td></td><td class="fit">D41D</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D41F</td>
				<td>D0 12</td>
				<td class="fit">BNE $D433</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D421</td>
				<td>A9 0D</td>
				<td class="fit">LDA #$0D</td><td rowspan="3"><p>Store a $0D (#13; RETURN) in DATA ($85)
and JSR to ERROFF ($C123) to turn off
the error LED.</p>
</td></tr>
				<tr><td></td><td class="fit">D423</td>
				<td>85 85</td>
				<td class="fit">STA $85</td></tr>
				<tr><td></td><td class="fit">D425</td>
				<td>20 23 C1</td>
				<td class="fit">JSR $C123</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D428</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to ERRTS0
($E6C1) to transfer the error message
to the error buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D42A</td>
				<td>20 C1 E6</td>
				<td class="fit">JSR $E6C1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D42D</td>
				<td>C6 A5</td>
				<td class="fit">DEC $A5</td><td rowspan="3"><p>Decrement CB+2 ($A5) so this pointer
points to the start of the message,
load .A with $80 (EOI out status), and
branch (always!) to GE30.</p>
</td></tr>
				<tr><td></td><td class="fit">D42F</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td></tr>
				<tr><td></td><td class="fit">D431</td>
				<td>D0 12</td>
				<td class="fit">BNE $D445</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GE10</td><td class="fit">D433</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="3"><p>JSR to GETBYT ($D137) to read a byte
of the error message. Store the b^te in
DATA ($85) and, if not $00, branch to
GE20.</p>
</td></tr>
				<tr><td></td><td class="fit">D436</td>
				<td>85 85</td>
				<td class="fit">STA $85</td></tr>
				<tr><td></td><td class="fit">D438</td>
				<td>D0 09</td>
				<td class="fit">BNE $D443</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GE15</td><td class="fit">D43A</td>
				<td>A9 D4</td>
				<td class="fit">LDA #$D4</td><td rowspan="2"><p>Load .A with $D4, the lo byte cf the
pointer to one byte below the error
buffer and JSR to SETPNT ($D4C8) to set
the pointers to the error buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D43C</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D43F</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Store the hi byte of the pointer to the
error buffer ($02) into BUFTAB+1,X
($9A,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D441</td>
				<td>95 9A</td>
				<td class="fit">STA $9A,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GE20</td><td class="fit">D443</td>
				<td>A9 88</td>
				<td class="fit">LDA #$88</td><td rowspan="1"><p>Load .A with $88, the channel status
byte for ready-to-talk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GE30</td><td class="fit">D445</td>
				<td>85 F7</td>
				<td class="fit">STA $F7</td><td rowspan="1"><p>Store the value in .A as the error
channel status in CHNRDY+ERRCHN ($F7).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D447</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="2"><p>Load .A with the byte from DATA ($85)
and store it as the channel data byte
for the error channel in CHNDAT+ERRCHN
($0243) .</p>
</td></tr>
				<tr><td></td><td class="fit">D449</td>
				<td>8D 43 02</td>
				<td class="fit">STA $0243</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D44C</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTBUF</td><td class="fit">D44D</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="3"><p>Read in the next block of a file by
following the track and sector link.
Set an EOF (end of file) indicator if
the track link (first byte) is $00.
JSR to GETACT ($DF93) to get the active
buffer number (in .A). Multiply the
buffer number by 2 (ASL) and transfer it
to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D450</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D451</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D452</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store a $00 in BUFTAB,X ($99, X) to set
the buffer pointer to the first byte.</p>
</td></tr>
				<tr><td></td><td class="fit">D454</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D456</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="2"><p>Check first byte (track link) in the
buffer, (BUFTAB,X). If it is zero, there
are no more blocks to get so branch to
NXTB1.</p>
</td></tr>
				<tr><td></td><td class="fit">D458</td>
				<td>F0 05</td>
				<td class="fit">BEQ $D45F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D45A</td>
				<td>D6 99</td>
				<td class="fit">DEC $99,X</td><td rowspan="2"><p>Decrement the buffer pointer, BUFTAB,X
($99, X) by 1 so it is $FF and JSR to
RDBYT ($D156). This forces a read of the
next sector because we set the pointer
to the end of the current buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D45C</td>
				<td>4C 56 D1</td>
				<td class="fit">JMP $D156</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTB1</td><td class="fit">D45F</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Direct block read</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DRTRD</td><td class="fit">D460</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80, the job code for read
and branch to DRT.</p>
</td></tr>
				<tr><td></td><td class="fit">D462</td>
				<td>D0 02</td>
				<td class="fit">BNE $D466</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Direct block write</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DRTWRT</td><td class="fit">D464</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="1"><p>Load .A with $90, the job code for write</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DRT</td><td class="fit">D466</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td><td rowspan="2"><p>OR the job code in .A with the current
drive number in DRVNUM ($7F) and store
the result in CMD ($024D) .</p>
</td></tr>
				<tr><td></td><td class="fit">D468</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D46B</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="2"><p>Load .A with the number of the buffer
to use for the job from JOBNUM ($F9) and
JSR to SETH ($D6D3) to set up the header
image for the job.</p>
</td></tr>
				<tr><td></td><td class="fit">D46D</td>
				<td>20 D3 D6</td>
				<td class="fit">JSR $D6D3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D470</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="2"><p>Load .X with the number of the buffer
to use for the job from JOBNUM ($F9) and
JMP to DOIT2 ($D593) to do the job.</p>
</td></tr>
				<tr><td></td><td class="fit">D472</td>
				<td>4C 93 D5</td>
				<td class="fit">JMP $D593</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open internal read channel: (SA=17)</h1>
<p>Use this entry point for PRG files.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPNIRD</td><td class="fit">D475</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="1"><p>Load .A with $01 (program file type)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open internal read channel (.A=any type)</h1>
<p>Use this entry point for any file type.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPNTYP</td><td class="fit">D477</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td><td rowspan="1"><p>Store file type (.A) into TYPE ($024A)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D47A</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="2"><p>Store $11 (#17) as the current secondary
address in SA ($83) .</p>
</td></tr>
				<tr><td></td><td class="fit">D47C</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D47E</td>
				<td>20 46 DC</td>
				<td class="fit">JSR $DC46</td><td rowspan="1"><p>JSR to OPNRCH ($DC46) to open a read
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D481</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Set .A to $02 and JMP to SETPNT ($D4C8)
to set the buffer pointer to point past
the track and sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">D483</td>
				<td>4C C8 D4</td>
				<td class="fit">JMP $D4C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open internal write channel (SA=18)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPNIWR</td><td class="fit">D486</td>
				<td>A9 12</td>
				<td class="fit">LDA #$12</td><td rowspan="2"><p>Store $12 (#18) as the current secondary
address in SA ($83) .</p>
</td></tr>
				<tr><td></td><td class="fit">D488</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D48A</td>
				<td>4C DA DC</td>
				<td class="fit">JMP $DCDA</td><td rowspan="1"><p>JMP to OPNWCH ($DCDA) to open the write
channel .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Allocate the next directory block</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXDRBK</td><td class="fit">D48D</td>
				<td>20 3B DE</td>
				<td class="fit">JSR $DE3B</td><td rowspan="1"><p>JSR to CURBLK ($DE3B) set the TRACK ($80)
and SECTOR ($81) values from the current
header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D490</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="4"><p>Set TEMP ($6F) to $01 and save the
current value of SECINC ($69). the
sector increment used for sequential
files, on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D492</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">D494</td>
				<td>A5 69</td>
				<td class="fit">LDA $69</td></tr>
				<tr><td></td><td class="fit">D496</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D497</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td><td rowspan="2"><p>Set the sector increment, SECINC ($69)
to $03, the increment used for the
directory track.</p>
</td></tr>
				<tr><td></td><td class="fit">D499</td>
				<td>85 69</td>
				<td class="fit">STA $69</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D49B</td>
				<td>20 2D F1</td>
				<td class="fit">JSR $F12D</td><td rowspan="1"><p>JSF to NXTDS ($F12D) to determine the
next available track and sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D49E</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Restore the original sector increment
in SECINC ($69) from the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D49F</td>
				<td>85 69</td>
				<td class="fit">STA $69</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4A1</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set .A to $00 and JSR to SETPNT ($D4C8)
to set the pointer to the first byte in
the active buffer (track byte) .</p>
</td></tr>
				<tr><td></td><td class="fit">D4A3</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4A6</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A with the next track from TRACK
($80) and JSR to PUTBYT ($CFF1) to
store the track link in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D4A8</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4AB</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Load .A with the next sector from SECTOR
($81) and JSR to PUTBYT ($CFF1) to
store the sector link in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D4AD</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4B0</td>
				<td>20 C7 D0</td>
				<td class="fit">JSR $D0C7</td><td rowspan="1"><p>JSR to WRTBUF ($D0C7) to write the
buffer out to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4B3</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait until the
write job is complete.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4B6</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set .A to $00 and JSR to SETPNT ($D4C8)
to set the pointer to the first byte in
the active buffer (track byte) .</p>
</td></tr>
				<tr><td></td><td class="fit">D4B8</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXDB1</td><td class="fit">D4BB</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td><td rowspan="2"><p>Loop to zero the entire buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D4BE</td>
				<td>D0 FB</td>
				<td class="fit">BNE $D4BB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4C0</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td><td rowspan="1"><p>JSR to PUTBYT ($CFF1) to store $00 as
the next track link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4C3</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Load .A with $FF and JMP to PUTBYT
($CFF1) to store $FF as the sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">D4C5</td>
				<td>4C F1 CF</td>
				<td class="fit">JMP $CFF1</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up pointer into active data buffer</h1>
<p>On entry: .A contains new pointer value</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETPNT</td><td class="fit">D4C8</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td><td rowspan="2"><p>Save the new pointer (in .A) into TEMP
($6F) and JSR to GETACT ($DF93) to find
the active buffer number (in .A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D4CA</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4CD</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by 2 (ASL)
and transfer the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D4CE</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4CF</td>
				<td>B5 9A</td>
				<td class="fit">LDA $9A,X</td><td rowspan="2"><p>Move the high byte of the buffer pointer
from BUFTAB+1,X ($9A,X) to DIRBUF+1 ($95)</p>
</td></tr>
				<tr><td></td><td class="fit">D4D1</td>
				<td>85 95</td>
				<td class="fit">STA $95</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4D3</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="3"><p>Load the new buffer pointer value from
TEMP ($6F) into .A. Store this new value
into BUFTAB,X ($99, X) and DIRBUF ($94).</p>
</td></tr>
				<tr><td></td><td class="fit">D4D5</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
				<tr><td></td><td class="fit">D4D7</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4D9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Free both internal channels: (SA=17&amp;18)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREICH</td><td class="fit">D4DA</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="3"><p>Set SA ($83) to $11 (#17) the internal
read channel and JSR to FRECHN ($D227)
to free the internal read channel.</p>
</td></tr>
				<tr><td></td><td class="fit">D4DC</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
				<tr><td></td><td class="fit">D4DE</td>
				<td>20 27 D2</td>
				<td class="fit">JSR $D227</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4E1</td>
				<td>A9 12</td>
				<td class="fit">LDA #$12</td><td rowspan="3"><p>Set SA ($83) to $12 (#18) the internal
write channel and JMP to FRECHN ($D227)
to free the internal write channel.</p>
</td></tr>
				<tr><td></td><td class="fit">D4E3</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
				<tr><td></td><td class="fit">D4E5</td>
				<td>4C 27 D2</td>
				<td class="fit">JMP $D227</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get the active buffer pointer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETPNT</td><td class="fit">D4E8</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETDIR</td><td class="fit">D4EB</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by two (ASL)
and transfer the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D4EC</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4ED</td>
				<td>B5 9A</td>
				<td class="fit">LDA $9A,X</td><td rowspan="2"><p>Move the hi byte of the buffer pointer
from BUFTAB+1,X ($9A,X) into the hi
byte of the directory buffer pointer
DIRBUF + 1 ($95) .</p>
</td></tr>
				<tr><td></td><td class="fit">D4EF</td>
				<td>85 95</td>
				<td class="fit">STA $95</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4F1</td>
				<td>B5 99</td>
				<td class="fit">LDA $99,X</td><td rowspan="2"><p>Move the lo byte of the buffer pointer
from BUFTAB,X ($99, X) into the lo byte
of the directory buffer pointer DIRBUF
($94). (.A = lo byte of the pointer)</p>
</td></tr>
				<tr><td></td><td class="fit">D4F3</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4F5</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Direct read of a byte: (.A = position)</h1>
<p>On entry: .A = position of byte in buffer</p>
<p>On exit: .A = data byte desired</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DRDBYT</td><td class="fit">D4F6</td>
				<td>85 71</td>
				<td class="fit">STA $71</td><td rowspan="1"><p>Store lo byte of pointer to desired byte
(in .A) into TEMP+2 ($71).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4F8</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D4FB</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="3"><p>Transfer buffer number into .X and load
.A with the hi byte of the active buffer
pointer from BUFIND,X ($FEE0,X). Store
this value into TEMP+3 ($72). This
creates a pointer to the byte in $71/72.</p>
</td></tr>
				<tr><td></td><td class="fit">D4FC</td>
				<td>BD E0 FE</td>
				<td class="fit">LDA $FEE0,X</td></tr>
				<tr><td></td><td class="fit">D4FF</td>
				<td>85 72</td>
				<td class="fit">STA $72</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D501</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Zero .Y and load .A with the desired
byte from (TEMP+2), Y; ($71), Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D503</td>
				<td>B1 71</td>
				<td class="fit">LDA ($71),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D505</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up job using last job's drive</h1>
<pre><code>Note: For this entry, job code is in CMD
      and .X is buffer number (job #)</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETLJB</td><td class="fit">D506</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td><td rowspan="3"><p>Load .A with previous job number from
LSTJOB,X ($025B,X), AND the job number
with $01 to leave just the drive number
bits, and OR the result with the new
job code on CMD ($024D). The resulting
new job code is in .A.</p>
</td></tr>
				<tr><td></td><td class="fit">D509</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">D50B</td>
				<td>0D 4D 02</td>
				<td class="fit">ORA $024D</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up new job</h1>
<pre><code>Note: For this entry, job code is in .A
      and .X is buffer number (job #)</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETJOB</td><td class="fit">D50E</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="2"><p>Save new job code on the stack and store
the number of the buffer to use (.X) in
JOBNUM ($F9) .</p>
</td></tr>
				<tr><td></td><td class="fit">D50F</td>
				<td>86 F9</td>
				<td class="fit">STX $F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D511</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the buffer number from .X to
.A, multiply it by 2 (ASL) and transfer
it back into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D512</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D513</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D514</td>
				<td>B5 07</td>
				<td class="fit">LDA $07,X</td><td rowspan="2"><p>Move the desired sector from HDRS+1,X
($07, X) into CMD ($024D).</p>
</td></tr>
				<tr><td></td><td class="fit">D516</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D519</td>
				<td>B5 06</td>
				<td class="fit">LDA $06,X</td><td rowspan="2"><p>Load .A with the desired track from
HDRS,X ($06, X). If it is $00, branch to
TSERR ($D54A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D51B</td>
				<td>F0 2D</td>
				<td class="fit">BEQ $D54A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D51D</td>
				<td>CD D7 FE</td>
				<td class="fit">CMP $FED7</td><td rowspan="2"><p>Compare the desired track (in .A) with
the maximum track number from MAXTRK
($FED7). If it is too large, branch to
TSERR ($D54A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D520</td>
				<td>B0 28</td>
				<td class="fit">BCS $D54A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D522</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the desired track number from
.A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D523</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the job code off the stack and
immediately push it back onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D524</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D525</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td><td rowspan="3"><p>AND the job code in .A with $F0 to mask
off the drive bits and compare it to $90
(the job code for a write). If this is
not a write job, branch to SJB1.</p>
</td></tr>
				<tr><td></td><td class="fit">D527</td>
				<td>C9 90</td>
				<td class="fit">CMP #$90</td></tr>
				<tr><td></td><td class="fit">D529</td>
				<td>D0 4F</td>
				<td class="fit">BNE $D57A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D52B</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the job code off the stack and
immediately push it back onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D52C</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D52D</td>
				<td>4A</td>
				<td class="fit">LSR</td><td rowspan="2"><p>Do an LSR on the job code in .A to
find the drive to use. If it is drive 1,
branch to SJB2.</p>
</td></tr>
				<tr><td></td><td class="fit">D52E</td>
				<td>B0 05</td>
				<td class="fit">BCS $D535</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D530</td>
				<td>AD 01 01</td>
				<td class="fit">LDA $0101</td><td rowspan="2"><p>Use drive so load DOS version from
DSKVER ($0101) and branch to S JB3 .</p>
</td></tr>
				<tr><td></td><td class="fit">D533</td>
				<td>90 03</td>
				<td class="fit">BCC $D538</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SJB2</td><td class="fit">D535</td>
				<td>AD 02 01</td>
				<td class="fit">LDA $0102</td><td rowspan="1"><p>Use drive 1 so load DOS version from
DSKVER+1 ($0102) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SJB3</td><td class="fit">D538</td>
				<td>F0 05</td>
				<td class="fit">BEQ $D53F</td><td rowspan="1"><p>If DOS version is $00 (no number). it is
OK, so branch to SJB4.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: On the 1541 the DOS version code
      (normally 65) is stored in ROM,
      not in RAM as on the 4040. This
      means you can not soft set a
      DOS version number on the 1541!
      However, a DOS version number of
      $00 is OK.</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D53A</td>
				<td>CD D5 FE</td>
				<td class="fit">CMP $FED5</td><td rowspan="2"><p>Compare the DOS version number with the
1541 DOS version number ($65) from
VERNUM ($FED5). If the version numbers
do not match, branch to VNERR ($D572).</p>
</td></tr>
				<tr><td></td><td class="fit">D53D</td>
				<td>D0 33</td>
				<td class="fit">BNE $D572</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SJB4</td><td class="fit">D53F</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="5"><p>Transfer the desired track number from
.X to .A and JSR to MAXSEX ($F24B) to
calculate the maximum sector number+1
for this track (returned in .A). Compare
this value with the desired sector
number in CMD. If the desired sector
number is legal, branch to SJB1 .</p>
</td></tr>
				<tr><td></td><td class="fit">D540</td>
				<td>20 4B F2</td>
				<td class="fit">JSR $F24B</td></tr>
				<tr><td></td><td class="fit">D543</td>
				<td>CD 4D 02</td>
				<td class="fit">CMP $024D</td></tr>
				<tr><td></td><td class="fit">D546</td>
				<td>F0 02</td>
				<td class="fit">BEQ $D54A</td></tr>
				<tr><td></td><td class="fit">D548</td>
				<td>B0 30</td>
				<td class="fit">BCS $D57A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSERR</td><td class="fit">D54A</td>
				<td>20 52 D5</td>
				<td class="fit">JSR $D552</td><td rowspan="1"><p>Track and/or sector number is illegal so
JSR to HED2TS ($D552) to store the
values in TRACK ($80) and SECTOR ($81) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSER1</td><td class="fit">D54D</td>
				<td>A9 66</td>
				<td class="fit">LDA #$66</td><td rowspan="2"><p>Load .A with $66 to indicate a bad track
and sector and JMP to CMDER2 ($E645).</p>
</td></tr>
				<tr><td></td><td class="fit">D54F</td>
				<td>4C 45 E6</td>
				<td class="fit">JMP $E645</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HED2TS</td><td class="fit">D552</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="3"><p>Set desired track and sector values:
Load .A with the number of the buffer to
use for this job from JOBNUM ($F9).
Multiply the buffer number by 2 (ASL)
and transfer it to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D554</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D555</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D556</td>
				<td>B5 06</td>
				<td class="fit">LDA $06,X</td><td rowspan="2"><p>Move the desired track number from
HDRS,X ($06, X) to TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">D558</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D55A</td>
				<td>B5 07</td>
				<td class="fit">LDA $07,X</td><td rowspan="2"><p>Move the desired sector number from
HDRS+1,X ($07, X) to SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">D55C</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D55E</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSCHK</td><td class="fit">D55F</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Check for bad track and sector values:
Load .A from TRACK ($80). If the track
is $00, branch back to TSER1 ($D54D).</p>
</td></tr>
				<tr><td></td><td class="fit">D561</td>
				<td>F0 EA</td>
				<td class="fit">BEQ $D54D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D563</td>
				<td>CD D7 FE</td>
				<td class="fit">CMP $FED7</td><td rowspan="2"><p>Compare the track to the maximum track
number allowed, MAXTRK ($FED7). If too
large, branch back to TSER1.</p>
</td></tr>
				<tr><td></td><td class="fit">D566</td>
				<td>B0 E5</td>
				<td class="fit">BCS $D54D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D568</td>
				<td>20 4B F2</td>
				<td class="fit">JSR $F24B</td><td rowspan="4"><p>JSR to MAXSEC ($F24B) to calculate the
maximum sector number allowed on this
track. If too large, branch to TSER1.</p>
</td></tr>
				<tr><td></td><td class="fit">D56B</td>
				<td>C5 81</td>
				<td class="fit">CMP $81</td></tr>
				<tr><td></td><td class="fit">D56D</td>
				<td>F0 DE</td>
				<td class="fit">BEQ $D54D</td></tr>
				<tr><td></td><td class="fit">D56F</td>
				<td>90 DC</td>
				<td class="fit">BCC $D54D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D571</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VNERR</td><td class="fit">D572</td>
				<td>20 52 D5</td>
				<td class="fit">JSR $D552</td><td rowspan="1"><p>Bad DOS version number:
JSR to HED2TS ($D552) to store the
values in TRACK ($80) and SECTOR ($81).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D575</td>
				<td>A9 73</td>
				<td class="fit">LDA #$73</td><td rowspan="2"><p>Load .A with $73 to indicate a bad DOS
version number and JMP to CMDER2 ($E645)
to</p>
</td></tr>
				<tr><td></td><td class="fit">D577</td>
				<td>4C 45 E6</td>
				<td class="fit">JMP $E645</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Conclude job set up</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SJB1</td><td class="fit">D57A</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="1"><p>Load .X with the number of the buffer
use for the job from JOBNUM ($F9) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D57C</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the job code off the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D57D</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td><td rowspan="3"><p>Store the job code as the current
command in CMD ($024D). in the job gueue
at JOBS,X ($00, X) to activate the disk
controller, and in LSTJOB,X.</p>
</td></tr>
				<tr><td></td><td class="fit">D580</td>
				<td>95 00</td>
				<td class="fit">STA $00,X</td></tr>
				<tr><td></td><td class="fit">D582</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D585</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS,</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Do a read job; return when done OK:</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOREAD</td><td class="fit">D586</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80. the read job code and
branch to DOJOB.</p>
</td></tr>
				<tr><td></td><td class="fit">D588</td>
				<td>D0 02</td>
				<td class="fit">BNE $D58C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOWRIT</td><td class="fit">D58A</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="1"><p>Do a write job; return when done OK:
Load .A with $90. the write job cede.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOJOB</td><td class="fit">D58C</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td><td rowspan="1"><p>OR the job code with the current drive
number in DF:VNUM ($7F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D58E</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="1"><p>Load .X with the number of the buffer to
use for the job from JOBNUM ($F9) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOIT</td><td class="fit">D590</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td><td rowspan="1"><p>Store complete job code in CMD ($024D) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOIT2</td><td class="fit">D593</td>
				<td>AD 4D 02</td>
				<td class="fit">LDA $024D</td><td rowspan="1"><p>Lead .A with job code from CMD ($024D) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D596</td>
				<td>20 0E D5</td>
				<td class="fit">JSR $D50E</td><td rowspan="1"><p>JSR to SETJOB ($D50E) to start job.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h2>Wait until job is completed</h2>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WATJOB</td><td class="fit">D599</td>
				<td>20 A6 D5</td>
				<td class="fit">JSR $D5A6</td><td rowspan="1"><p>JSR to TSTJOB ($D5A6) to check if job
is done yet (error code returned in .A)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D59C</td>
				<td>B0 FB</td>
				<td class="fit">BCS $D599</td><td rowspan="1"><p>If job not done yet, branch to WATJOB.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D59E</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save error cede on the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D59F</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set job completed flag, JOBRTN ($0298),
to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">D5A1</td>
				<td>8D 98 02</td>
				<td class="fit">STA $0298</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5A4</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Recover error code from stack (in .A).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5A5</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test if job done yet</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTJOB</td><td class="fit">D5A6</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="1"><p>If not done, return. If done OK, then
return. If not OK, redo the job.
Load .A with value from the job queue,
JOBS,X ($00, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5A8</td>
				<td>30 1A</td>
				<td class="fit">BMI $D5C4</td><td rowspan="1"><p>If .A &gt; 127, job not done yet so branch
to NOTYET to exit with carry flag set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5AA</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td><td rowspan="2"><p>If .A &lt; 2, job was completed with no
errors so branch to OK to exit with the
carry flag clear.</p>
</td></tr>
				<tr><td></td><td class="fit">D5AC</td>
				<td>90 14</td>
				<td class="fit">BCC $D5C2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5AE</td>
				<td>C9 08</td>
				<td class="fit">CMP #$08</td><td rowspan="2"><p>Compare the error code to $08. If it is
$08, a fatal write protect error has
occured so branch to TJ10 and abort.</p>
</td></tr>
				<tr><td></td><td class="fit">D5B0</td>
				<td>F0 08</td>
				<td class="fit">BEQ $D5BA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5B2</td>
				<td>C9 0B</td>
				<td class="fit">CMP #$0B</td><td rowspan="2"><p>Compare the error code to $0B. If it is
$0B, a fatal ID mismatch error has
occured so branch to TJ10 and abort.</p>
</td></tr>
				<tr><td></td><td class="fit">D5B4</td>
				<td>F0 04</td>
				<td class="fit">BEQ $D5BA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5B6</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td><td rowspan="2"><p>Compare the error code to $0F. If it is
NOT $0F, a non-fatal error has occured
so branch to RECOV and try again.
NOTE: an error code of $0F means a fatal
drive-not-available error has occured.</p>
</td></tr>
				<tr><td></td><td class="fit">D5B8</td>
				<td>D0 0C</td>
				<td class="fit">BNE $D5C6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TJ10</td><td class="fit">D5BA</td>
				<td>2C 98 02</td>
				<td class="fit">BIT $0298</td><td rowspan="2"><p>Test bit 7 of the job return flag,
JOBRTN ($0298). If it is set, the disk
has been initialized and this is the
first attempt to carry out the job, so
branch to OK to return with the carry
flag clear.</p>
</td></tr>
				<tr><td></td><td class="fit">D5BD</td>
				<td>30 03</td>
				<td class="fit">BMI $D5C2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5BF</td>
				<td>4C 3F D6</td>
				<td class="fit">JMP $D63F</td><td rowspan="1"><p>JMP to QUIT2 ($D63F) to try to recover.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OK</td><td class="fit">D5C2</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Clear the carry flag and terminate the
routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D5C3</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NOTYET</td><td class="fit">D5C4</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="2"><p>Set the carry flag and terminate the
routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">D5C5</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RECOV</td><td class="fit">D5C6</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="4"><p>Save .Y value and the current drive
number from DRVNUM ($7F) on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D5C7</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">D5C8</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td></tr>
				<tr><td></td><td class="fit">D5CA</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5CB</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td><td rowspan="3"><p>Load the job code for the last job from
LSTJOB,X ($025B,X). AND it with $01 to
mask off the non-drive bits, and store
the result as the current drive number
in DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">D5CE</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">D5D0</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5D2</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="3"><p>Transfer the drive number from .A to .Y
and move the LED error mask from
LEDMSK,Y ($FECA,Y) to ERLED ($026D)</p>
</td></tr>
				<tr><td></td><td class="fit">D5D3</td>
				<td>B9 CA FE</td>
				<td class="fit">LDA $FECA,Y</td></tr>
				<tr><td></td><td class="fit">D5D6</td>
				<td>8D 6D 02</td>
				<td class="fit">STA $026D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5D9</td>
				<td>20 A6 D6</td>
				<td class="fit">JSR $D6A6</td><td rowspan="3"><p>JSR to DOREC ($D6A6) to do last job
recovery. On return, if the error code
(in .A) is $01, it worked so branch to
REC01.</p>
</td></tr>
				<tr><td></td><td class="fit">D5DC</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D5DE</td>
				<td>B0 03</td>
				<td class="fit">BCS $D5E3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5E0</td>
				<td>4C 6D D6</td>
				<td class="fit">JMP $D66D</td><td rowspan="1"><p>Retry didn't work, JMP to REC95 ($D66D)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC01</td><td class="fit">D5E3</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td><td rowspan="3"><p>Load .A with the original job code from
LSTJOB,X ($025B,X). AND it with $F0 to
mask off the drive number bits, and save
it on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D5E6</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">D5E8</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5E9</td>
				<td>C9 90</td>
				<td class="fit">CMP #$90</td><td rowspan="2"><p>Check if the job code was $90 (a write
job). If not, branch to RECO.</p>
</td></tr>
				<tr><td></td><td class="fit">D5EB</td>
				<td>D0 07</td>
				<td class="fit">BNE $D5F4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D5ED</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>This is a write job. OR the current
drive number from DRVNUM ($7F) with $B8
(the job code for a sector seek) and
store the result in LSTJOB,X ($025B,X) .
This replaces the original write job
with a seek job during recovery.</p>
</td></tr>
				<tr><td></td><td class="fit">D5EF</td>
				<td>09 B8</td>
				<td class="fit">ORA #$B8</td></tr>
				<tr><td></td><td class="fit">D5F1</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC0</td><td class="fit">D5F4</td>
				<td>24 6A</td>
				<td class="fit">BIT $6A</td><td rowspan="5"><p>See if the head is on track by checking
bit 6 of REVCNT (6A). If this bit is
set, the head is on track so branch to
REC5.
Head not on track so zero the offset
table pointer, EPTR ($0299) and the
total offset TOFF ($029A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D5F6</td>
				<td>70 39</td>
				<td class="fit">BVS $D631</td></tr>
				<tr><td></td><td class="fit">D5F8</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">D5FA</td>
				<td>8D 99 02</td>
				<td class="fit">STA $0299</td></tr>
				<tr><td></td><td class="fit">D5FD</td>
				<td>8D 9A 02</td>
				<td class="fit">STA $029A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC1</td><td class="fit">D600</td>
				<td>AC 99 02</td>
				<td class="fit">LDY $0299</td><td rowspan="2"><p>Load .Y with the offset table pointer
EPTR ($0299) and .A with the total
offset TOFF ($029A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D603</td>
				<td>AD 9A 02</td>
				<td class="fit">LDA $029A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D606</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>Set the carry flag and subtract the
offset OFFSET, Y ($FEDB) from the total
offset in .A. Store the result as the
new total offset in TOFF ($029A).</p>
</td></tr>
				<tr><td></td><td class="fit">D607</td>
				<td>F9 DB FE</td>
				<td class="fit">SBC $FEDB,Y</td></tr>
				<tr><td></td><td class="fit">D60A</td>
				<td>8D 9A 02</td>
				<td class="fit">STA $029A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D60D</td>
				<td>B9 DB FE</td>
				<td class="fit">LDA $FEDB,Y</td><td rowspan="2"><p>Load .A with the head offset from
OFFSET, Y and JSR to HEDOFF ($D676) to
move the head so it is on track.</p>
</td></tr>
				<tr><td></td><td class="fit">D610</td>
				<td>20 76 D6</td>
				<td class="fit">JSR $D676</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D613</td>
				<td>EE 99 02</td>
				<td class="fit">INC $0299</td><td rowspan="4"><p>Increment the offset table pointer and
JSR to DOREC ($D6A6) to attempt to
recover. On return, if the error code
in .A &lt; $02, the recovery worked so
branch to REC3 .</p>
</td></tr>
				<tr><td></td><td class="fit">D616</td>
				<td>20 A6 D6</td>
				<td class="fit">JSR $D6A6</td></tr>
				<tr><td></td><td class="fit">D619</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D61B</td>
				<td>90 08</td>
				<td class="fit">BCC $D625</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D61D</td>
				<td>AC 99 02</td>
				<td class="fit">LDY $0299</td><td rowspan="3"><p>That try at recovery did not work so
increment the offset table pointer by 1
and load .A with the offset from
OFFSET, Y ($FEDB,Y). If the value loaded
is not $00, branch to REC1 to try again.</p>
</td></tr>
				<tr><td></td><td class="fit">D620</td>
				<td>B9 DB FE</td>
				<td class="fit">LDA $FEDB,Y</td></tr>
				<tr><td></td><td class="fit">D623</td>
				<td>D0 DB</td>
				<td class="fit">BNE $D600</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC3</td><td class="fit">D625</td>
				<td>AD 9A 02</td>
				<td class="fit">LDA $029A</td><td rowspan="5"><p>One more try on the offset. Load .A with
the total offset from TOFF ($029A) and
JSR to HEDOFF ($D676). If no error on
return, branch to REC9.</p>
</td></tr>
				<tr><td></td><td class="fit">D628</td>
				<td>20 76 D6</td>
				<td class="fit">JSR $D676</td></tr>
				<tr><td></td><td class="fit">D62B</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td></tr>
				<tr><td></td><td class="fit">D62D</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D62F</td>
				<td>90 2B</td>
				<td class="fit">BCC $D65C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC5</td><td class="fit">D631</td>
				<td>24 6A</td>
				<td class="fit">BIT $6A</td><td rowspan="2"><p>Check bit 7 of the error recover count
REVCNT ($6A). If this bit is clear,
branch to REC7 to do a bump to track 1.</p>
</td></tr>
				<tr><td></td><td class="fit">D633</td>
				<td>10 0F</td>
				<td class="fit">BPL $D644</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">QUIT</td><td class="fit">D635</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the original job code off the
stack. If it is NOT $90 (a write job)
branch to QUIT2.</p>
</td></tr>
				<tr><td></td><td class="fit">D636</td>
				<td>C9 90</td>
				<td class="fit">CMP #$90</td></tr>
				<tr><td></td><td class="fit">D638</td>
				<td>D0 05</td>
				<td class="fit">BNE $D63F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D63A</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td><td rowspan="2"><p>For write jobs only, OR the job code in
.A with the drive number from DRVNUM
and put the result in LSTJOB,X ($025B,X)
to restore the original value.</p>
</td></tr>
				<tr><td></td><td class="fit">D63C</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">QUIT2</td><td class="fit">D63F</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="2"><p>Load .A with the error code from JOBS,X
($00,X) and abort with a JSR to ERROR
($E60A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D641</td>
				<td>20 0A E6</td>
				<td class="fit">JSR $E60A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC7</td><td class="fit">D644</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the job code off the stack (in .A).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC5</td><td class="fit">D645</td>
				<td>2C 98 02</td>
				<td class="fit">BIT $0298</td><td rowspan="3"><p>Check bit 7 of the job return flag
JOBRTN ($0298). If this bit is set,
branch to REC95 to exit with job error.
Push the job code back onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D648</td>
				<td>30 23</td>
				<td class="fit">BMI $D66D</td></tr>
				<tr><td></td><td class="fit">D64A</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D64B</td>
				<td>A9 C0</td>
				<td class="fit">LDA #$C0</td><td rowspan="3"><p>Do a bump to track 1 by loading .A with
$C0 (BUMP job code). ORing it. with the
current drive number from DRVNUM ($7F) ,
and storing the result in the job queue
at JOBS,X ($00, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D64D</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td></tr>
				<tr><td></td><td class="fit">D64F</td>
				<td>95 00</td>
				<td class="fit">STA $00,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC8</td><td class="fit">D651</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="2"><p>Wait for current job to be completed.</p>
</td></tr>
				<tr><td></td><td class="fit">D653</td>
				<td>30 FC</td>
				<td class="fit">BMI $D651</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D655</td>
				<td>20 A6 D6</td>
				<td class="fit">JSR $D6A6</td><td rowspan="3"><p>JSR to DOREC ($D6A6) to try one more
time. On return, if the error code (.A)
is not $01 (no error). give up in
disgust and branch to QUIT.</p>
</td></tr>
				<tr><td></td><td class="fit">D658</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D65A</td>
				<td>B0 D9</td>
				<td class="fit">BCS $D635</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC9</td><td class="fit">D65C</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the original job code off the stack
and compare it to $90 (the job code for
a write job). If this isn't a write job,
branch to REC9 5.</p>
</td></tr>
				<tr><td></td><td class="fit">D65D</td>
				<td>C9 90</td>
				<td class="fit">CMP #$90</td></tr>
				<tr><td></td><td class="fit">D65F</td>
				<td>D0 0C</td>
				<td class="fit">BNE $D66D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D661</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td><td rowspan="2"><p>OR the job code (in .A) with the drive
number from DRVNUM ($7F) and store the
value in LSTJOB,X.</p>
</td></tr>
				<tr><td></td><td class="fit">D663</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D666</td>
				<td>20 A6 D6</td>
				<td class="fit">JSR $D6A6</td><td rowspan="3"><p>JSR to DOREC ($D6A6) to try one last
time. On return, if the error code (.A)
is not $01 (no error). give up in
disgust and branch to QUIT2.</p>
</td></tr>
				<tr><td></td><td class="fit">D669</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D66B</td>
				<td>B0 D2</td>
				<td class="fit">BCS $D63F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REC95</td><td class="fit">D66D</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original drive number off the
stack and store it in DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">D66E</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D670</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original .Y value off the stack
and restore .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D671</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D672</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="3"><p>Load .A with the error code from JOBS,X
($00, X). clear the carry flag, and exit
with an RTS .</p>
</td></tr>
				<tr><td></td><td class="fit">D674</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">D675</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Adjust head offset</h1>
<p>On entry: .A = OFFSET</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HEDOFF</td><td class="fit">D676</td>
				<td>C9 00</td>
				<td class="fit">CMP #$00</td><td rowspan="2"><p>If .A=0, no offset required so branch
to HOF3.</p>
</td></tr>
				<tr><td></td><td class="fit">D678</td>
				<td>F0 18</td>
				<td class="fit">BEQ $D692</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D67A</td>
				<td>30 0C</td>
				<td class="fit">BMI $D688</td><td rowspan="1"><p>If .A &gt; 127, head needs to be stepped
inward so branch to HOF2.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HOF1</td><td class="fit">D67C</td>
				<td>A0 01</td>
				<td class="fit">LDY #$01</td><td rowspan="2"><p>We want to move head outward 1 track so:
load .Y with $01 and JSR to MOVHED
($D693) to move the head.</p>
</td></tr>
				<tr><td></td><td class="fit">D67E</td>
				<td>20 93 D6</td>
				<td class="fit">JSR $D693</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D681</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>On return, set the carry flag and
subtract $01 from the value in .A. If
the result is not $00, the head has not-
finished so branch back to HOF1.</p>
</td></tr>
				<tr><td></td><td class="fit">D682</td>
				<td>E9 01</td>
				<td class="fit">SBC #$01</td></tr>
				<tr><td></td><td class="fit">D684</td>
				<td>D0 F6</td>
				<td class="fit">BNE $D67C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D686</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $D692</td><td rowspan="1"><p>If the head is finished moving, branch
to HOF3.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HOF2</td><td class="fit">D688</td>
				<td>A0 FF</td>
				<td class="fit">LDY #$FF</td><td rowspan="2"><p>We want to move head inward 1 track so:
load .Y with $FF and JSR to MOVHED
($D693) to move the head.</p>
</td></tr>
				<tr><td></td><td class="fit">D68A</td>
				<td>20 93 D6</td>
				<td class="fit">JSR $D693</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D68D</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="3"><p>On return, clear the carry flag and
add $01 to the value in .A. If the
result is not $00, the head has not
finished so branch back to HOF2.</p>
</td></tr>
				<tr><td></td><td class="fit">D68E</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
				<tr><td></td><td class="fit">D690</td>
				<td>D0 F6</td>
				<td class="fit">BNE $D688</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HOF3</td><td class="fit">D692</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MCVHED</td><td class="fit">D693</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Step head inward or outward 1 track:
Save the value in .A onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D694</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer the number of steps to move
(phase) from .Y into .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D695</td>
				<td>A4 7F</td>
				<td class="fit">LDY $7F</td><td rowspan="1"><p>Load. Y with the current drive number
from DRVNUM ($7F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D697</td>
				<td>99 FE 02</td>
				<td class="fit">STA $02FE,Y</td><td rowspan="1"><p>Store the phase into PHASE, Y ($02FE,Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MH10</td><td class="fit">D69A</td>
				<td>D9 FE 02</td>
				<td class="fit">CMP $02FE,Y</td><td rowspan="2"><p>Compare the phase in .A with the value
in PHASE, Y ($02FE,Y). If they are equal,
the controller has not yet moved the
head so branch back to MH10.</p>
</td></tr>
				<tr><td></td><td class="fit">D69D</td>
				<td>F0 FB</td>
				<td class="fit">BEQ $D69A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D69F</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in PHASE, Y ($02FE,Y) so head
won't move any more.</p>
</td></tr>
				<tr><td></td><td class="fit">D6A1</td>
				<td>99 FE 02</td>
				<td class="fit">STA $02FE,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6A4</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull original value of .A off the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6A5</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOREC</td><td class="fit">D6A6</td>
				<td>A5 6A</td>
				<td class="fit">LDA $6A</td><td rowspan="3"><p>Load .A with the retry counter, REVCNT
($6A). AND it with $3F to mask off the
high order bits, and transfer the result
into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D6A8</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td></tr>
				<tr><td></td><td class="fit">D6AA</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOREC1</td><td class="fit">D6AB</td>
				<td>AD 6D 02</td>
				<td class="fit">LDA $026D</td><td rowspan="3"><p>Load .A with the error LED mask from
ERLED ($026D). EOR it with the disk
controller port B, DSKCNT ($1C00) and
store it back in DSKCNT ($1C00) to turn
the drive light OFF.</p>
</td></tr>
				<tr><td></td><td class="fit">D6AE</td>
				<td>4D 00 1C</td>
				<td class="fit">EOR $1C00</td></tr>
				<tr><td></td><td class="fit">D6B1</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6B4</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td><td rowspan="2"><p>Restart the last job by moving the job
code from LSTJOB,X ($025B,X) to the job
queue at JOBS,X ($00, X).</p>
</td></tr>
				<tr><td></td><td class="fit">D6B7</td>
				<td>95 00</td>
				<td class="fit">STA $00,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOREC2</td><td class="fit">D6B9</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="4"><p>Loop to wait until the value in the job
queue at JOBS,X ($00, X) is less than 127
(indicates job has been completed).
Test to see if the error code returned
is $01 (successful). If everything was
OK, branch to DOREC3.</p>
</td></tr>
				<tr><td></td><td class="fit">D6BB</td>
				<td>30 FC</td>
				<td class="fit">BMI $D6B9</td></tr>
				<tr><td></td><td class="fit">D6BD</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D6BF</td>
				<td>90 03</td>
				<td class="fit">BCC $D6C4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6C1</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>It didn't work. Decrement the error
counter in .Y and, if .Y has not counted
down to $00 yet, branch to DOREC1 and
keep trying.</p>
</td></tr>
				<tr><td></td><td class="fit">D6C2</td>
				<td>D0 E7</td>
				<td class="fit">BNE $D6AB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOREC3</td><td class="fit">D6C4</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save the error code onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6C5</td>
				<td>AD 6D 02</td>
				<td class="fit">LDA $026D</td><td rowspan="3"><p>Load .A with the error LED mask from
ERLED ($026D). OR it with the disk
controller port B, DSKCNT ($1C00) and
store it back in DSKCNT ($1C00) to turn
the drive light back ON.</p>
</td></tr>
				<tr><td></td><td class="fit">D6C8</td>
				<td>0D 00 1C</td>
				<td class="fit">ORA $1C00</td></tr>
				<tr><td></td><td class="fit">D6CB</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6CE</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the error code back off the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6CF</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up the header for the active buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETHDR</td><td class="fit">D6D0</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>Uses values in TRACK, SECTOR, &amp; DSKID.
JSR to GETACT ($DF93) to get the number
of the active buffer (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6D3</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the number of the active buffer
(in .A) by 2 (ASL) and transfer the
result into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D6D4</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6D5</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Move the track number from TRACK ($80)
to HDRS,Y ($0006, Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">D6D7</td>
				<td>99 06 00</td>
				<td class="fit">STA $0006,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6DA</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Move the sector number from SECTOR ($81)
to HDRS+1,Y ($0007, Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">D6DC</td>
				<td>99 07 00</td>
				<td class="fit">STA $0007,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6DF</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>Load .A with the current drive number
from DRVNUM ($7F). multiply it by 2 (ASL)
and transfer the result to .X.</p>
<pre><code>Note: this last bunch of code really
      does nothing. On the 4040 it is
      done in preparation for moving
      the ID characters. However, this
      is not done here on the 1541!</code></pre>
</td></tr>
				<tr><td></td><td class="fit">D6E1</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">D6E2</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6E3</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with  an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Add new filename to the directory</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDFIL</td><td class="fit">D6E4</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="8"><p>Save the following variables onto the
stack: SA ($83), LINDX ($82), SECTOR
($81). and TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">D6E6</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">D6E7</td>
				<td>A5 82</td>
				<td class="fit">LDA $82</td></tr>
				<tr><td></td><td class="fit">D6E9</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">D6EA</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td></tr>
				<tr><td></td><td class="fit">D6EC</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">D6ED</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">D6EF</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6F0</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="2"><p>Set the current secondary address, SA
($83) to $11 (#17), the internal read
channel .</p>
</td></tr>
				<tr><td></td><td class="fit">D6F2</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6F4</td>
				<td>20 3B DE</td>
				<td class="fit">JSR $DE3B</td><td rowspan="1"><p>JSR to CURBLK ($DE3B) to find a read
channel and set TRACK ($80) and SECTOR
($81) from the most recently read header</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6F7</td>
				<td>AD 4A 02</td>
				<td class="fit">LDA $024A</td><td rowspan="2"><p>Save the file type, TYPE ($024A) of the
file to be added onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">D6FA</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D6FB</td>
				<td>A5 E2</td>
				<td class="fit">LDA $E2</td><td rowspan="3"><p>Load .A with the drive number for the
new file, and it with $01, and store the
result as the current drive, DRVNUM($7F)</p>
</td></tr>
				<tr><td></td><td class="fit">D6FD</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">D6FF</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D701</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="2"><p>Load .X with the last job number frcm
JOBNUM ($F9) .</p>
</td></tr>
				<tr><td></td><td class="fit">D703</td>
				<td>5D 5B 02</td>
				<td class="fit">EOR $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D706</td>
				<td>4A</td>
				<td class="fit">LSR</td><td rowspan="2"><p>EOR the drive number in .A with the
last job code from LSTJOB,X ($025B,X) ,
divide the result by 2 (LSR). and check
if the carry flag is clear. If it is,
the new file uses the same drive as the
last job so there is no need to change
the drive and we can branch to AF08.</p>
</td></tr>
				<tr><td></td><td class="fit">D707</td>
				<td>90 0C</td>
				<td class="fit">BCC $D715</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D709</td>
				<td>A2 01</td>
				<td class="fit">LDX #$01</td><td rowspan="5"><p>Store $01 in DELIND ($0292) to indicate
that we are searching for a deleted
entry and JSR to SRCHST ($C5AC). On
return, if .A=0, all directory sectors
are full so branch to AF15 to start a
new sector. If .AO0, we have found a
spot to put the new entry so branch to
AF20.</p>
</td></tr>
				<tr><td></td><td class="fit">D70B</td>
				<td>8E 92 02</td>
				<td class="fit">STX $0292</td></tr>
				<tr><td></td><td class="fit">D70E</td>
				<td>20 AC C5</td>
				<td class="fit">JSR $C5AC</td></tr>
				<tr><td></td><td class="fit">D711</td>
				<td>F0 1D</td>
				<td class="fit">BEQ $D730</td></tr>
				<tr><td></td><td class="fit">D713</td>
				<td>D0 28</td>
				<td class="fit">BNE $D73D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AF08</td><td class="fit">D715</td>
				<td>AD 91 02</td>
				<td class="fit">LDA $0291</td><td rowspan="2"><p>Since we have used this drive before,
some of the directory information is
in memory. Check if DELSEC ($0291)
is $00. If it is, we didn't locate a
deleted entry the last time we read in
the directory so branch to AF10.</p>
</td></tr>
				<tr><td></td><td class="fit">D718</td>
				<td>F0 0C</td>
				<td class="fit">BEQ $D726</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D71A</td>
				<td>C5 81</td>
				<td class="fit">CMP $81</td><td rowspan="2"><p>Since DELSEC is not $00, it is the
number of the sector containing the
first available directory entry. See if
this sector is currently in memory by
comparing this sector number with the
one in SECTOR ($81). If they are equal,
the sector is in memory so branch to
AF20.</p>
</td></tr>
				<tr><td></td><td class="fit">D71C</td>
				<td>F0 1F</td>
				<td class="fit">BEQ $D73D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D71E</td>
				<td>85 81</td>
				<td class="fit">STA $81</td><td rowspan="3"><p>Since the desired sector is not in
memory, set SECTOR ($81) to the desired
sector number and JSR to DRTRD ($D460)
to read in the sector. Now branch to
AF20.</p>
</td></tr>
				<tr><td></td><td class="fit">D720</td>
				<td>20 60 D4</td>
				<td class="fit">JSR $D460</td></tr>
				<tr><td></td><td class="fit">D723</td>
				<td>4C 3D D7</td>
				<td class="fit">JMP $D73D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AF10</td><td class="fit">D726</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Store $01 in DELIND ($0292) to indicate
that we are looking for a deleted entry
and JSR to SEARCH ($C617) to find the
first deleted or empty directory entry.</p>
</td></tr>
				<tr><td></td><td class="fit">D728</td>
				<td>8D 92 02</td>
				<td class="fit">STA $0292</td></tr>
				<tr><td></td><td class="fit">D72B</td>
				<td>20 17 C6</td>
				<td class="fit">JSR $C617</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D72E</td>
				<td>D0 0D</td>
				<td class="fit">BNE $D73D</td><td rowspan="1"><p>On return, if .A is not equal to $00, a
deleted or empty entry was found so
branch to AF20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AF15</td><td class="fit">D730</td>
				<td>20 8D D4</td>
				<td class="fit">JSR $D48D</td><td rowspan="1"><p>No empty entries so we have to start a
new sector so JSR to NXDRBK ($D48D) to
find us the next available sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D733</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="4"><p>Move the new sector number from SECTOR
($81) to DELSEC ($0291) and set DELIND
($0292) to $02.</p>
</td></tr>
				<tr><td></td><td class="fit">D735</td>
				<td>8D 91 02</td>
				<td class="fit">STA $0291</td></tr>
				<tr><td></td><td class="fit">D738</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td></tr>
				<tr><td></td><td class="fit">D73A</td>
				<td>8D 92 02</td>
				<td class="fit">STA $0292</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AF20</td><td class="fit">D73D</td>
				<td>AD 92 02</td>
				<td class="fit">LDA $0292</td><td rowspan="2"><p>Load .A with the pointer that points to
first character in the directory entry,
DELIND($0292). and JSR to SETPNT ( $D4C8 )
to set the pointers to this entry.</p>
</td></tr>
				<tr><td></td><td class="fit">D740</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D743</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the file type off the stack and
store it back in TYPE ($024A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D744</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D747</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td><td rowspan="2"><p>Compare the file type to $04 (REL type) .
If this is not a relative file, branch
to AF25.</p>
</td></tr>
				<tr><td></td><td class="fit">D749</td>
				<td>D0 02</td>
				<td class="fit">BNE $D74D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D74B</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td><td rowspan="1"><p>Since it is a REL file, OR the file type
(in .A) with $80 to set bit 7.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AF25</td><td class="fit">D74D</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td><td rowspan="1"><p>JSR to PUTBYT ($CFF1) to store the file
type (in .A) into the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D750</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the file's track link off the
stack, store it in FILTRK ($0280). and
JSR to PUTBYT ($CFF1) to store the
track link in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D751</td>
				<td>8D 80 02</td>
				<td class="fit">STA $0280</td></tr>
				<tr><td></td><td class="fit">D754</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D757</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the file's sector link off the
stack, store it in FILSEC ($0285). and
JSR to PUT3YT ($CFF1) to store the
sector link in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D758</td>
				<td>8D 85 02</td>
				<td class="fit">STA $0285</td></tr>
				<tr><td></td><td class="fit">D75B</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D75E</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="2"><p>JSR to GETACT ($DF93) to get the active
buffer number (in .A) and transfer the
value to .Y</p>
</td></tr>
				<tr><td></td><td class="fit">D761</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D762</td>
				<td>AD 7A 02</td>
				<td class="fit">LDA $027A</td><td rowspan="2"><p>Load .X with the file table pointer
from FILTAB ($027A) .</p>
</td></tr>
				<tr><td></td><td class="fit">D765</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D766</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td><td rowspan="3"><p>Load .A with $10 (#16) and JSR to TRNAME
($C66E) to transfer the file name to
the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">D768</td>
				<td>20 6E C6</td>
				<td class="fit">JSR $C66E</td></tr>
				<tr><td></td><td class="fit">D76B</td>
				<td>A0 10</td>
				<td class="fit">LDY #$10</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D76D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="5"><p>Loop to fill directory entry with $00' s
from (DIRBUF),16 to (DIRBUF),27.</p>
</td></tr>
				<tr><td></td><td class="fit">D76F</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">D771</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">D772</td>
				<td>C0 1B</td>
				<td class="fit">CPY #$1B</td></tr>
				<tr><td></td><td class="fit">D774</td>
				<td>90 F9</td>
				<td class="fit">BCC $D76F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D776</td>
				<td>AD 4A 02</td>
				<td class="fit">LDA $024A</td><td rowspan="3"><p>Check the value in TYPE ($024A) to see
if this is a relative file. If not,
branch to AF50.</p>
</td></tr>
				<tr><td></td><td class="fit">D779</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td></tr>
				<tr><td></td><td class="fit">D77B</td>
				<td>D0 13</td>
				<td class="fit">BNE $D790</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D77D</td>
				<td>A0 10</td>
				<td class="fit">LDY #$10</td><td rowspan="1"><p>For REL files only: Load .Y with $10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D77F</td>
				<td>AD 59 02</td>
				<td class="fit">LDA $0259</td><td rowspan="3"><p>Move the side-sector track number from
TRKSS ($0259) to (DIRBUF),Y. Increment Y</p>
</td></tr>
				<tr><td></td><td class="fit">D782</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">D784</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D785</td>
				<td>AD 5A 02</td>
				<td class="fit">LDA $025A</td><td rowspan="3"><p>Move the side-sector sector number from
SECSS ($025A) to (DIRBUF) ,Y. Increment Y</p>
</td></tr>
				<tr><td></td><td class="fit">D788</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">D78A</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D78B</td>
				<td>AD 58 02</td>
				<td class="fit">LDA $0258</td><td rowspan="2"><p>Move the record length from REC ($0258)
to (DIRBUF) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D78E</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AF50</td><td class="fit">D790</td>
				<td>20 64 D4</td>
				<td class="fit">JSR $D464</td><td rowspan="1"><p>JSR to DRTWRT ($D464) to write out the
directory sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D793</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the original value of LINDX off the
stack, store it back in LINDX ($82). and
transfer the value into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">D794</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
				<tr><td></td><td class="fit">D796</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D797</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original value of SA off the
stack, store it back in SA ($83) .</p>
</td></tr>
				<tr><td></td><td class="fit">D798</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D79A</td>
				<td>AD 91 02</td>
				<td class="fit">LDA $0291</td><td rowspan="4"><p>Load .A with the number of the directory
sector containing the new entry from
DELSEC ($0291) and store it in ENTSEC
($D8) and in DSEC,X ($0260, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D79D</td>
				<td>85 D8</td>
				<td class="fit">STA $D8</td></tr>
				<tr><td></td><td class="fit">D79F</td>
				<td>9D 60 02</td>
				<td class="fit">STA $0260,X</td></tr>
				<tr><td></td><td class="fit">D7A2</td>
				<td>AD 92 02</td>
				<td class="fit">LDA $0292</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7A5</td>
				<td>85 DD</td>
				<td class="fit">STA $DD</td><td rowspan="2"><p>Load .A with the pointer to the start
of the new entry from DELIND ($0292)
and store it in DIND,X ($0266, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D7A7</td>
				<td>9D 66 02</td>
				<td class="fit">STA $0266,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7AA</td>
				<td>AD 4A 02</td>
				<td class="fit">LDA $024A</td><td rowspan="2"><p>Load .A with the file type of the new
entry from TYPE ($024A) and store it in
PATTYP ($E7) .</p>
</td></tr>
				<tr><td></td><td class="fit">D7AD</td>
				<td>85 E7</td>
				<td class="fit">STA $E7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7AF</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Load .A with the curre nt drive number
from DRVNUM ($7F) and  store it in
FILDRV ($E2) .</p>
</td></tr>
				<tr><td></td><td class="fit">D7B1</td>
				<td>85 E2</td>
				<td class="fit">STA $E2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7B3</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open a channel from serial bus</h1>
<p>The open, load, or save command is
parsed. A channel is allocated and the
directory is searched for the filename
specified in the command.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPEN</td><td class="fit">D7B4</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="2"><p>Move the current secondary address from
SA ($83) to TEMPSA ($024C).</p>
</td></tr>
				<tr><td></td><td class="fit">D7B6</td>
				<td>8D 4C 02</td>
				<td class="fit">STA $024C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7B9</td>
				<td>20 B3 C2</td>
				<td class="fit">JSR $C2B3</td><td rowspan="1"><p>JSR to CMDSET ($C2B3) to set the command
string pointers. On return, store the .X
value in CMDNUM ($022A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7BC</td>
				<td>8E 2A 02</td>
				<td class="fit">STX $022A</td><td rowspan="4"><p>Load .X with the first character in the
command string CMDBUF ($0200). Load .A
with the secondary address from TEMPSA
($024C). If the secondary address is not
$00, this is not a load so branch to
OP021.</p>
</td></tr>
				<tr><td></td><td class="fit">D7BF</td>
				<td>AE 00 02</td>
				<td class="fit">LDX $0200</td></tr>
				<tr><td></td><td class="fit">D7C2</td>
				<td>AD 4C 02</td>
				<td class="fit">LDA $024C</td></tr>
				<tr><td></td><td class="fit">D7C5</td>
				<td>D0 2C</td>
				<td class="fit">BNE $D7F3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7C7</td>
				<td>E0 2A</td>
				<td class="fit">CPX #$2A</td><td rowspan="2"><p>Compare the value in .X with $2A (&quot;*&quot;)
to check if the command is &quot;load the
last referenced program&quot;. If not $2A,
branch to OP021.</p>
</td></tr>
				<tr><td></td><td class="fit">D7C9</td>
				<td>D0 28</td>
				<td class="fit">BNE $D7F3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7CB</td>
				<td>A5 7E</td>
				<td class="fit">LDA $7E</td><td rowspan="2"><p>Appears to be &quot;load last&quot;. Check by
loading .A with the last program's track
link from PRGTRK ($7E). If .A=0, there
is no last program so branch to OP0415
to initialize drive 0.</p>
</td></tr>
				<tr><td></td><td class="fit">D7CD</td>
				<td>F0 4D</td>
				<td class="fit">BEQ $D81C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP02</td><td class="fit">D7CF</td>
				<td>85 80</td>
				<td class="fit">STA $80</td><td rowspan="1"><p>Seems OK, let's load last program.
Store the program's track link (in .A)
into TRACK ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7D1</td>
				<td>AD 6E 02</td>
				<td class="fit">LDA $026E</td><td rowspan="3"><p>Move the program's drive number from
PRGDRV ($026E) to DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">D7D4</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
				<tr><td></td><td class="fit">D7D6</td>
				<td>85 E2</td>
				<td class="fit">STA $E2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7D8</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Store $82 (program) as the file type in
PATTYP ($E7) .</p>
</td></tr>
				<tr><td></td><td class="fit">D7DA</td>
				<td>85 E7</td>
				<td class="fit">STA $E7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7DC</td>
				<td>AD 6F 02</td>
				<td class="fit">LDA $026F</td><td rowspan="2"><p>Move the program's sector link from
PRGSEC ($026F) into SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">D7DF</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7E1</td>
				<td>20 00 C1</td>
				<td class="fit">JSR $C100</td><td rowspan="1"><p>JSR to SETLDS ($C100) to turn on the
drive active LED.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7E4</td>
				<td>20 46 DC</td>
				<td class="fit">JSR $DC46</td><td rowspan="1"><p>JSR to OPNRCH ($DC46) to open a read
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7E7</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>Load .A with $04 (2 * program type). OR
it with the drive number in DRVNUM ($7F)</p>
</td></tr>
				<tr><td></td><td class="fit">D7E9</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ENDRD</td><td class="fit">D7EB</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the number of the active
buffer from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7ED</td>
				<td>99 EC 00</td>
				<td class="fit">STA $00EC,Y</td><td rowspan="1"><p>Store the value in .A as the file type
in FILTYP,Y ($00EC,Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7F0</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate routine with a JMP to ENDCMD
($C194) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP021</td><td class="fit">D7F3</td>
				<td>E0 24</td>
				<td class="fit">CPX #$24</td><td rowspan="2"><p>Compare the byte in .X (the first in the
command  string) with $24 (&quot;$&quot;) to check
if we a re to load the directory. If it
is NOT   &quot;$&quot;,branch to OP041.</p>
</td></tr>
				<tr><td></td><td class="fit">D7F5</td>
				<td>D0 1E</td>
				<td class="fit">BNE $D815</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7F7</td>
				<td>AD 4C 02</td>
				<td class="fit">LDA $024C</td><td rowspan="2"><p>We want the directory. But, should we
load it or just open it as a SEQ file?
Check the secondary address in TEMPSA
(024C). If it is not $00, branch to
OP04 to open it as a SEQ file.</p>
</td></tr>
				<tr><td></td><td class="fit">D7FA</td>
				<td>D0 03</td>
				<td class="fit">BNE $D7FF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D7FC</td>
				<td>4C 55 DA</td>
				<td class="fit">JMP $DA55</td><td rowspan="1"><p>JMP to  LOADIR ($DA55) to load the
directory</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP04</td><td class="fit">D7FF</td>
				<td>20 D1 C1</td>
				<td class="fit">JSR $C1D1</td><td rowspan="1"><p>Open the directory as a SEQ file.
JSR to SIMPRS ($C1D1) to parse the
command string.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D802</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="2"><p>Move the directory's track link from
DIRTRK ($FE85) into TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">D805</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D807</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero the desired sector, SECTOR ($81)</p>
</td></tr>
				<tr><td></td><td class="fit">D809</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D80B</td>
				<td>20 46 DC</td>
				<td class="fit">JSR $DC46</td><td rowspan="1"><p>JSR to OPNRCH ($DC46) to open the read
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D80E</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Load .A with the current drive number
from DRVNUM ($7F) and OR it with $02
(2 * the SEQ file type) .</p>
</td></tr>
				<tr><td></td><td class="fit">D810</td>
				<td>09 02</td>
				<td class="fit">ORA #$02</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D812</td>
				<td>4C EB D7</td>
				<td class="fit">JMP $D7EB</td><td rowspan="1"><p>Terminate routine with a JMP to ENDRD
($D7EB) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP041</td><td class="fit">D815</td>
				<td>E0 23</td>
				<td class="fit">CPX #$23</td><td rowspan="2"><p>Compare the byte in .X (the first in the
command string) with $23 (&quot;#&quot;) to check
if this is to be a direct access channel
If it is NOT &quot;#&quot;, branch to OP042.</p>
</td></tr>
				<tr><td></td><td class="fit">D817</td>
				<td>D0 12</td>
				<td class="fit">BNE $D82B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D819</td>
				<td>4C 84 CB</td>
				<td class="fit">JMP $CB84</td><td rowspan="1"><p>Continue routine with a JMP to OPNBLK
($CB84) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP0415</td><td class="fit">D81C</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Set the file type flag TYPFLG ($0296)
to $02 (program file) .</p>
</td></tr>
				<tr><td></td><td class="fit">D81E</td>
				<td>8D 96 02</td>
				<td class="fit">STA $0296</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D821</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Zero the current drive number DRVNUM
($7F) and the last job drive number
LSTDRV ($028E) .</p>
</td></tr>
				<tr><td></td><td class="fit">D823</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
				<tr><td></td><td class="fit">D825</td>
				<td>8D 8E 02</td>
				<td class="fit">STA $028E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D828</td>
				<td>20 42 D0</td>
				<td class="fit">JSR $D042</td><td rowspan="1"><p>JSR to INITDR ($D042) to initialize
drive #0.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP042</td><td class="fit">D82B</td>
				<td>20 E5 C1</td>
				<td class="fit">JSR $C1E5</td><td rowspan="1"><p>JSR to PRSCLN ($C1E5) to parse the
command string to find the colon.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D82E</td>
				<td>D0 04</td>
				<td class="fit">BNE $D834</td><td rowspan="1"><p>If none found, branch to OP049</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D830</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="2"><p>Zero .X and branch to OP20 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">D832</td>
				<td>F0 0C</td>
				<td class="fit">BEQ $D840</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP049</td><td class="fit">D834</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer the byte in .X to .A. If the
byte is $00. branch to OP10.</p>
</td></tr>
				<tr><td></td><td class="fit">D835</td>
				<td>F0 05</td>
				<td class="fit">BEQ $D83C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP05</td><td class="fit">D837</td>
				<td>A9 30</td>
				<td class="fit">LDA #$30</td><td rowspan="2"><p>Oops, trouble! Load .A with $30 to
indicate a BAD SYNTAX error and JMP to
CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">D839</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP10</td><td class="fit">D83C</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement .Y so it points to the &quot; : &quot;
If .Y=0, first character is a &quot; : &quot; so
branch to OP20.</p>
</td></tr>
				<tr><td></td><td class="fit">D83D</td>
				<td>F0 01</td>
				<td class="fit">BEQ $D840</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D83F</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="1"><p>Decrement .Y so it points to the byte
just before the &quot; : &quot; .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP20</td><td class="fit">D840</td>
				<td>8C 7A 02</td>
				<td class="fit">STY $027A</td><td rowspan="1"><p>Store the pointer to the file name
(in .Y) into FILTBL ($027A).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D843</td>
				<td>A9 8D</td>
				<td class="fit">LDA #$8D</td><td rowspan="2"><p>Load .A with $8D (shifted return) and
JSR to PARSE ($C268) to parse the rest
of the command string.</p>
</td></tr>
				<tr><td></td><td class="fit">D845</td>
				<td>20 68 C2</td>
				<td class="fit">JSR $C268</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D848</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment .X (file count) and store the
result into F2CNT ($0278) .</p>
</td></tr>
				<tr><td></td><td class="fit">D849</td>
				<td>8E 78 02</td>
				<td class="fit">STX $0278</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D84C</td>
				<td>20 12 C3</td>
				<td class="fit">JSR $C312</td><td rowspan="1"><p>JSR to ONEDRV ($C312) to set up one
drive and the necessary pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D84F</td>
				<td>20 CA C3</td>
				<td class="fit">JSR $C3CA</td><td rowspan="1"><p>JSR to OPTSCH ($C3CA) to&quot; determine the
optimal search pattern,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D852</td>
				<td>20 9D C4</td>
				<td class="fit">JSR $C49D</td><td rowspan="2"><p>JSR to FFST ($C49D) to search the disk
directory for the file entry.</p>
</td></tr>
				<tr><td></td><td class="fit">D855</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D857</td>
				<td>8E 58 02</td>
				<td class="fit">STX $0258</td><td rowspan="4"><p>Zero the record length, REC ($0258) ,
MODE ($0297) (read mode), and the file
type, TYPE ($024A) (deleted file).</p>
</td></tr>
				<tr><td></td><td class="fit">D85A</td>
				<td>8E 97 02</td>
				<td class="fit">STX $0297</td></tr>
				<tr><td></td><td class="fit">D85D</td>
				<td>8E 4A 02</td>
				<td class="fit">STX $024A</td></tr>
				<tr><td></td><td class="fit">D860</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D861</td>
				<td>EC 77 02</td>
				<td class="fit">CPX $0277</td><td rowspan="2"><p>Test the value of F1CNT ($0277). If it
is $00, there are NO wild cards in the
filename so branch to OP40.</p>
</td></tr>
				<tr><td></td><td class="fit">D864</td>
				<td>B0 10</td>
				<td class="fit">BCS $D876</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D866</td>
				<td>20 09 DA</td>
				<td class="fit">JSR $DA09</td><td rowspan="1"><p>JSR to CKTM ($DA09) to set the file
type and mode.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D869</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Test the value of F1CNT ($0277). If it
is $01, there is only one wild card in
the filename so branch to OP40.</p>
</td></tr>
				<tr><td></td><td class="fit">D86A</td>
				<td>EC 77 02</td>
				<td class="fit">CPX $0277</td></tr>
				<tr><td></td><td class="fit">D86D</td>
				<td>B0 07</td>
				<td class="fit">BCS $D876</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D86F</td>
				<td>C0 04</td>
				<td class="fit">CPY #$04</td><td rowspan="2"><p>Compare .Y to $04. If .Y=$04, this is a
relative file so branch to OP60 to set
the record size.</p>
</td></tr>
				<tr><td></td><td class="fit">D871</td>
				<td>F0 3E</td>
				<td class="fit">BEQ $D8B1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D873</td>
				<td>20 09 DA</td>
				<td class="fit">JSR $DA09</td><td rowspan="1"><p>JSR to CKTM ($DA09) to set the file
type and mode.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP40</td><td class="fit">D876</td>
				<td>AE 4C 02</td>
				<td class="fit">LDX $024C</td><td rowspan="2"><p>Restore the original secondary address
into SA ($83) using the value from
TEMPSA ($024C) .</p>
</td></tr>
				<tr><td></td><td class="fit">D879</td>
				<td>86 83</td>
				<td class="fit">STX $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D87B</td>
				<td>E0 02</td>
				<td class="fit">CPX #$02</td><td rowspan="2"><p>Test the secondary address, if it is
greater or equal to $02, this is not a
load or save so branch to OP45.</p>
</td></tr>
				<tr><td></td><td class="fit">D87D</td>
				<td>B0 12</td>
				<td class="fit">BCS $D891</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D87F</td>
				<td>8E 97 02</td>
				<td class="fit">STX $0297</td><td rowspan="1"><p>This is a load or save. Set MODE ($0297)
(0=read; l=write) using the secondary
address (0=load; l=save) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D882</td>
				<td>A9 40</td>
				<td class="fit">LDA #$40</td><td rowspan="2"><p>Set the write BAM flag, WBAM ($02F9) to
$40 to flag that BAM is dirty.</p>
</td></tr>
				<tr><td></td><td class="fit">D884</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D887</td>
				<td>AD 4A 02</td>
				<td class="fit">LDA $024A</td><td rowspan="2"><p>Load .A with the file type, TYPE ($024A)
If it is not $00 (deleted file type) ,
branch to OP50. NOTE: load &amp; save of
files have TYPE set to $00 in $D857.</p>
</td></tr>
				<tr><td></td><td class="fit">D88A</td>
				<td>D0 1B</td>
				<td class="fit">BNE $D8A7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D88C</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Set file type, TYPE ($024A) to $02
(program file type).</p>
</td></tr>
				<tr><td></td><td class="fit">D88E</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP45</td><td class="fit">D891</td>
				<td>AD 4A 02</td>
				<td class="fit">LDA $024A</td><td rowspan="2"><p>Load .A with the file type, TYPE ($024A)
If it is not $00 (scratched file type) ,
branch to OP50.</p>
</td></tr>
				<tr><td></td><td class="fit">D894</td>
				<td>D0 11</td>
				<td class="fit">BNE $D8A7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D896</td>
				<td>A5 E7</td>
				<td class="fit">LDA $E7</td><td rowspan="3"><p>Load the file type as given in the
directory from PATTYP ( $E7). AND it with
$07 (file type mask). and store the
result as the file type in TYPE ($024A)</p>
</td></tr>
				<tr><td></td><td class="fit">D898</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">D89A</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D89D</td>
				<td>AD 80 02</td>
				<td class="fit">LDA $0280</td><td rowspan="2"><p>Test the file's first&quot;track link in
FILTRK ($0280). If it is not $00, the
file exists so branch to OP50.</p>
</td></tr>
				<tr><td></td><td class="fit">D8A0</td>
				<td>D0 05</td>
				<td class="fit">BNE $D8A7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8A2</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>The file doesn't exist, set TYPE ($024A)
to $01 (the default value; a SEQ file) .</p>
</td></tr>
				<tr><td></td><td class="fit">D8A4</td>
				<td>8D 4A 02</td>
				<td class="fit">STA $024A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP50</td><td class="fit">D8A7</td>
				<td>AD 97 02</td>
				<td class="fit">LDA $0297</td><td rowspan="3"><p>Check MODE ($0297). If it is $01, it is
write mode so branch to OP75 to write,</p>
</td></tr>
				<tr><td></td><td class="fit">D8AA</td>
				<td>C9 01</td>
				<td class="fit">CMP #$01</td></tr>
				<tr><td></td><td class="fit">D8AC</td>
				<td>F0 18</td>
				<td class="fit">BEQ $D8C6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8AE</td>
				<td>4C 40 D9</td>
				<td class="fit">JMP $D940</td><td rowspan="1"><p>JMP to OP90 ($D940) to open to read or
load.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Handle relative file</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP60</td><td class="fit">D8B1</td>
				<td>BC 7A 02</td>
				<td class="fit">LDY $027A,X</td><td rowspan="1"><p>Load .Y with the pointer from FILTBL,X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8B4</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td><td rowspan="2"><p>Load .A with the file's record size as
given in the directory from CMDBUF,Y and
store it in REC ($0258).</p>
</td></tr>
				<tr><td></td><td class="fit">D8B7</td>
				<td>8D 58 02</td>
				<td class="fit">STA $0258</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8BA</td>
				<td>AD 80 02</td>
				<td class="fit">LDA $0280</td><td rowspan="2"><p>Test if the file's track link in FILTRK
($0280) is $00. If it is NOT $00, the
fHandle relative file:ile is present so branch to OP40 to
read it.</p>
</td></tr>
				<tr><td></td><td class="fit">D8BD</td>
				<td>D0 B7</td>
				<td class="fit">BNE $D876</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8BF</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Set the MODE ($0297) to $01 (write mode)
and branch to OP40 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">D8C1</td>
				<td>8D 97 02</td>
				<td class="fit">STA $0297</td></tr>
				<tr><td></td><td class="fit">D8C4</td>
				<td>D0 B0</td>
				<td class="fit">BNE $D876</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP75</td><td class="fit">D8C6</td>
				<td>A5 E7</td>
				<td class="fit">LDA $E7</td><td rowspan="4"><p>Load .A with the file's type as given in
the directory from PATTYP ($E7). AND it
with $80 to determine if it is a deleted
file, and transfer the result to .X. If
it is not a deletedfile, branch to OP81</p>
</td></tr>
				<tr><td></td><td class="fit">D8C8</td>
				<td>29 80</td>
				<td class="fit">AND #$80</td></tr>
				<tr><td></td><td class="fit">D8CA</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">D8CB</td>
				<td>D0 14</td>
				<td class="fit">BNE $D8E1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP77</td><td class="fit">D8CD</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="3"><p>Open to write. Load.A with $20 and test
if any bits in .A and the file type in
PATTYP ($E7) match If not, branch to
OP80.</p>
</td></tr>
				<tr><td></td><td class="fit">D8CF</td>
				<td>24 E7</td>
				<td class="fit">BIT $E7</td></tr>
				<tr><td></td><td class="fit">D8D1</td>
				<td>F0 06</td>
				<td class="fit">BEQ $D8D9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8D3</td>
				<td>20 B6 C8</td>
				<td class="fit">JSR $C8B6</td><td rowspan="1"><p>JSR to DELDIR ($C8B6) to delete the
directory entry andwrite out the
revised sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8D6</td>
				<td>4C E3 D9</td>
				<td class="fit">JMP $D9E3</td><td rowspan="1"><p>JMP to OPWRIT ($D9E3) to open the
channel to write.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP80</td><td class="fit">D8D9</td>
				<td>AD 80 02</td>
				<td class="fit">LDA $0280</td><td rowspan="2"><p>Load .A with the entry's track link from
FILTRK ($0280). If it is not $00, there
is an existing file so branch to OP81.</p>
</td></tr>
				<tr><td></td><td class="fit">D8DC</td>
				<td>D0 03</td>
				<td class="fit">BNE $D8E1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8DE</td>
				<td>4C E3 D9</td>
				<td class="fit">JMP $D9E3</td><td rowspan="1"><p>File not found but that's OK. JMP to
OPWRIT ($D9E3) to open a write channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP81</td><td class="fit">D8E1</td>
				<td>AD 00 02</td>
				<td class="fit">LDA $0200</td><td rowspan="3"><p>Load .A with CMDBUF ($0200), the first
byte of the command string. If it equals
$40 (&quot;@&quot;), branch to OP82. NOTE: THIS IS
WHERE REPLACE FILE COMMAND IS DETECTED!</p>
</td></tr>
				<tr><td></td><td class="fit">D8E4</td>
				<td>C9 40</td>
				<td class="fit">CMP #$40</td></tr>
				<tr><td></td><td class="fit">D8E6</td>
				<td>F0 0D</td>
				<td class="fit">BEQ $D8F5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8E8</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer .X value into .A. If it is not
$00, branch to OP815.</p>
</td></tr>
				<tr><td></td><td class="fit">D8E9</td>
				<td>D0 05</td>
				<td class="fit">BNE $D8F0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8EB</td>
				<td>A9 63</td>
				<td class="fit">LDA #$63</td><td rowspan="2"><p>Load .A with $63 to indicate a FILE
EXISTS ERROR and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">D8ED</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP815</td><td class="fit">D8F0</td>
				<td>A9 33</td>
				<td class="fit">LDA #$33</td><td rowspan="2"><p>Load .A with $33 to indicate a bad
filename and JMP to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">D8F2</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Replace file routine * may have bug!</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP82</td><td class="fit">D8F5</td>
				<td>A5 E7</td>
				<td class="fit">LDA $E7</td><td rowspan="4"><p>Load the file type of the directory
entry from PATTYP ($E7). AND it with
the file type mask $07. and compare the
result with the command string file type
in TYPE ($024A). If the file types do
not match, branch to OP115 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">D8F7</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">D8F9</td>
				<td>CD 4A 02</td>
				<td class="fit">CMP $024A</td></tr>
				<tr><td></td><td class="fit">D8FC</td>
				<td>D0 67</td>
				<td class="fit">BNE $D965</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D8FE</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td><td rowspan="2"><p>Compare the file type (in .A) with $04.
If it is $04, this is a relative file
so branch to OP115 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">D900</td>
				<td>F0 63</td>
				<td class="fit">BEQ $D965</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D902</td>
				<td>20 DA DC</td>
				<td class="fit">JSR $DCDA</td><td rowspan="1"><p>JSR to OPNWCH ($DCDA) to open the write
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D905</td>
				<td>A5 82</td>
				<td class="fit">LDA $82</td><td rowspan="2"><p>Move the active buffer number from
LINDX ($82) to WLINDX ($0270) .</p>
</td></tr>
				<tr><td></td><td class="fit">D907</td>
				<td>8D 70 02</td>
				<td class="fit">STA $0270</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D90A</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="2"><p>Set the secondary address, SA ($83) to
$11 (#17) the internal read channel.</p>
</td></tr>
				<tr><td></td><td class="fit">D90C</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D90E</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D911</td>
				<td>AD 94 02</td>
				<td class="fit">LDA $0294</td><td rowspan="2"><p>Load .A with the current value of the
pointer into the directory buffer, INDEX
($0294) and JSR to SETPNT ($D4C8) to set
the buffer pointers to point to the
INDEXth byte. NOTE: at this point INDEX
points to the first byte in the entry,
the file type.</p>
</td></tr>
				<tr><td></td><td class="fit">D914</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D917</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Zero .Y. Then load .A with the file type
from (DIRBUF) ,Y; ($94), Y, OR the file
type with $20 (set the replace bit). and
store the result back in (DIRBUF) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D919</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
				<tr><td></td><td class="fit">D91B</td>
				<td>09 20</td>
				<td class="fit">ORA #$20</td></tr>
				<tr><td></td><td class="fit">D91D</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D91F</td>
				<td>A0 1A</td>
				<td class="fit">LDY #$1A</td><td rowspan="3"><p>Load .Y with $1A (#26) and move the new
track link from TRACK($80) to (DIRBUF) ,Y</p>
</td></tr>
				<tr><td></td><td class="fit">D921</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">D923</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D925</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y and move the new sector
link from SECTOR ($81) to (DIRBUF) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D926</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td></tr>
				<tr><td></td><td class="fit">D928</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D92A</td>
				<td>AE 70 02</td>
				<td class="fit">LDX $0270</td><td rowspan="1"><p>Load .X with the active buffer number
from WLINDX ($0270) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D92D</td>
				<td>A5 D8</td>
				<td class="fit">LDA $D8</td><td rowspan="2"><p>Load .A with the sector of the directory
entry ENTSEC ($D8) and copy it into
DSEC,X ($0260, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">D92F</td>
				<td>9D 60 02</td>
				<td class="fit">STA $0260,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D932</td>
				<td>A5 DD</td>
				<td class="fit">LDA $DD</td><td rowspan="2"><p>Load .A with the pointer to the start of
the directory entry ENTIND ($DD) and
copy it into DIND,X ($0266 / X).</p>
</td></tr>
				<tr><td></td><td class="fit">D934</td>
				<td>9D 66 02</td>
				<td class="fit">STA $0266,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D937</td>
				<td>20 3B DE</td>
				<td class="fit">JSR $DE3B</td><td rowspan="1"><p>JSR to CURBLK ($DE3B) to set TRACK ($80)
and SECTOR ($81) from header of most
recently read header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D93A</td>
				<td>20 64 D4</td>
				<td class="fit">JSR $D464</td><td rowspan="1"><p>JSR to DRTWRT ($D464) to do direct block
write of directory block to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D93D</td>
				<td>4C EF D9</td>
				<td class="fit">JMP $D9EF</td><td rowspan="1"><p>JMP to OPFIN ($D9EF) to finish opening
the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP90</td><td class="fit">D940</td>
				<td>AD 80 02</td>
				<td class="fit">LDA $0280</td><td rowspan="2"><p>Test the directory entry's track link
in FILTRK ($0280). If it is NOT $00,
the file exists so branch to OP100.</p>
</td></tr>
				<tr><td></td><td class="fit">D943</td>
				<td>D0 05</td>
				<td class="fit">BNE $D94A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP95</td><td class="fit">D945</td>
				<td>A9 62</td>
				<td class="fit">LDA #$62</td><td rowspan="2"><p>Load .A with $62 to indicate a FILE NOT
FOUND error and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">D947</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP100</td><td class="fit">D94A</td>
				<td>AD 97 02</td>
				<td class="fit">LDA $0297</td><td rowspan="3"><p>Compare the value in MODE ($0297) to
$03 (open to modify). If MODE=$03 branch
to OP110.</p>
</td></tr>
				<tr><td></td><td class="fit">D94D</td>
				<td>C9 03</td>
				<td class="fit">CMP #$03</td></tr>
				<tr><td></td><td class="fit">D94F</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $D95C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D951</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="3"><p>Check bit 5 of the directory entry's
file type. If this bit is set, it flags
a file that is already opened (or not
closed properly). If the bit is NOT SET,
branch to OP110 and carry on.</p>
</td></tr>
				<tr><td></td><td class="fit">D953</td>
				<td>24 E7</td>
				<td class="fit">BIT $E7</td></tr>
				<tr><td></td><td class="fit">D955</td>
				<td>F0 05</td>
				<td class="fit">BEQ $D95C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D957</td>
				<td>A9 60</td>
				<td class="fit">LDA #$60</td><td rowspan="2"><p>Load .A with $60 to indicate a FILE OPEN
error and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">D959</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP110</td><td class="fit">D95C</td>
				<td>A5 E7</td>
				<td class="fit">LDA $E7</td><td rowspan="4"><p>Load .A with the directory entry's file
type from PATTYP ($E7). AND it with $07
to mask off higher order bits, and
compare it with the file type specified
in the command string from TYPE ($024A) .
If the file types match, branch to OP120</p>
</td></tr>
				<tr><td></td><td class="fit">D95E</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">D960</td>
				<td>CD 4A 02</td>
				<td class="fit">CMP $024A</td></tr>
				<tr><td></td><td class="fit">D963</td>
				<td>F0 05</td>
				<td class="fit">BEQ $D96A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP115</td><td class="fit">D965</td>
				<td>A9 64</td>
				<td class="fit">LDA #$64</td><td rowspan="2"><p>Load .A with $64 to indicate a FILE TYPE
MISMATCH error and JMP to CMDERR ($C1C8)</p>
</td></tr>
				<tr><td></td><td class="fit">D967</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP120</td><td class="fit">D96A</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Load .Y with $00 and use it to zero
F2PTR ($0279)</p>
</td></tr>
				<tr><td></td><td class="fit">D96C</td>
				<td>8C 79 02</td>
				<td class="fit">STY $0279</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D96F</td>
				<td>AE 97 02</td>
				<td class="fit">LDX $0297</td><td rowspan="3"><p>Load .X with the mode from MODE ($0297)</p>
</td></tr>
				<tr><td></td><td class="fit">D972</td>
				<td>E0 02</td>
				<td class="fit">CPX #$02</td></tr>
				<tr><td></td><td class="fit">D974</td>
				<td>D0 1A</td>
				<td class="fit">BNE $D990</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D976</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td><td rowspan="2"><p>If MODE is not $02 (open to append) ,
branch to OP125.</p>
</td></tr>
				<tr><td></td><td class="fit">D978</td>
				<td>F0 EB</td>
				<td class="fit">BEQ $D965</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D97A</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Compare the file type (in .A) with $04.
If it is $04,this is a relative file
so branch to OP115.</p>
</td></tr>
				<tr><td></td><td class="fit">D97C</td>
				<td>29 4F</td>
				<td class="fit">AND #$4F</td></tr>
				<tr><td></td><td class="fit">D97E</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D980</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="4"><p>This applies only to opening to append,
Load .A with the file type from
(DIRBUF) ,Y ; ($94) ,Y, AND it with $4F,
and store it back in (DIRBUF) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">D982</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">D983</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td></tr>
				<tr><td></td><td class="fit">D985</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D987</td>
				<td>20 3B DE</td>
				<td class="fit">JSR $DE3B</td><td rowspan="1"><p>Save the secondary address from SA ($83)
onto the stack and set SA ($83) to $11
(#17, the internal read channel) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D98A</td>
				<td>20 64 D4</td>
				<td class="fit">JSR $D464</td><td rowspan="1"><p>JSR to CURBLK ($DE3B) to set TRACK ($80)
and SECTOR ($81) from header of most
recently read header .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D98D</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>JSR to DRTWRT ($D464) to do direct block
write of directory block to disk.</p>
</td></tr>
				<tr><td></td><td class="fit">D98E</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP125</td><td class="fit">D990</td>
				<td>20 A0 D9</td>
				<td class="fit">JSR $D9A0</td><td rowspan="1"><p>Pull original secondary address off the
stack and restore it in SA ($83).
JSR to OPREAD ($D9A0) to open the file
for a read.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D993</td>
				<td>AD 97 02</td>
				<td class="fit">LDA $0297</td><td rowspan="3"><p>Check if MODE ($0297) is $02 (append) .
If it isn't $'02, branch to OPFIN ($D9EF)</p>
</td></tr>
				<tr><td></td><td class="fit">D996</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D998</td>
				<td>D0 55</td>
				<td class="fit">BNE $D9EF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D99A</td>
				<td>20 2A DA</td>
				<td class="fit">JSR $DA2A</td><td rowspan="1"><p>JSR to APPEND ($DA2A) to read to the end
of the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D99D</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>JMP to ENDCMD ($C194) to terminate.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open a file to read</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPREAD</td><td class="fit">D9A0</td>
				<td>A0 13</td>
				<td class="fit">LDY #$13</td><td rowspan="7"><p>Copy the relative file values from the
directory entry (DIRBUF) ,Y; ($94) ,Y into
their RAM variable locations:
Track for side sector to TRKSS ($0259)
Sector for side sector to SECSS ($025A)</p>
</td></tr>
				<tr><td></td><td class="fit">D9A2</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
				<tr><td></td><td class="fit">D9A4</td>
				<td>8D 59 02</td>
				<td class="fit">STA $0259</td></tr>
				<tr><td></td><td class="fit">D9A7</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">D9A8</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
				<tr><td></td><td class="fit">D9AA</td>
				<td>8D 5A 02</td>
				<td class="fit">STA $025A</td></tr>
				<tr><td></td><td class="fit">D9AD</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9AE</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A with the record size from the
directory entry. Load .X with the size
from the command string, REC ($0258) .</p>
</td></tr>
				<tr><td></td><td class="fit">D9B0</td>
				<td>AE 58 02</td>
				<td class="fit">LDX $0258</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9B3</td>
				<td>8D 58 02</td>
				<td class="fit">STA $0258</td><td rowspan="1"><p>Store the value in .A into REC ($0258) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9B6</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer the value from .X into .A. If
the command string size is $00, branch
to OP130 (defaults to entry size) .</p>
</td></tr>
				<tr><td></td><td class="fit">D9B7</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $D9C3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9B9</td>
				<td>CD 58 02</td>
				<td class="fit">CMP $0258</td><td rowspan="2"><p>Compare the two record lengths. If they
are equal, branch to OP130.</p>
</td></tr>
				<tr><td></td><td class="fit">D9BC</td>
				<td>F0 05</td>
				<td class="fit">BEQ $D9C3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9BE</td>
				<td>A9 50</td>
				<td class="fit">LDA #$50</td><td rowspan="2"><p>Record lengths do not match, load .A
with $50 to indicate a READ PAST END OF
FILE error and JSR to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">D9C0</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OP130</td><td class="fit">D9C3</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="1"><p>Load .X with the pointer F2PTR ($0279).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9C6</td>
				<td>BD 80 02</td>
				<td class="fit">LDA $0280,X</td><td rowspan="2"><p>Copy the track link from FILTRK,X
($0280, X) to TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">D9C9</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9CB</td>
				<td>BD 85 02</td>
				<td class="fit">LDA $0285,X</td><td rowspan="2"><p>Copy the sector link from FILSEC,X
($0285, X) to SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">D9CE</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9D0</td>
				<td>20 46 DC</td>
				<td class="fit">JSR $DC46</td><td rowspan="1"><p>JSR to OPNRCH ($DC46) to open a read
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9D3</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9D5</td>
				<td>AE 79 02</td>
				<td class="fit">LDX $0279</td><td rowspan="1"><p>Load .X with the pointer F2PTR ($0279).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9D8</td>
				<td>B5 D8</td>
				<td class="fit">LDA $D8,X</td><td rowspan="3"><p>Copy the directory sector containing the
entry from ENTSEC,X ($D8,X) to DSEC,Y
($0260, Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">D9DA</td>
				<td>99 60 02</td>
				<td class="fit">STA $0260,Y</td></tr>
				<tr><td></td><td class="fit">D9DD</td>
				<td>B5 DD</td>
				<td class="fit">LDA $DD,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9DF</td>
				<td>99 66 02</td>
				<td class="fit">STA $0266,Y</td><td rowspan="1"><p>Copy the pointer to the entry in the
directory sector from ENTIND,X ($DD,X)
to DIND,Y ($0266, Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9E2</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open a file to write</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPWRIT</td><td class="fit">D9E3</td>
				<td>A5 E2</td>
				<td class="fit">LDA $E2</td><td rowspan="3"><p>Load .A with the drive number for the
file from FILDRV ($E2), AND it with $01
to mask off non-drive bits, and store
the result, as the current drive in
DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">D9E5</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">D9E7</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9E9</td>
				<td>20 DA DC</td>
				<td class="fit">JSR $DCDA</td><td rowspan="1"><p>JSR to OPNWCH ($DCDA) to open a write
channel .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9EC</td>
				<td>20 E4 D6</td>
				<td class="fit">JSR $D6E4</td><td rowspan="1"><p>JSR to ADDFIL ($D6E4) to add the entry
to the directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPFIN</td><td class="fit">D9EF</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="3"><p>If the secondary address is greater than
$01. it is a not a program file so
branch to OPF1.</p>
</td></tr>
				<tr><td></td><td class="fit">D9F1</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">D9F3</td>
				<td>B0 11</td>
				<td class="fit">BCS $DA06</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9F5</td>
				<td>20 3E DE</td>
				<td class="fit">JSR $DE3E</td><td rowspan="1"><p>JSR to GETHDR ($DE3E) to set up TRACK
and SECTOR values from the last header
read.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9F8</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Copy the track link from TRACK ($80) to
PRGTRK ($7E) .</p>
</td></tr>
				<tr><td></td><td class="fit">D9FA</td>
				<td>85 7E</td>
				<td class="fit">STA $7E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">D9FC</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Copy the file drive from DRVNUM ($7F) to
PRGDRV ($026E) .</p>
</td></tr>
				<tr><td></td><td class="fit">D9FE</td>
				<td>8D 6E 02</td>
				<td class="fit">STA $026E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA01</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Copy the sector link from SECTOR ($81)
to PRGSEC ($026F) .</p>
</td></tr>
				<tr><td></td><td class="fit">DA03</td>
				<td>8D 6F 02</td>
				<td class="fit">STA $026F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPF1</td><td class="fit">DA06</td>
				<td>4C 99 C1</td>
				<td class="fit">JMP $C199</td><td rowspan="1"><p>Terminate routine with a JMP to ENDSAV
($C199) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Check mode or file type</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CKTM</td><td class="fit">DA09</td>
				<td>BC 7A 02</td>
				<td class="fit">LDY $027A,X</td><td rowspan="3"><p>Load .Y with the pointer from FILTBL,X.</p>
<p>Load .A with the mode or file type from
the command string, CMDBUF,Y.</p>
<p>Load .Y with $04, the number of modes.</p>
</td></tr>
				<tr><td></td><td class="fit">DA0C</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td></tr>
				<tr><td></td><td class="fit">DA0F</td>
				<td>A0 04</td>
				<td class="fit">LDY #$04</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CKM1</td><td class="fit">DA11</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="4"><p>Loop to compare mode requested with the
table of modes, MODLST,Y ($FEB2,Y). If
no match is found, branch to CKM2. If a
match is found, fall through.</p>
<pre><code>Valid modes:   0 = R (READ)
	       1 = W (WRITE)
	       2 = A (APPEND)
	       3 = M (MODIFY)</code></pre>
</td></tr>
				<tr><td></td><td class="fit">DA12</td>
				<td>30 08</td>
				<td class="fit">BMI $DA1C</td></tr>
				<tr><td></td><td class="fit">DA14</td>
				<td>D9 B2 FE</td>
				<td class="fit">CMP $FEB2,Y</td></tr>
				<tr><td></td><td class="fit">DA17</td>
				<td>D0 F8</td>
				<td class="fit">BNE $DA11</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA19</td>
				<td>8C 97 02</td>
				<td class="fit">STY $0297</td><td rowspan="1"><p>Store .Y counter (0-3) in MODE ($0297)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CKM2</td><td class="fit">DA1C</td>
				<td>A0 05</td>
				<td class="fit">LDY #$05</td><td rowspan="5"><p>Loop to compare type requested with the
table of types, TPLST,Y ($FEB6,Y). If
no match is found, branch to CKT2. If a
match is found, fall through.</p>
<pre><code>Valid types:   0 = D (DELETED)
	       1 = S (SEQUENTIAL)
	       2 = P (PROGRAM)
	       3 = U (USER)
	       4 = R (RELATIVE)</code></pre>
</td></tr>
				<tr><td></td><td class="fit">DA1E</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">DA1F</td>
				<td>30 08</td>
				<td class="fit">BMI $DA29</td></tr>
				<tr><td></td><td class="fit">DA21</td>
				<td>D9 B6 FE</td>
				<td class="fit">CMP $FEB6,Y</td></tr>
				<tr><td></td><td class="fit">DA24</td>
				<td>D0 F8</td>
				<td class="fit">BNE $DA1E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA26</td>
				<td>8C 4A 02</td>
				<td class="fit">STY $024A</td><td rowspan="1"><p>Store .Y counter (0-3) in TYPE ($024A)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CKT2</td><td class="fit">DA29</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Append information to the end of a file</h1>
<p>Reads through old file to end.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">APPEND</td><td class="fit">DA2A</td>
				<td>20 39 CA</td>
				<td class="fit">JSR $CA39</td><td rowspan="1"><p>JSR to GCBYTE ($CA39) tc get a byte from
the data channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA2D</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="3"><p>Test if we are at the end of file. If
not, loop back to APPEND.</p>
</td></tr>
				<tr><td></td><td class="fit">DA2F</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
				<tr><td></td><td class="fit">DA32</td>
				<td>F0 F6</td>
				<td class="fit">BEQ $DA2A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA34</td>
				<td>20 95 DE</td>
				<td class="fit">JSR $DE95</td><td rowspan="1"><p>JSR to RDLNK ($DE95) to set TRACK ($80)
and SECTOR ($81) from the track and
sector links in the last block. NOTE:
TRACK will be $00 and SECTOR will be a
pointer to the end of the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA37</td>
				<td>A6 81</td>
				<td class="fit">LDX $81</td><td rowspan="4"><p>Load .X with the end of file pointer
from SECTOR ($81), increment it by 1,
and transfer the result to .A. If the
new value of the pointer is not $00,
there is space left at the end of this
sector so branch to AP30.</p>
</td></tr>
				<tr><td></td><td class="fit">DA39</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">DA3A</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">DA3B</td>
				<td>D0 05</td>
				<td class="fit">BNE $DA42</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA3D</td>
				<td>20 A3 D1</td>
				<td class="fit">JSR $D1A3</td><td rowspan="2"><p>No space left in this sector so JSR to
WRT0 ($D1A3) to get the next sector.</p>
</td></tr>
				<tr><td></td><td class="fit">DA40</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AP30</td><td class="fit">DA42</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td><td rowspan="1"><p>Load .A with $02 so it. points to the
start of the data area for this new
sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA45</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="3"><p>JSR to SETPNT ($D4C8) to set the active
buffer pointers.</p>
</td></tr>
				<tr><td></td><td class="fit">DA47</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">DA49</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA4B</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="4"><p>Load .X with the active buffer number
from LINDX ($82) and store $01 (channel
ready at the end of file) in the channel
status flag CHNRDY,X ($F2,X).</p>
</td></tr>
				<tr><td></td><td class="fit">DA4D</td>
				<td>05 82</td>
				<td class="fit">ORA $82</td></tr>
				<tr><td></td><td class="fit">DA4F</td>
				<td>A6 83</td>
				<td class="fit">LDX $83</td></tr>
				<tr><td></td><td class="fit">DA51</td>
				<td>9D 2B 02</td>
				<td class="fit">STA $022B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA54</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Load .X with the sec. address SA ($83) .
Load .A with $80, OR it with the active
buffer number in LINDX ($82). and store
the result in LINTAB,X ($022B,X) to
indicate that this is now a write file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LOADIR</td><td class="fit">DA55</td>
				<td>A9 0C</td>
				<td class="fit">LDA #$0C</td><td rowspan="2"><p>Terminate the routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DA57</td>
				<td>8D 2A 02</td>
				<td class="fit">STA $022A</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Load the directory ($)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA5A</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="1"><p>Store $0C (load) as the command code in
CMDNUM ($022A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA5C</td>
				<td>AE 74 02</td>
				<td class="fit">LDX $0274</td><td rowspan="3"><p>Load .A with $00 (load only drive #0)</p>
</td></tr>
				<tr><td></td><td class="fit">DA5F</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">DA60</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $DA6D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LD01</td><td class="fit">DA62</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Load .X with the command length from
CMDSIZ ($0274) and decrement &quot; the length
in .X by 1. If the result is $00, branch
to LD02 to load complete directory for
drive 0.</p>
</td></tr>
				<tr><td></td><td class="fit">DA63</td>
				<td>D0 21</td>
				<td class="fit">BNE $DA86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA65</td>
				<td>AD 01 02</td>
				<td class="fit">LDA $0201</td><td rowspan="3"><p>Decrement the length in .X by 1. If the
result is still not $00, this must be a
selective load by name so branch to LD03</p>
</td></tr>
				<tr><td></td><td class="fit">DA68</td>
				<td>20 BD C3</td>
				<td class="fit">JSR $C3BD</td></tr>
				<tr><td></td><td class="fit">DA6B</td>
				<td>30 19</td>
				<td class="fit">BMI $DA86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LD02</td><td class="fit">DA6D</td>
				<td>85 E2</td>
				<td class="fit">STA $E2</td><td rowspan="1"><p>Load .A with the second character in the
command string from CMDBUF+i ($0201) and
JSR to TST0V1 ($C3BD) to test if the
character is an ASCII &quot;0&quot; or &quot;1&quot;. If
not, branch to LD03 to load by name.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA6F</td>
				<td>EE 77 02</td>
				<td class="fit">INC $0277</td><td rowspan="3"><p>Store the drive number desired (in .A)
into FILDRV ($E2) .</p>
</td></tr>
				<tr><td></td><td class="fit">DA72</td>
				<td>EE 78 02</td>
				<td class="fit">INC $0278</td></tr>
				<tr><td></td><td class="fit">DA75</td>
				<td>EE 7A 02</td>
				<td class="fit">INC $027A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA78</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Increment F1CNT ($0277). F2CNT ($0278),
and FILTBL ($027A) .</p>
</td></tr>
				<tr><td></td><td class="fit">DA7A</td>
				<td>85 E7</td>
				<td class="fit">STA $E7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA7C</td>
				<td>A9 2A</td>
				<td class="fit">LDA #$2A</td><td rowspan="3"><p>Store $80 in PATTYP ($E7) to represent
the file type.</p>
</td></tr>
				<tr><td></td><td class="fit">DA7E</td>
				<td>8D 00 02</td>
				<td class="fit">STA $0200</td></tr>
				<tr><td></td><td class="fit">DA81</td>
				<td>8D 01 02</td>
				<td class="fit">STA $0201</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA84</td>
				<td>D0 18</td>
				<td class="fit">BNE $DA9E</td><td rowspan="1"><p>Store $2A ( &quot; * &quot; ) as the first two b&gt;tes
in the command string CMDBUF ($0200) and
CMDBUF+1 ($0201)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LD03</td><td class="fit">DA86</td>
				<td>20 E5 C1</td>
				<td class="fit">JSR $C1E5</td><td rowspan="2"><p>Branch always to LD10.</p>
</td></tr>
				<tr><td></td><td class="fit">DA89</td>
				<td>D0 05</td>
				<td class="fit">BNE $DA90</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA8B</td>
				<td>20 DC C2</td>
				<td class="fit">JSR $C2DC</td><td rowspan="1"><p>JSR to PRSCLN ($C2DC) to find the colon
in the command string. If no colon is
found. branch to LD05.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA8E</td>
				<td>A0 03</td>
				<td class="fit">LDY #$03</td><td rowspan="1"><p>Colon found so JSR to CMDRST ($C2DC) to
zero all command string variables.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LD05</td><td class="fit">DA90</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="3"><p>Lead .Y with $03.</p>
</td></tr>
				<tr><td></td><td class="fit">DA91</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">DA92</td>
				<td>8C 7A 02</td>
				<td class="fit">STY $027A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA95</td>
				<td>20 00 C2</td>
				<td class="fit">JSR $C200</td><td rowspan="1"><p>Decrement .Y twice and store the result,
in FILTBL ($027A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA98</td>
				<td>20 98 C3</td>
				<td class="fit">JSR $C398</td><td rowspan="1"><p>JSR to TC35 ($C200) to parse and set-
up the tables.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DA9B</td>
				<td>20 20 C3</td>
				<td class="fit">JSR $C320</td><td rowspan="1"><p>JSF to FS1SET ($C398) to set pointers to
file name and check type.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LD10</td><td class="fit">DA9E</td>
				<td>20 CA C3</td>
				<td class="fit">JSR $C3CA</td><td rowspan="1"><p>JSR to ALLDRS ($C320) to set up all
drives required.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAA1</td>
				<td>20 B7 C7</td>
				<td class="fit">JSR $C7B7</td><td rowspan="1"><p>JSR to OPTSCH ($C3CA) to determine the
best drive search pattern.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAA4</td>
				<td>20 9D C4</td>
				<td class="fit">JSR $C49D</td><td rowspan="1"><p>JSR to NEWDIR ($C7B7) to read in BAM and
set up disk name, ID, etc as first line
in directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LD20</td><td class="fit">DAA7</td>
				<td>20 9E EC</td>
				<td class="fit">JSR $EC9E</td><td rowspan="1"><p>JSR to FFST ($C49D) to find file start
entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAAA</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="1"><p>JSR to STDIR ($EC9E) to start the
directory loading function.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAAD</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>JSR to GETBYT ($D137) to read first byte
from the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAAF</td>
				<td>9D 3E 02</td>
				<td class="fit">STA $023E,X</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAB2</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Store the first byte (in .A) into
CHNDAT,X ($023E,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DAB4</td>
				<td>8D 8E 02</td>
				<td class="fit">STA $028E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAB7</td>
				<td>09 04</td>
				<td class="fit">ORA #$04</td><td rowspan="2"><p>Load .A with the current drive number
from DRVNUM ($7F) and use this value to
set the last job drive LSTDRV ($028E) .
OR the drive number in .A with $04 and
store the result as the file type in
FILTYP,X ($EC,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DAB9</td>
				<td>95 EC</td>
				<td class="fit">STA $EC,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DABB</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero BUFTAB+CBPTR ($A3). Note: CBPTR is
the command buffer pointer ($0A).</p>
</td></tr>
				<tr><td></td><td class="fit">DABD</td>
				<td>85 A3</td>
				<td class="fit">STA $A3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DABF</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Close the file related to the specified secondary address</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLOSE</td><td class="fit">DAC0</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero the write BAM flag, WBAM ($02F9).</p>
</td></tr>
				<tr><td></td><td class="fit">DAC2</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAC5</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="2"><p>If secondary address, SA ($83) is not
zero (directory load). branch to CLS10</p>
</td></tr>
				<tr><td></td><td class="fit">DAC7</td>
				<td>D0 0B</td>
				<td class="fit">BNE $DAD4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAC9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Close directory: Zero the directory
listing flag DIRLST ($0254) and JSR to
FRECHN ($D227) to free the channel.</p>
</td></tr>
				<tr><td></td><td class="fit">DACB</td>
				<td>8D 54 02</td>
				<td class="fit">STA $0254</td></tr>
				<tr><td></td><td class="fit">DACE</td>
				<td>20 27 D2</td>
				<td class="fit">JSR $D227</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLS05</td><td class="fit">DAD1</td>
				<td>4C DA D4</td>
				<td class="fit">JMP $D4DA</td><td rowspan="1"><p>JMP to FREICH ($D4DA) t o free the
internal channel and terminate routine.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLS10</td><td class="fit">DAD4</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td><td rowspan="2"><p>If secondary address (in .A) is $0F(#15)
branch to CLSALL to close all files.</p>
</td></tr>
				<tr><td></td><td class="fit">DAD6</td>
				<td>F0 14</td>
				<td class="fit">BEQ $DAEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAD8</td>
				<td>20 02 DB</td>
				<td class="fit">JSR $DB02</td><td rowspan="1"><p>JSR to CLSCHN ($DB02) to close channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DADB</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="3"><p>If secondary address in SA ($83) is $01
(save). branch to CLS05to close the
internal channel and exit.</p>
</td></tr>
				<tr><td></td><td class="fit">DADD</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">DADF</td>
				<td>90 F0</td>
				<td class="fit">BCC $DAD1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAE1</td>
				<td>AD 6C 02</td>
				<td class="fit">LDA $026C</td><td rowspan="2"><p>Check the error status in ERWORD ($026C)
If status is not $00, the last command
produced an error so branch to CLS15.</p>
</td></tr>
				<tr><td></td><td class="fit">DAE4</td>
				<td>D0 03</td>
				<td class="fit">BNE $DAE9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAE6</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>JMP to ENDCMD ($C194) to end command.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLS15</td><td class="fit">DAE9</td>
				<td>4C AD C1</td>
				<td class="fit">JMP $C1AD</td><td rowspan="1"><p>Error so JMP to SCREN1 ($C1AD)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Close all files: (when CMD closed)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSALL</td><td class="fit">DAEC</td>
				<td>A9 0E</td>
				<td class="fit">LDA #$0E</td><td rowspan="2"><p>Set secondary address, SA ($83) to $0E.</p>
</td></tr>
				<tr><td></td><td class="fit">DAEE</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLS20</td><td class="fit">DAF0</td>
				<td>20 02 DB</td>
				<td class="fit">JSR $DB02</td><td rowspan="1"><p>JSR to CLSCHN ($DB02) to close channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAF3</td>
				<td>C6 83</td>
				<td class="fit">DEC $83</td><td rowspan="2"><p>Decrement SA ($83). If more secondary
addresses to do (SA&gt;=0) loop to CLS20.</p>
</td></tr>
				<tr><td></td><td class="fit">DAF5</td>
				<td>10 F9</td>
				<td class="fit">BPL $DAF0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAF7</td>
				<td>AD 6C 02</td>
				<td class="fit">LDA $026C</td><td rowspan="2"><p>Check the error status in ERWORD ($026C)
If status is net $00, the last command
produced an error so branch to CLS25.</p>
</td></tr>
				<tr><td></td><td class="fit">DAFA</td>
				<td>D0 03</td>
				<td class="fit">BNE $DAFF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DAFC</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>JMP to ENDCMD ($C194) to end command.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLS25</td><td class="fit">DAFF</td>
				<td>4C AD C1</td>
				<td class="fit">JMP $C1AD</td><td rowspan="1"><p>Error so JMP to SCRENl ($C1AD)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSCHN</td><td class="fit">DB02</td>
				<td>A6 83</td>
				<td class="fit">LDX $83</td><td rowspan="1"><p>Close file with specified sec. address
Load .X with the secondary address from
SA ($83) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB04</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td><td rowspan="2"><p>Load .A with the channel status from
LINTAB,X ($022B,X). If the status is
not $FF (closed), branch to CLSC28.</p>
</td></tr>
				<tr><td></td><td class="fit">DB07</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB09</td>
				<td>D0 01</td>
				<td class="fit">BNE $DB0C</td><td rowspan="2"><p>Channel already closed so terminate
routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DB0B</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSC28</td><td class="fit">DB0C</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="2"><p>AND the channel status (in .A) with $0F
to leave only the buffer number and
store the result in LINDX ($82) .</p>
</td></tr>
				<tr><td></td><td class="fit">DB0E</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB10</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="1"><p>JSR to TYPFIL ($D125) to determine the
file type (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB13</td>
				<td>C9 07</td>
				<td class="fit">CMP #$07</td><td rowspan="2"><p>If file type is $07 (direct channel)
branch to CLSC30.</p>
</td></tr>
				<tr><td></td><td class="fit">DB15</td>
				<td>F0 0F</td>
				<td class="fit">BEQ $DB26</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB17</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td><td rowspan="2"><p>If file type is $04 (relative file)
branch to CLSREL.</p>
</td></tr>
				<tr><td></td><td class="fit">DB19</td>
				<td>F0 11</td>
				<td class="fit">BEQ $DB2C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB1B</td>
				<td>20 07 D1</td>
				<td class="fit">JSR $D107</td><td rowspan="2"><p>JSR to FNDWCK ($D107) to find an unused
write channel. If none found, branch to</p>
</td></tr>
				<tr><td></td><td class="fit">DB1E</td>
				<td>B0 09</td>
				<td class="fit">BCS $DB29</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB20</td>
				<td>20 62 DB</td>
				<td class="fit">JSR $DB62</td><td rowspan="1"><p>JSR to CLSWRT ($DB62) to close off
sequential write.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB23</td>
				<td>20 A5 DB</td>
				<td class="fit">JSR $DBA5</td><td rowspan="1"><p>JSR to CLSDIR ($DBA5) to close directory</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSC30</td><td class="fit">DB26</td>
				<td>20 F4 EE</td>
				<td class="fit">JSR $EEF4</td><td rowspan="1"><p>JSR to MAPOUT ($EEF4) to write out. BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSC31</td><td class="fit">DB29</td>
				<td>4C 27 D2</td>
				<td class="fit">JMP $D227</td><td rowspan="1"><p>JMP to FRECHN ($D227) to free channel
and terminate the command.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSREL</td><td class="fit">DB2C</td>
				<td>20 F1 DD</td>
				<td class="fit">JSR $DDF1</td><td rowspan="1"><p>Sub to close relative file:
JSR to SCRUB ($DDF1) to write out BAM
if it is dirty (RAM version modified) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB2F</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to set up double
buffering and read ahead.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB32</td>
				<td>20 CB E1</td>
				<td class="fit">JSR $E1CB</td><td rowspan="1"><p>JSR to SSEND ($E1CB) to position side
sector &amp; buffer table pointer to the end
of the last record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB35</td>
				<td>A6 D5</td>
				<td class="fit">LDX $D5</td><td rowspan="3"><p>Load .X with the side sector number from
SSNUM ($D5), store this byte in T4($73),
and increment T4 by 1.</p>
</td></tr>
				<tr><td></td><td class="fit">DB37</td>
				<td>86 73</td>
				<td class="fit">STX $73</td></tr>
				<tr><td></td><td class="fit">DB39</td>
				<td>E6 73</td>
				<td class="fit">INC $73</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB3B</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Zero T1 ($70) and T2 ($71).</p>
</td></tr>
				<tr><td></td><td class="fit">DB3D</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">DB3F</td>
				<td>85 71</td>
				<td class="fit">STA $71</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB41</td>
				<td>A5 D6</td>
				<td class="fit">LDA $D6</td><td rowspan="4"><p>Load .A with the pointer to the side
sector value in the directory buffer
from SSIND ($D6), set the carry flag,
subtract $0E (the side sector offset-2) ,
and store the result in T3 ($72) .</p>
</td></tr>
				<tr><td></td><td class="fit">DB43</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">DB44</td>
				<td>E9 0E</td>
				<td class="fit">SBC #$0E</td></tr>
				<tr><td></td><td class="fit">DB46</td>
				<td>85 72</td>
				<td class="fit">STA $72</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB48</td>
				<td>20 51 DF</td>
				<td class="fit">JSR $DF51</td><td rowspan="1"><p>JSR to SSCALC ($DF51) to calculate the
number of side sector blocks needed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB4B</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB4D</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td><td rowspan="4"><p>Move the lo byte of the number of side
sector blocks from Tl ($70) to NBKL,X
($B5,X) and the hi byte from T2 ($71) to
NBKH,X ($BB,X).</p>
</td></tr>
				<tr><td></td><td class="fit">DB4F</td>
				<td>95 B5</td>
				<td class="fit">STA $B5,X</td></tr>
				<tr><td></td><td class="fit">DB51</td>
				<td>A5 71</td>
				<td class="fit">LDA $71</td></tr>
				<tr><td></td><td class="fit">DB53</td>
				<td>95 BB</td>
				<td class="fit">STA $BB,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB55</td>
				<td>A9 40</td>
				<td class="fit">LDA #$40</td><td rowspan="3"><p>Load .A with $40 (the dirty flag for a
relative record flag) and JSR to TSTFLG
($DDA6) to test if relative record must
be written out. If not, branch to CLSR1 .</p>
</td></tr>
				<tr><td></td><td class="fit">DB57</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
				<tr><td></td><td class="fit">DB5A</td>
				<td>F0 03</td>
				<td class="fit">BEQ $DB5F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB5C</td>
				<td>20 A5 DB</td>
				<td class="fit">JSR $DBA5</td><td rowspan="1"><p>JSR to CLSDIR ($DBA5) to close the
directory file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSR1</td><td class="fit">DB5F</td>
				<td>4C 27 D2</td>
				<td class="fit">JMP $D227</td><td rowspan="1"><p>JMP to FRECHN ($D227) to clear the
channel and terminate routine.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Close a sequential file write channel</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSWRT</td><td class="fit">DB62</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Lead .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB64</td>
				<td>B5 B5</td>
				<td class="fit">LDA $B5,X</td><td rowspan="3"><p>Load .A with the number of bytes written
in this sector from NBKL,X ($B5,X) and
OR .A with the number of data blocks
written from NBKL,X ($B5,X).
If the result is not $00. at least one
block of the file has been written so
branch to CLSW10.</p>
</td></tr>
				<tr><td></td><td class="fit">DB66</td>
				<td>15 BB</td>
				<td class="fit">ORA $BB,X</td></tr>
				<tr><td></td><td class="fit">DB68</td>
				<td>D0 0C</td>
				<td class="fit">BNE $DB76</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB6A</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="3"><p>No blocks have been written so JSF to
GETPNT ($D4E8) to get the pointer into
the data buffer (returned in .A). If
this value is greater than two, at least
one byte has been written so branch to
CLSW10.</p>
</td></tr>
				<tr><td></td><td class="fit">DB6D</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">DB6F</td>
				<td>D0 05</td>
				<td class="fit">BNE $DB76</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB71</td>
				<td>A9 0D</td>
				<td class="fit">LDA #$0D</td><td rowspan="2"><p>No bytes have been written so load .A
with $0D (carriage return) and JSR to
PUTBYT ($CFF1) to write it out to the
data buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">DB73</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSW10</td><td class="fit">DB76</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="3"><p>JSR to GETPNT ($D4E8) to get the pointer
into the data buffer (returned in .A) .
If the pointer value is not $02, the
buffer is not empty so branch to CLSW20.</p>
</td></tr>
				<tr><td></td><td class="fit">DB79</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">DB7B</td>
				<td>D0 0F</td>
				<td class="fit">BNE $DB8C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB7D</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>Since we have an empty buffer, JSR to
DBLBUF ($CF1E) to switch buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB80</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB82</td>
				<td>B5 B5</td>
				<td class="fit">LDA $B5,X</td><td rowspan="2"><p>Load .A with the number of bytes written
in this sector from NBKL,X ($B5,X). If
this value is not equal to $00, branch
to CLSW15.</p>
</td></tr>
				<tr><td></td><td class="fit">DB84</td>
				<td>D0 02</td>
				<td class="fit">BNE $DB88</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB86</td>
				<td>D6 BB</td>
				<td class="fit">DEC $BB,X</td><td rowspan="1"><p>Decrement the number of data blocks
written in NBKH,X ($BB,X) by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSW15</td><td class="fit">DB88</td>
				<td>D6 B5</td>
				<td class="fit">DEC $B5,X</td><td rowspan="1"><p>Decrement the number of bytes written
in this sector, NBKL,X ($B5,X) by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB8A</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="1"><p>Load .A with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSW20</td><td class="fit">DB8C</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>Set the carry flag, subtract $01 from
the number of bytes written in this
sector (.A), and save the result, on the
stack.</p>
</td></tr>
				<tr><td></td><td class="fit">DB8D</td>
				<td>E9 01</td>
				<td class="fit">SBC #$01</td></tr>
				<tr><td></td><td class="fit">DB8F</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB90</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to SETPNT
($D4C8) to set the buffer pointers to
the first byte in the data buffer (the
track link) .</p>
</td></tr>
				<tr><td></td><td class="fit">DB92</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB95</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td><td rowspan="1"><p>JSR to PUTBYT ($CFF1) to write $00 out
as the track link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB98</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the bytes written from the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB99</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td><td rowspan="1"><p>JSR to PUTBYT ($CFF1) to write out the
bytes in this sector as the sector link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB9C</td>
				<td>20 C7 D0</td>
				<td class="fit">JSR $D0C7</td><td rowspan="1"><p>JSR to WRTBUF ($D0C7) to write the data
buffer out to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DB9F</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
write job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBA2</td>
				<td>4C 1E CF</td>
				<td class="fit">JMP $CF1E</td><td rowspan="1"><p>JMP to DBLBUF ($CF1E) to make sure that
both buffers are OK.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Close directory after writing file</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSDIR</td><td class="fit">DBA5</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="2"><p>Load .X with the active buffer number
from LINDX ($82). Save this value into
WL1NDX ($0270) .</p>
</td></tr>
				<tr><td></td><td class="fit">DBA7</td>
				<td>8E 70 02</td>
				<td class="fit">STX $0270</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBAA</td>
				<td>A5 83</td>
				<td class="fit">LDA $83</td><td rowspan="2"><p>Save the current secondary address from
SA ($83) onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">DBAC</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBAD</td>
				<td>BD 60 02</td>
				<td class="fit">LDA $0260,X</td><td rowspan="2"><p>Copy the sector of the directory entry
for the file from DSEC,X ($0260, X) into
SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">DBB0</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBB2</td>
				<td>BD 66 02</td>
				<td class="fit">LDA $0266,X</td><td rowspan="2"><p>Copy the pointer to the directory entry
for the file from DIND,X ($0266, X) into
INDEX ($0294) .</p>
</td></tr>
				<tr><td></td><td class="fit">DBB5</td>
				<td>8D 94 02</td>
				<td class="fit">STA $0294</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBB8</td>
				<td>B5 EC</td>
				<td class="fit">LDA $EC,X</td><td rowspan="3"><p>Load .A with the file type from FILTYP,X
($EC,X), AND it with $01 to mask off the
non-drive bits, and store the result as
the current drive number in DRVNUM ($7F)</p>
</td></tr>
				<tr><td></td><td class="fit">DBBA</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">DBBC</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBBE</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="2"><p>Copy the directory track number (#18)
from DIRTRK ($FE85) into TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">DBC1</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBC3</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBC6</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="2"><p>Save the active buffer number onto the
stack and into JOBNUM ($F9) .</p>
</td></tr>
				<tr><td></td><td class="fit">DBC7</td>
				<td>85 F9</td>
				<td class="fit">STA $F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBC9</td>
				<td>20 60 D4</td>
				<td class="fit">JSR $D460</td><td rowspan="1"><p>JSR to DIRTRD ($D460) to read in the
directory sector containing the entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBCC</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBCE</td>
				<td>BD E0 FE</td>
				<td class="fit">LDA $FEE0,X</td><td rowspan="2"><p>Load .A with the hi byte of the pointer
to the active buffer from BUFIND,X
($FEE0,X) and store it in R0+1 ($87).</p>
</td></tr>
				<tr><td></td><td class="fit">DBD1</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBD3</td>
				<td>AD 94 02</td>
				<td class="fit">LDA $0294</td><td rowspan="2"><p>Complete the pointer into the directory
buffer by copying the lo byte of the
pointer from INDEX ($0294) to R0 ($86) .</p>
</td></tr>
				<tr><td></td><td class="fit">DBD6</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBD8</td>
				<td>B1 86</td>
				<td class="fit">LDA ($86),Y</td><td rowspan="3"><p>Load .A with the file type from the
directory entry (R0),Y, AND it with $20,
and checking if the result is $00. If
it is $00, this is NOT a replace so
branch to CLSD5 .</p>
</td></tr>
				<tr><td></td><td class="fit">DBDA</td>
				<td>29 20</td>
				<td class="fit">AND #$20</td></tr>
				<tr><td></td><td class="fit">DBDC</td>
				<td>F0 43</td>
				<td class="fit">BEQ $DC21</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: Here is where we do the directory
      entry when a file is replaced.
      Possible bugs!</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBDE</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="1"><p>JSR to TYPF1L ($D125) to determine the
file type (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBE1</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td><td rowspan="2"><p>If file type is $04 (a relative file)
branch to CLSD6 .</p>
</td></tr>
				<tr><td></td><td class="fit">DBE3</td>
				<td>F0 44</td>
				<td class="fit">BEQ $DC29</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBE5</td>
				<td>B1 86</td>
				<td class="fit">LDA ($86),Y</td><td rowspan="3"><p>Load .A with the file type from R0,Y,
AND it with $8F to mask off the replace
bit, and store the result back in R0,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DBE7</td>
				<td>29 8F</td>
				<td class="fit">AND #$8F</td></tr>
				<tr><td></td><td class="fit">DBE9</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBEB</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y. The pointer at (R0) ,Y now
points to the old track link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBEC</td>
				<td>B1 86</td>
				<td class="fit">LDA ($86),Y</td><td rowspan="2"><p>Copy the old track link from (R0) ,Y to
into TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">DBEE</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBF0</td>
				<td>84 71</td>
				<td class="fit">STY $71</td><td rowspan="1"><p>Store the .Y value into TEMP+2 ($71) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBF2</td>
				<td>A0 1B</td>
				<td class="fit">LDY #$1B</td><td rowspan="1"><p>Load .Y with $1B (#27). The pointer at
(R0) ,Y now points to the replacement
sector link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBF4</td>
				<td>B1 86</td>
				<td class="fit">LDA ($86),Y</td><td rowspan="2"><p>Load .A with the replacement sector link
from (R0) ,Y and save it on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">DBF6</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBF7</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="1"><p>Decrement .Y. The pointer at (R0) ,Y now
points to the replacement track link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBF8</td>
				<td>B1 86</td>
				<td class="fit">LDA ($86),Y</td><td rowspan="2"><p>Load .A with the replacement track link.
If this link is NOT $00, branch to CLSD4</p>
</td></tr>
				<tr><td></td><td class="fit">DBFA</td>
				<td>D0 0A</td>
				<td class="fit">BNE $DC06</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBFC</td>
				<td>85 80</td>
				<td class="fit">STA $80</td><td rowspan="1"><p>Trouble! Replacement track link should
never be $00. So put replacement track
link in TRACK ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DBFE</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull replacement sector link off the
stack and put it in SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">DBFF</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC01</td>
				<td>A9 67</td>
				<td class="fit">LDA #$67</td><td rowspan="2"><p>Load .A with $67 to indicate a SYSTEM
TRACK OR SECTOR error and JMP to CMDER2
($E645) .</p>
</td></tr>
				<tr><td></td><td class="fit">DC03</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSD4</td><td class="fit">DC06</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Push the replacement track link onto
the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC07</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00. Zero the replacement-
track link in the entry (R0) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DC09</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC0B</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC0C</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td><td rowspan="1"><p>Zero replacement sector link in (R0) ,Y .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC0E</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the replacement track link off
the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC0F</td>
				<td>A4 71</td>
				<td class="fit">LDY $71</td><td rowspan="1"><p>Load .Y with the original pointer value
from TEMP+2 ($71). Note: pointer at
(R0) ,Y now points to the second byte of
the entry, the track link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC11</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td><td rowspan="1"><p>Store the replacement track link as the
final track link in (R0) ,Y .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC13</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y. Note: the pointer at
(R0) ,Y now points to the third byte of
the entry, the sector link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC14</td>
				<td>B1 86</td>
				<td class="fit">LDA ($86),Y</td><td rowspan="2"><p>Move the old sector link from (R0) ,Y to
SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">DC16</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC18</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the replacement sector link off the
stack and store it as the final sector
link in (R0) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DC19</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC1B</td>
				<td>20 7D C8</td>
				<td class="fit">JSR $C87D</td><td rowspan="1"><p>JSR to DEIFIL ($C87D) to delete the old
file from the BAM by following the track
and sector links.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC1E</td>
				<td>4C 29 DC</td>
				<td class="fit">JMP $DC29</td><td rowspan="1"><p>JSR to CLSD6 ($DC29) to finish closing.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSD5</td><td class="fit">DC21</td>
				<td>B1 86</td>
				<td class="fit">LDA ($86),Y</td><td rowspan="4"><p>Load .A with the file type from (R0) ,Y ,
AND it with $0F to mask off any high
order bits, OR it with $80 to set the
closed bit, and store the result back
in (R0) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DC23</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">DC25</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td></tr>
				<tr><td></td><td class="fit">DC27</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLSD6</td><td class="fit">DC29</td>
				<td>AE 70 02</td>
				<td class="fit">LDX $0270</td><td rowspan="1"><p>Load .X with the active buffer number
that was saved into WLINDX ($0270) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC2C</td>
				<td>A0 1C</td>
				<td class="fit">LDY #$1C</td><td rowspan="1"><p>Load .Y with $1B (#27). The pointer at
(R0) ,Y now points to the low byte of the
number of blocks in the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC2E</td>
				<td>B5 B5</td>
				<td class="fit">LDA $B5,X</td><td rowspan="2"><p>Copy the lo byte of the number of blocks
from NBKL,X ($B5,X) to (R0),Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DC30</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC32</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC33</td>
				<td>B5 BB</td>
				<td class="fit">LDA $BB,X</td><td rowspan="2"><p>Copy the hi byte of the number of blocks
from NBKH,X ($BB,X) to (R0) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DC35</td>
				<td>91 86</td>
				<td class="fit">STA ($86),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC37</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original buffer number off the
stack and transfer it into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">DC38</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC39</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="2"><p>Load .A with $90 (write job code) and OR
it with the drive number in DRVNUM($7F).</p>
</td></tr>
				<tr><td></td><td class="fit">DC3B</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC3D</td>
				<td>20 90 D5</td>
				<td class="fit">JSR $D590</td><td rowspan="1"><p>JSR to DOIT ($D590) to write out the
revised directory sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC40</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original secondary address off
the stack and transfer it into SA ($83),</p>
</td></tr>
				<tr><td></td><td class="fit">DC41</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC43</td>
				<td>4C 07 D1</td>
				<td class="fit">JMP $D107</td><td rowspan="1"><p>JMP to FNDWCH ($D107) to exit.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open read channel with two buffers</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPNRCH</td><td class="fit">DC46</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Sets secondary address in LINTAB and
initializes all pointers, including the
ones for a relative file.
Load .A with $01 and JSR to GETRCH
($D1E2) to set up one read channel</p>
</td></tr>
				<tr><td></td><td class="fit">DC48</td>
				<td>20 E2 D1</td>
				<td class="fit">JSR $D1E2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC4B</td>
				<td>20 B6 DC</td>
				<td class="fit">JSR $DCB6</td><td rowspan="1"><p>JSR to INITP ($DCB6) to clear pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC4E</td>
				<td>AD 4A 02</td>
				<td class="fit">LDA $024A</td><td rowspan="2"><p>Load .A with the file type and save this
value on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">DC51</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC52</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="3"><p>Multiply the file type in .A by 2 (ASL) ,
OR it with the current drive in DRVNUM
($7F) and store it in FILTYP,X to set
the file type.</p>
</td></tr>
				<tr><td></td><td class="fit">DC53</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td></tr>
				<tr><td></td><td class="fit">DC55</td>
				<td>95 EC</td>
				<td class="fit">STA $EC,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC57</td>
				<td>20 9B D0</td>
				<td class="fit">JSR $D09B</td><td rowspan="1"><p>JSR to STRRD ($D09B) to read the first-
one or two blocks in the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC5A</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC5C</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A with the current track number
from TRACK ($80). If the track number
is not $00 (not the last block in the
file), branch to CR10.</p>
</td></tr>
				<tr><td></td><td class="fit">DC5E</td>
				<td>D0 05</td>
				<td class="fit">BNE $DC65</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC60</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Load .A with the current sector number
from SECTOR ($81). Since TRACK=$00, this
is the pointer to the last character in
the file. Store this value in LSTCHR,X
($0244, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DC62</td>
				<td>9D 44 02</td>
				<td class="fit">STA $0244,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OR10</td><td class="fit">DC65</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the original file type off the
stack. If this is not a relative file,
branch to OR30.</p>
</td></tr>
				<tr><td></td><td class="fit">DC66</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td></tr>
				<tr><td></td><td class="fit">DC68</td>
				<td>D0 3F</td>
				<td class="fit">BNE $DCA9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC6A</td>
				<td>A4 83</td>
				<td class="fit">LDY $83</td><td rowspan="4"><p>Load .Y with the secondary address from
SA ($83). Load the channel type from
LINTAB, Y ($022B,Y), OR it with $40 to
mark it as a READ/WRITE file, and store
the channel type back in LINTAB, Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DC6C</td>
				<td>B9 2B 02</td>
				<td class="fit">LDA $022B,Y</td></tr>
				<tr><td></td><td class="fit">DC6F</td>
				<td>09 40</td>
				<td class="fit">ORA #$40</td></tr>
				<tr><td></td><td class="fit">DC71</td>
				<td>99 2B 02</td>
				<td class="fit">STA $022B,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC74</td>
				<td>AD 58 02</td>
				<td class="fit">LDA $0258</td><td rowspan="2"><p>Copy the record size from REC ($0258)
into RS,X ($C7,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DC77</td>
				<td>95 C7</td>
				<td class="fit">STA $C7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC79</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td><td rowspan="2"><p>JSR to GETBUF ($D28E) to set up a buffer
for the side sectors. If a buffer is
available, branch to OR20.</p>
</td></tr>
				<tr><td></td><td class="fit">DC7C</td>
				<td>10 03</td>
				<td class="fit">BPL $DC81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC7E</td>
				<td>4C 0F D2</td>
				<td class="fit">JMP $D20F</td><td rowspan="1"><p>Since no buffer is available for the
side sectors, abort with a JMP to GBERR
($D20F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OR20</td><td class="fit">DC81</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
(side sector buffer) from LINDX ($82).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC83</td>
				<td>95 CD</td>
				<td class="fit">STA $CD,X</td><td rowspan="1"><p>Store the side sector buffer number in
SS,X ($CD,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC85</td>
				<td>AC 59 02</td>
				<td class="fit">LDY $0259</td><td rowspan="2"><p>Copy the side sector track link from
TRKSS ($0259) into TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">DC88</td>
				<td>84 80</td>
				<td class="fit">STY $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC8A</td>
				<td>AC 5A 02</td>
				<td class="fit">LDY $025A</td><td rowspan="2"><p>Copy the side sector sector link from
SECSS ($025A) into SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">DC8D</td>
				<td>84 81</td>
				<td class="fit">STY $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC8F</td>
				<td>20 D3 D6</td>
				<td class="fit">JSR $D6D3</td><td rowspan="1"><p>JSR to SETH ($D6D3) to set up the side
sector header image.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC92</td>
				<td>20 73 DE</td>
				<td class="fit">JSR $DE73</td><td rowspan="1"><p>JSR to RDSS ($DE73) to read in the side
sector block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC95</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OROW</td><td class="fit">DC98</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
(side sector buffer) from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DC9A</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="3"><p>Set the next record pointer in the side
sector buffer NR,X ($C1,X) to $02.</p>
</td></tr>
				<tr><td></td><td class="fit">DC9C</td>
				<td>95 C1</td>
				<td class="fit">STA $C1,X</td></tr>
				<tr><td></td><td class="fit">DC9E</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCA0</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td><td rowspan="1"><p>Load .A with $00 and JSR to SETPNT
($D4C8) to set the buffer pointers to
the start of the side sector buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCA3</td>
				<td>20 53 E1</td>
				<td class="fit">JSR $E153</td><td rowspan="1"><p>JSR to RD4C ($E153) to set up the first
record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCA6</td>
				<td>4C 3E DE</td>
				<td class="fit">JMP $DE3E</td><td rowspan="1"><p>JMP to GETHDR ($DE3E) to restore the
track and sector pointers and exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OR30</td><td class="fit">DCA9</td>
				<td>20 56 D1</td>
				<td class="fit">JSR $D156</td><td rowspan="1"><p>JSR to RDBYT ($D156) to read a byte.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCAC</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
(side sector buffer) from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCAE</td>
				<td>9D 3E 02</td>
				<td class="fit">STA $023E,X</td><td rowspan="1"><p>Store the data byte (in .A) into
CHNDAT,X ($023E,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCB1</td>
				<td>A9 88</td>
				<td class="fit">LDA #$88</td><td rowspan="2"><p>Store $88 (ready to talk) as the channel
status in CHNRDY,X ($F2,X).</p>
</td></tr>
				<tr><td></td><td class="fit">DCB3</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCB5</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INITP</td><td class="fit">DCB6</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Initialize variables for open channel:
Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCB8</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="3"><p>Load buffer number from BUF0,X ($A7,X),
multiply it by two (ASL). and transfer
the result into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DCBA</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">DCBB</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCBC</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Store $02 into the buffer pointer
BUFTAB,Y ($0099, Y) so it points to the
first data byte in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">DCBE</td>
				<td>99 99 00</td>
				<td class="fit">STA $0099,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCC1</td>
				<td>B5 AE</td>
				<td class="fit">LDA $AE,X</td><td rowspan="3"><p>Load .A with the alternative-buffer
number from BUF1,X ($AE,X), OR it with
$80 to set the buffer-inactive bit, and
store the result back in BUF1,X.</p>
</td></tr>
				<tr><td></td><td class="fit">DCC3</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td></tr>
				<tr><td></td><td class="fit">DCC5</td>
				<td>95 AE</td>
				<td class="fit">STA $AE,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCC7</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number (in .A) by
two (ASL) and transfer the result to .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DCC8</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCC9</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Store $02 into the buffer pointer
BUFTAB,Y ($0099, Y) so it points to the
first data byte in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">DCCB</td>
				<td>99 99 00</td>
				<td class="fit">STA $0099,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCCE</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Zero the lo and hi bytes of the number
of blocks written, NBKL,X ($B5,X) and
NBKH,X ($BB,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DCD0</td>
				<td>95 B5</td>
				<td class="fit">STA $B5,X</td></tr>
				<tr><td></td><td class="fit">DCD2</td>
				<td>95 BB</td>
				<td class="fit">STA $BB,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCD4</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero the last data byte LSTCHR,X
($0244) ,X.</p>
</td></tr>
				<tr><td></td><td class="fit">DCD6</td>
				<td>9D 44 02</td>
				<td class="fit">STA $0244,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCD9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Open write channel with two buffers</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OPNWCH</td><td class="fit">DCDA</td>
				<td>20 A9 F1</td>
				<td class="fit">JSR $F1A9</td><td rowspan="1"><p>JSR to INTTS ($F1A9) to get the first
track and sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCDD</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Load .A with $01 and JSR to GETWCH
($D1DF) to get one buffer for writing.</p>
</td></tr>
				<tr><td></td><td class="fit">DCDF</td>
				<td>20 DF D1</td>
				<td class="fit">JSR $D1DF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCE2</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>JSR to SETHDR ($D6D0) to set up header
image.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCE5</td>
				<td>20 B6 DC</td>
				<td class="fit">JSR $DCB6</td><td rowspan="1"><p>JSR to INITP ($DCB6) to set up pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCE8</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCEA</td>
				<td>AD 4A 02</td>
				<td class="fit">LDA $024A</td><td rowspan="2"><p>Load .A with the file type from TYPE
($024A) and save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">DCED</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCEE</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="3"><p>Multiply the file type in .A by two
(ASL). OR it with the drive number from
DRVNUM ($7F). and store the result as
the file type in FILTYP,X ($EC,X).</p>
</td></tr>
				<tr><td></td><td class="fit">DCEF</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td></tr>
				<tr><td></td><td class="fit">DCF1</td>
				<td>95 EC</td>
				<td class="fit">STA $EC,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCF3</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the original file type off the
stack and if this is a relative file
(type = $04), branch to OW10.</p>
</td></tr>
				<tr><td></td><td class="fit">DCF4</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td></tr>
				<tr><td></td><td class="fit">DCF6</td>
				<td>F0 05</td>
				<td class="fit">BEQ $DCFD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCF8</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Since this is not a relative file, set
channel status, CHNRDY,X ($F2,X) to $01
(active listener) .</p>
</td></tr>
				<tr><td></td><td class="fit">DCFA</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCFC</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OW10</td><td class="fit">DCFD</td>
				<td>A4 83</td>
				<td class="fit">LDY $83</td><td rowspan="1"><p>Load .Y with the secondary address from
SA ($83) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DCFF</td>
				<td>B9 2B 02</td>
				<td class="fit">LDA $022B,Y</td><td rowspan="4"><p>Load .A with the buffer type from
LINTAB,Y ($022B,Y). AND it with $3F to
mask off higher order bits, OR it with
$40 to flag this as a READ/WRITE file,
and store the result back in LINTAB,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DD02</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td></tr>
				<tr><td></td><td class="fit">DD04</td>
				<td>09 40</td>
				<td class="fit">ORA #$40</td></tr>
				<tr><td></td><td class="fit">DD06</td>
				<td>99 2B 02</td>
				<td class="fit">STA $022B,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD09</td>
				<td>AD 58 02</td>
				<td class="fit">LDA $0258</td><td rowspan="2"><p>Copy record size from REC ($0258) into
RS,X ($C7,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DD0C</td>
				<td>95 C7</td>
				<td class="fit">STA $C7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD0E</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td><td rowspan="2"><p>JSR to GETBUF ($D28E) to get a new
buffer for storing the side sectors.
If a buffer is available, branch to OW20</p>
</td></tr>
				<tr><td></td><td class="fit">DD11</td>
				<td>10 03</td>
				<td class="fit">BPL $DD16</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD13</td>
				<td>4C 0F D2</td>
				<td class="fit">JMP $D20F</td><td rowspan="1"><p>No buffer available so abort with a
JMP to GBERR ($D20F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OW20</td><td class="fit">DD16</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD18</td>
				<td>95 CD</td>
				<td class="fit">STA $CD,X</td><td rowspan="1"><p>Store the new side sector buffer number
into SS,X ($CD,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD1A</td>
				<td>20 C1 DE</td>
				<td class="fit">JSR $DEC1</td><td rowspan="1"><p>JSR to CLRBUF ($DEC1) to clear the
side sector buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD1D</td>
				<td>20 1E F1</td>
				<td class="fit">JSR $F11E</td><td rowspan="1"><p>JSR to NXTTS ($F11E) to find the next-
available track and sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD20</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Copy the new track link from TRACK ($80)
to TRKSS ($0259) .</p>
</td></tr>
				<tr><td></td><td class="fit">DD22</td>
				<td>8D 59 02</td>
				<td class="fit">STA $0259</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD25</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Copy the new sector link from SECTOR
($81) to SECSS ($025A) .</p>
</td></tr>
				<tr><td></td><td class="fit">DD27</td>
				<td>8D 5A 02</td>
				<td class="fit">STA $025A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD2A</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD2C</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="1"><p>Load .A with the side sector buffer
number from SS,X ($CD,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD2E</td>
				<td>20 D3 D6</td>
				<td class="fit">JSR $D6D3</td><td rowspan="1"><p>JSR to SETH ($D6D3) to set up the header</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD31</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to SETSSP
($DEE9) to set the buffer pointers
using the current SS pointer (in .A)</p>
</td></tr>
				<tr><td></td><td class="fit">DD33</td>
				<td>20 E9 DE</td>
				<td class="fit">JSR $DEE9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD36</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to PUTSS
($DD8D) to set a null side sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">DD38</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD3B</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td><td rowspan="2"><p>Load .A with $11 (the side sector offset
plus 1) and JSR to PUTSS ($DD8D) to set
the last character.</p>
</td></tr>
				<tr><td></td><td class="fit">DD3D</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD40</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to PUTSS
($DD8D) to set this side sector number.</p>
</td></tr>
				<tr><td></td><td class="fit">DD42</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD45</td>
				<td>AD 58 02</td>
				<td class="fit">LDA $0258</td><td rowspan="2"><p>Load .A with the record size from REC
($0258) and JSR to PUTSS ($DD8D) to set
the record size.</p>
</td></tr>
				<tr><td></td><td class="fit">DD48</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD4B</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A with the file track link from
TRACK ($80) and JSR to PUTSS ($DD8D) to
set the track link.</p>
</td></tr>
				<tr><td></td><td class="fit">DD4D</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD50</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Load .A with the file sector link from
SECTOR ($81) and JSR to PUTSS ($DD8D) to
set the sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">DD52</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD55</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td><td rowspan="2"><p>Load .A with the side sector offset
($10) and JSR to PUTSS ($DD8D) to set
the side sector offset.</p>
</td></tr>
				<tr><td></td><td class="fit">DD57</td>
				<td>20 E9 DE</td>
				<td class="fit">JSR $DEE9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD5A</td>
				<td>20 3E DE</td>
				<td class="fit">JSR $DE3E</td><td rowspan="1"><p>JSR to GETHDR ($DE3E) to get the track
and sector of the first side sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD5D</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A with the SS track link from
TRACK ($80) and JSR to PUTSS ($DD8D) to
set the SS track link.</p>
</td></tr>
				<tr><td></td><td class="fit">DD5F</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD62</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Load .A with the SS sector link from
SECTOR ($81) and JSR to PUTSS ($DD8D) to
set the SS sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">DD64</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD67</td>
				<td>20 6C DE</td>
				<td class="fit">JSR $DE6C</td><td rowspan="1"><p>JSF to WRTSS ($DE6C) to write out the
side sector block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD6A</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
write job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD6D</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Load .A with $02 and JSR to SETPNT
($D4C8) to set the pointer into the
data buffer to the start of the data.</p>
</td></tr>
				<tr><td></td><td class="fit">DD6F</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD72</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD74</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="4"><p>Set the carry flag, load .A with $00,
subtract the record size from RS,X
($C7,X), and store the result in NR,X
($C1,X) to set NR for a null buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">DD75</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">DD77</td>
				<td>F5 C7</td>
				<td class="fit">SBC $C7,X</td></tr>
				<tr><td></td><td class="fit">DD79</td>
				<td>95 C1</td>
				<td class="fit">STA $C1,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD7B</td>
				<td>20 E2 E2</td>
				<td class="fit">JSR $E2E2</td><td rowspan="1"><p>JSR to NULBUF ($E2E2) to set null
records in the active buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD7E</td>
				<td>20 19 DE</td>
				<td class="fit">JSR $DE19</td><td rowspan="1"><p>JSR to NULLNK ($DE19) to set track link
to $00 and sector link to last non-zero
character.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD81</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write out the
null record block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD84</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
write job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD87</td>
				<td>20 F4 EE</td>
				<td class="fit">JSR $EEF4</td><td rowspan="1"><p>JSR to MAPOUT ($EEF4) to write out the
BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD8A</td>
				<td>4C 98 DC</td>
				<td class="fit">JMP $DC98</td><td rowspan="1"><p>JMP to OROW ($DC98) finish opening the
channel .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Put byte into the side sector</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUTSS</td><td class="fit">DD8D</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Push byte in .A cnto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD8E</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD90</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="1"><p>Load .A with the side sector buffer
number from SS,X ($CD,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD92</td>
				<td>4C FD CF</td>
				<td class="fit">JMP $CFFD</td><td rowspan="1"><p>JMP to PUTB1 ($CFFD) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCFLG</td><td class="fit">DD95</td>
				<td>90 06</td>
				<td class="fit">BCC $DD9D</td><td rowspan="1"><p>Set/Clear flag:
If carry flag clear, branch to CLRFLG</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETFLG</td><td class="fit">DD97</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Set flag:
Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD99</td>
				<td>15 EC</td>
				<td class="fit">ORA $EC,X</td><td rowspan="1"><p>OR the byte in .A with the file type in
FILTYP,X ($EC,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD9B</td>
				<td>D0 06</td>
				<td class="fit">BNE $DDA3</td><td rowspan="1"><p>If result is not $00, branch to CLRF10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLRFLG</td><td class="fit">DD9D</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Clear flag:
Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DD9F</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td><td rowspan="1"><p>EOR the byte in .A with $FF to flip all
the bits.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDA1</td>
				<td>35 EC</td>
				<td class="fit">AND $EC,X</td><td rowspan="1"><p>AND the byte in .A with the file type in
FILTYP,X ($EC,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLRF10</td><td class="fit">DDA3</td>
				<td>95 EC</td>
				<td class="fit">STA $EC,X</td><td rowspan="1"><p>Store the result in .A, as the new file
type in FILTYP,X ($EC,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDA5</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTFLG</td><td class="fit">DDA6</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Test flag:
Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDA8</td>
				<td>35 EC</td>
				<td class="fit">AND $EC,X</td><td rowspan="1"><p>AND the byte in .A with the file type
in FILTYP,X ($EC,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDAA</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test if this is a write job</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTWRT</td><td class="fit">DDAB</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDAE</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the buffer number to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDAF</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td><td rowspan="3"><p>Load .A with the last job code from
LSTJOB,X ($025B). AND the job code with
$F0 to mask off the drive bits, and
compare the result with $90 (write job
code). This sets the Z flag if this is
a write job.</p>
</td></tr>
				<tr><td></td><td class="fit">DDB2</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">DDB4</td>
				<td>C9 90</td>
				<td class="fit">CMP #$90</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDB6</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test for active files in LINDX tables</h1>
<pre><code>C=0 if file active X=ENTFND; Y=LINDX
C=1 if file inactive X=18</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTCHN</td><td class="fit">DDB7</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="1"><p>Load .X with $00 (secondary address)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTC20</td><td class="fit">DDB9</td>
				<td>86 71</td>
				<td class="fit">STX $71</td><td rowspan="1"><p>Save .X value into TEMP + 2 ($71) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDBB</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td><td rowspan="3"><p>Load .A with the buffer number for this
secondary address from LINTAB,X (022B,X)
If the buffer number is NOT $FF, branch
to TSTC40 for further testing.</p>
</td></tr>
				<tr><td></td><td class="fit">DDBE</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">DDC0</td>
				<td>D0 08</td>
				<td class="fit">BNE $DDCA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTC30</td><td class="fit">DDC2</td>
				<td>A6 71</td>
				<td class="fit">LDX $71</td><td rowspan="4"><p>Restore .X value from TEMP+2 ($71) and
increment it by 1. If the resulting .X
value is less than $10 (the maximum
sec. address - 2), loop back to TSTC20.</p>
</td></tr>
				<tr><td></td><td class="fit">DDC4</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">DDC5</td>
				<td>E0 10</td>
				<td class="fit">CPX #$10</td></tr>
				<tr><td></td><td class="fit">DDC7</td>
				<td>90 F0</td>
				<td class="fit">BCC $DDB9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTRTS</td><td class="fit">DDC9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTC40</td><td class="fit">DDCA</td>
				<td>86 71</td>
				<td class="fit">STX $71</td><td rowspan="1"><p>Save .X value into TEMP+2 ($71) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDCC</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td><td rowspan="2"><p>AND the buffer number in .A with $3F to
mask off the higher order bits and
transfer the result into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DDCE</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDCF</td>
				<td>B9 EC 00</td>
				<td class="fit">LDA $00EC,Y</td><td rowspan="3"><p>Load .A with the file type for this
secondary address from FILTYP,Y ($EC,Y) ,
AND it with $01 to mask off the
non-drive bits, and store the result in
TEMP+1 ($70) .</p>
</td></tr>
				<tr><td></td><td class="fit">DDD2</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">DDD4</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDD6</td>
				<td>AE 53 02</td>
				<td class="fit">LDX $0253</td><td rowspan="1"><p>Load .X with the index entry found
from ENTFND ($0253) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDD9</td>
				<td>B5 E2</td>
				<td class="fit">LDA $E2,X</td><td rowspan="4"><p>Load .A with the drive number for this
secondary address from FILDRV f X ($E2,X),
AND it with $01 to mask off the
non-drive bits, and compare the result
with the drive number in TEMP + 1 ($70) .
If the drives do not match, branch to
TSTC30.</p>
</td></tr>
				<tr><td></td><td class="fit">DDDB</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">DDDD</td>
				<td>C5 70</td>
				<td class="fit">CMP $70</td></tr>
				<tr><td></td><td class="fit">DDDF</td>
				<td>D0 E1</td>
				<td class="fit">BNE $DDC2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDE1</td>
				<td>B9 60 02</td>
				<td class="fit">LDA $0260,Y</td><td rowspan="3"><p>Drive numbers match, now check if the
directory entries match by comparing
the entry sector in DSEC. Y ($026C , Y) with
the one in ENTSEC,X ($D8,X). If they do
not match, branch to TSTC30.</p>
</td></tr>
				<tr><td></td><td class="fit">DDE4</td>
				<td>D5 D8</td>
				<td class="fit">CMP $D8,X</td></tr>
				<tr><td></td><td class="fit">DDE6</td>
				<td>D0 DA</td>
				<td class="fit">BNE $DDC2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDE8</td>
				<td>B9 66 02</td>
				<td class="fit">LDA $0266,Y</td><td rowspan="3"><p>Drive numbers are match, now check if
the directory entries match by comparing
the entry index in DIND,Y ($0266, Y) with
the one in ENTIND,X ($DD,X). If they do
not match, branch to TSTC30.</p>
</td></tr>
				<tr><td></td><td class="fit">DDEB</td>
				<td>D5 DD</td>
				<td class="fit">CMP $DD,X</td></tr>
				<tr><td></td><td class="fit">DDED</td>
				<td>D0 D3</td>
				<td class="fit">BNE $DDC2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDEF</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Clear the carry flag to indicate that
all tests passed and active file found.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDF0</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write out buffer if dirty</h1>
<pre><code>Note: a buffer is dirty if the copy in
      RAM has been modified so it does
      not match the copy on disk.</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCRUB</td><td class="fit">DDF1</td>
				<td>20 9E DF</td>
				<td class="fit">JSR $DF9E</td><td rowspan="1"><p>JSR to GAFLGS ($DF9E) to get active
buffer number and set in LBUSED.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDF4</td>
				<td>50 06</td>
				<td class="fit">BVC $DDFC</td><td rowspan="1"><p>If V flag not set, buffer is not dirty
so branch to SCR1 .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDF6</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write out. the
buffer to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DDF9</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCR1</td><td class="fit">DDFC</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Put TRACK and SECTOR into header</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETLNK</td><td class="fit">DDFD</td>
				<td>20 2B DE</td>
				<td class="fit">JSR $DE2B</td><td rowspan="2"><p>JSR to SETOO ($DE2B) to set up pointer
to header.</p>
</td></tr>
				<tr><td></td><td class="fit">DE00</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE02</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td><td rowspan="2"><p>Move desired track from TRACK ($80) to
(DIRBUF) ,Y; ($94), Y. Increment .Y</p>
</td></tr>
				<tr><td></td><td class="fit">DE04</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE05</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Move desired sector from SECTOR ($81) to
(DIRBUF) ,Y; ($94) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DE07</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE09</td>
				<td>4C 05 E1</td>
				<td class="fit">JMP $E105</td><td rowspan="1"><p>Terminate routine with a JMP to SDIRTY
($E105) to flag the buffer as dirty.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set TRACK &amp; SECTOR from link in buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETLNK</td><td class="fit">DE0C</td>
				<td>20 2B DE</td>
				<td class="fit">JSR $DE2B</td><td rowspan="1"><p>JSR to SETOO ($DE2B) to set up pointer
to header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE0F</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Move track link from (DIRBUF) ,Y; ( $94) ,Y
to TRACK ($80). Increment .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DE11</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
				<tr><td></td><td class="fit">DE13</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE14</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Move sector link from (DJRBUF),Y
($94) ,Y to SECTOR ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE16</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE18</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NULLNK</td><td class="fit">DE19</td>
				<td>20 2B DE</td>
				<td class="fit">JSR $DE2B</td><td rowspan="1"><p>Set track link to $00 and sector link to
the last non-zero character in buffer.
JSR to SETOO ($DE2B) to set up pointer
to header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE1C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Store $00 as track link in (DIRBUF) ,Y
($94) ,Y. Increment .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DE1E</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">DE20</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE21</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE23</td>
				<td>B5 C1</td>
				<td class="fit">LDA $C1,X</td><td rowspan="5"><p>Load .A with the pointer into the data
buffer from NR,X ($C1,X), decrement it
by 1, and store the result as the sector
link in (DIRBUF) ,Y; ($94) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DE25</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">DE26</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">DE27</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">DE28</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE2A</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up pointer to active buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SET00</td><td class="fit">DE2B</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE2E</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number (in .A) by
two (ASL) and transfer the result to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">DE2F</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE30</td>
				<td>B5 9A</td>
				<td class="fit">LDA $9A,X</td><td rowspan="2"><p>Move the hi byte of the buffer pointer
from BUFTAB+1,X ($9A,X) to DIRBUF+1 ( $95 )</p>
</td></tr>
				<tr><td></td><td class="fit">DE32</td>
				<td>85 95</td>
				<td class="fit">STA $95</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE34</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 as the lo byte of the buffer
pointer in DIRBUF ($94) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE36</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE38</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Zero .Y and exit routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DE3A</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set TRACK &amp; SECTOR from header</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CURBLK</td><td class="fit">DE3B</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETHDR</td><td class="fit">DE3E</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE41</td>
				<td>85 F9</td>
				<td class="fit">STA $F9</td><td rowspan="1"><p>Store the buffer number in JOBNUM ($F9)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE43</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number (in .A) by
two (ASL) and transfer the result to .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DE44</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE45</td>
				<td>B9 06 00</td>
				<td class="fit">LDA $0006,Y</td><td rowspan="2"><p>Move the track number from the header
table, HDRS,X ($0006, Y) to TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">DE48</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE4A</td>
				<td>B9 07 00</td>
				<td class="fit">LDA $0007,Y</td><td rowspan="2"><p>Move the sector number from the header
table, HDRS+1,X($0007,Y) to SECTOR($81).</p>
</td></tr>
				<tr><td></td><td class="fit">DE4D</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE4F</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Do read and write jobs</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTAB</td><td class="fit">DE50</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="3"><p>Store $90 (write job code) in CMD($024D)
and branch to SJ10 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE52</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
				<tr><td></td><td class="fit">DE55</td>
				<td>D0 28</td>
				<td class="fit">BNE $DE7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDAB</td><td class="fit">DE57</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="3"><p>Store $80 (read job code) in CMD($024D)
and branch to SJ10 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE59</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
				<tr><td></td><td class="fit">DE5C</td>
				<td>D0 21</td>
				<td class="fit">BNE $DE7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTOUT</td><td class="fit">DE5E</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="3"><p>Store $90 (write job code) in CMD($024D)
and branch to SJ20 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE60</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
				<tr><td></td><td class="fit">DE63</td>
				<td>D0 26</td>
				<td class="fit">BNE $DE8B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDIN</td><td class="fit">DE65</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="3"><p>Store $80 (read job code) in CMD($024D)
and branch to SJ20 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE67</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
				<tr><td></td><td class="fit">DE6A</td>
				<td>D0 1F</td>
				<td class="fit">BNE $DE8B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTSS</td><td class="fit">DE6C</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="3"><p>Store $90 (write job code) in CMD($024D)
and branch to RDS5 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE6E</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
				<tr><td></td><td class="fit">DE71</td>
				<td>D0 02</td>
				<td class="fit">BNE $DE75</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDSS</td><td class="fit">DE73</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="1"><p>Load .A with $80 (read job code)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDS5</td><td class="fit">DE75</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td><td rowspan="1"><p>Store job code (in .A) into CMD($024D).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE78</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE7A</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="3"><p>Load .A with the side sector buffer
number from SS,X ($CD,X) and tranfer it
to .X. If the SS buffer number &lt; 127,
branch to SJ30.</p>
</td></tr>
				<tr><td></td><td class="fit">DE7C</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">DE7D</td>
				<td>10 13</td>
				<td class="fit">BPL $DE92</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SJ10</td><td class="fit">DE7F</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>JSR to SETHDR ($D6D0) to set header from
TRACK and SECTOR.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE82</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT to get the active buffer
number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE85</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the buffer number to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE86</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Copy the drive number from DRVNUM ($7F)
to LSTJOB,X ($025B,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE88</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SJ20</td><td class="fit">DE8B</td>
				<td>20 15 E1</td>
				<td class="fit">JSR $E115</td><td rowspan="1"><p>JSR to CDIRTY ($E115) to clear the
dirty buffer flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE8E</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE91</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the buffer number to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE92</td>
				<td>4C 06 D5</td>
				<td class="fit">JMP $D506</td><td rowspan="1"><p>Continue routine with JMP to SETLJB
($D506) to set last used buffer.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set TRACK &amp; SECTOR from link in buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDLNK</td><td class="fit">DE95</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to SETPNT
($D4C8) to set the buffer pointer to the
first byte in the buffer (track link) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE97</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE9A</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="2"><p>JSR to GETBYT ($D137) to read the track
link. Store the link in TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">DE9D</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DE9F</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="2"><p>JSR to GETBYT ($D137) to read the sector
link. Store the link in SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">DEA2</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEA4</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Move bytes from one buffer to another</h1>
<pre><code>On entry: .A = number of bytes to move
	  .Y = from buffer #
	  .X = to buffer #</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">B0TOB0</td><td class="fit">DEA5</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save number of bytes to move (in .A)
onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEA6</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Zero TEMP ($6F) and TEMP+2 ($71).</p>
</td></tr>
				<tr><td></td><td class="fit">DEA8</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">DEAA</td>
				<td>85 71</td>
				<td class="fit">STA $71</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEAC</td>
				<td>B9 E0 FE</td>
				<td class="fit">LDA $FEE0,Y</td><td rowspan="2"><p>Move the hi byte of the from buffer
pointer from BUFIND,Y ($FEE0,Y) to
TEMP+1 ($70) .</p>
</td></tr>
				<tr><td></td><td class="fit">DEAF</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEB1</td>
				<td>BD E0 FE</td>
				<td class="fit">LDA $FEE0,X</td><td rowspan="2"><p>Move the hi byte of the to buffer
pointer from BUFIND,X ($FEE0,X) to
TEMP+3 ($72) .</p>
</td></tr>
				<tr><td></td><td class="fit">DEB4</td>
				<td>85 72</td>
				<td class="fit">STA $72</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">B02</td><td class="fit">DEB6</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the number-of-bytes-to-move from
the stack, transfer it into .Y, and
decrement .Y by 1 (0th byte is #1) .</p>
</td></tr>
				<tr><td></td><td class="fit">DEB7</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">DEB8</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEB9</td>
				<td>B1 6F</td>
				<td class="fit">LDA ($6F),Y</td><td rowspan="4"><p>Loop using. Y as a count-down index to
transfer bytes from (TEMP)Y to (TEMP+2) Y</p>
</td></tr>
				<tr><td></td><td class="fit">DEBB</td>
				<td>91 71</td>
				<td class="fit">STA ($71),Y</td></tr>
				<tr><td></td><td class="fit">DEBD</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">DEBE</td>
				<td>10 F9</td>
				<td class="fit">BPL $DEB9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEC0</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Clear buffer: (buffer # in .A)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLRBUF</td><td class="fit">DEC1</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="1"><p>Transfer buffer number from .A to .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEC2</td>
				<td>B9 E0 FE</td>
				<td class="fit">LDA $FEE0,Y</td><td rowspan="2"><p>Move the hi byte of the from buffer
pointer from BUFIND,Y ($FEE0,Y) to
TEMP + 1 ($70) .</p>
</td></tr>
				<tr><td></td><td class="fit">DEC5</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEC7</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Zero TEMP ($6F) and .Y</p>
</td></tr>
				<tr><td></td><td class="fit">DEC9</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">DECB</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CB10</td><td class="fit">DECC</td>
				<td>91 6F</td>
				<td class="fit">STA ($6F),Y</td><td rowspan="3"><p>Loop to fill buffer with $00 's.</p>
</td></tr>
				<tr><td></td><td class="fit">DECE</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">DECF</td>
				<td>D0 FB</td>
				<td class="fit">BNE $DECC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DED1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set side sector pointer to $00</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSSET</td><td class="fit">DED2</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and JSR to SSDIR ($DEDC) to set
DIRBUF with current SS pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">DED4</td>
				<td>20 DC DE</td>
				<td class="fit">JSR $DEDC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DED7</td>
				<td>A0 02</td>
				<td class="fit">LDY #$02</td><td rowspan="2"><p>Load .Y with $02. Load .A with the side
sector pointer from (DIRBUF) ,Y; ($94) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DED9</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEDB</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Use SS pointer to set DIRBUF</h1>
<p>On entry: .A = lo byte</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSDIR</td><td class="fit">DEDC</td>
				<td>85 94</td>
				<td class="fit">STA $94</td><td rowspan="1"><p>Store lo byte (in .A) into DIRBUF ($94)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEDE</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEE0</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="1"><p>Load .A with the side sector buffer
number from SS,X ($CD,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEE2</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer SS buffer number to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEE3</td>
				<td>BD E0 FE</td>
				<td class="fit">LDA $FEE0,X</td><td rowspan="2"><p>Copy hi byte of buffer pointer from
BUFIND ($FEE0) toDIRBUF+1 ($95).</p>
</td></tr>
				<tr><td></td><td class="fit">DEE6</td>
				<td>85 95</td>
				<td class="fit">STA $95</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEE8</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Use SS pointer to set DIRBUF &amp; BUFTAB</h1>
<p>On entry: .A = lo byte</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETSSP</td><td class="fit">DEE9</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save lo byte (in .A) onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEEA</td>
				<td>20 DC DE</td>
				<td class="fit">JSR $DEDC</td><td rowspan="1"><p>JSR to SSDIR ($DEDC) to set DIRBUF from
current SS pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEED</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>On return, .A contains the hi byte of
the SS buffer pointer. Save the hi byte
onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEEE</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the SS buffer number from .X
to .A, multiply it by two (ASL). and
transfer it back into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">DEEF</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">DEF0</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEF1</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull hi byte of SS buffer pointer off
the stack and store it in BUFTAB+1,X
($9A,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DEF2</td>
				<td>95 9A</td>
				<td class="fit">STA $9A,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEF4</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull lo byte of SS buffer pointer off
the stack and store it in BUFTAB ,X
($99, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">DEF5</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEF7</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Use SSNUM &amp; SSIND to set SS &amp; BUFTAB</h1>
<pre><code>On return V = all OK
	  V = 1 out of range</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSPOS</td><td class="fit">DEF8</td>
				<td>20 66 DF</td>
				<td class="fit">JSR $DF66</td><td rowspan="1"><p>JSR to SSTEST ($DF66) to test if SSNUM &amp;
SSIND are resident and within range.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEFB</td>
				<td>30 0E</td>
				<td class="fit">BMI $DF0B</td><td rowspan="1"><p>If N flag set, out of range so branch
to SSP10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEFD</td>
				<td>50 13</td>
				<td class="fit">BVC $DF12</td><td rowspan="1"><p>If V flag clear, it is in residence so
branch to SSP20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DEFF</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Since V flag set, maybe in range and
maybe not. Do another test:
Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF01</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="1"><p>Load .A with the side sector buffer
number from SS,X ($CD,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF03</td>
				<td>20 1B DF</td>
				<td class="fit">JSR $DF1B</td><td rowspan="1"><p>JSR to IBRD ($DF1B) to read in the SS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF06</td>
				<td>20 66 DF</td>
				<td class="fit">JSR $DF66</td><td rowspan="1"><p>JSR to SSTEST ($DF66) to test again.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF09</td>
				<td>10 07</td>
				<td class="fit">BPL $DF12</td><td rowspan="1"><p>If N flag clear, it is in range so
branch to SSP20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSP10</td><td class="fit">DF0B</td>
				<td>20 CB E1</td>
				<td class="fit">JSR $E1CB</td><td rowspan="1"><p>Out of range so JSR to SSEND ($E1CB) to
set SS &amp; BUFTAB to end of last record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF0E</td>
				<td>2C CE FE</td>
				<td class="fit">BIT $FECE</td><td rowspan="2"><p>BIT with ER1 ($FECE) to set flags and
terminate routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DF11</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSP20</td><td class="fit">DF12</td>
				<td>A5 D6</td>
				<td class="fit">LDA $D6</td><td rowspan="1"><p>Load .A with the SS pointer from SSIND
($D6) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF14</td>
				<td>20 E9 DE</td>
				<td class="fit">JSR $DEE9</td><td rowspan="1"><p>JSR to SETSSP ($DEE9) to set DIRBUF and
BUFTAB.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF17</td>
				<td>2C CD FE</td>
				<td class="fit">BIT $FECD</td><td rowspan="2"><p>BIT with ERO ($FECD) to set flags and
terminate routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DF1A</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Indirect block read/write:</h1>
<pre><code>On entry: .A = buffer number for R/W
	  .X = active buffer (LINDX)
 (DIRBUF) ,Y points to T&amp;S to be R/W</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IBRD</td><td class="fit">DF1B</td>
				<td>85 F9</td>
				<td class="fit">STA $F9</td><td rowspan="1"><p>Store buffer number (.A) in JOBNUM ($F9)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF1D</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80 (read job code) and
branch to IBOP.</p>
</td></tr>
				<tr><td></td><td class="fit">DF1F</td>
				<td>D0 04</td>
				<td class="fit">BNE $DF25</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IBWT</td><td class="fit">DF21</td>
				<td>85 F9</td>
				<td class="fit">STA $F9</td><td rowspan="1"><p>Store buffer number (.A) in JOBNUM ($F9)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF23</td>
				<td>A9 90</td>
				<td class="fit">LDA #$90</td><td rowspan="1"><p>Load .A with $90 (write job code)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IBOP</td><td class="fit">DF25</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Push the job code onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF26</td>
				<td>B5 EC</td>
				<td class="fit">LDA $EC,X</td><td rowspan="3"><p>Load .A with the file's drive number
from FILTYP,X ($EC,X), AND it with $01
to mask off the non-drive bits, and use
it to set the drive, DRVNUM ($7F)</p>
</td></tr>
				<tr><td></td><td class="fit">DF28</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">DF2A</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF2C</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the job code off the stack, OR it
with the drive number in DRVNUM ($7F) ,
and store the result in CMD ($024D) .</p>
</td></tr>
				<tr><td></td><td class="fit">DF2D</td>
				<td>05 7F</td>
				<td class="fit">ORA $7F</td></tr>
				<tr><td></td><td class="fit">DF2F</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF32</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="3"><p>Move the track number from (DIRBUF) ,Y
($94), Y to TRACK ($80). Increment .Y</p>
</td></tr>
				<tr><td></td><td class="fit">DF34</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
				<tr><td></td><td class="fit">DF36</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF37</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Move the sector number from (DIRBUF) ,Y
($94) ,Y to SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">DF39</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF3B</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="2"><p>Load .A with the buffer number from
JOBNUM ($F9) and JSR to SETH ($D6D3) to
set up the header.</p>
</td></tr>
				<tr><td></td><td class="fit">DF3D</td>
				<td>20 D3 D6</td>
				<td class="fit">JSR $D6D3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF40</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="2"><p>Load .X with the buffer number from
JOBNUM ($F9) and JMP to DOIT2 ($D593)
to do the job.</p>
</td></tr>
				<tr><td></td><td class="fit">DF42</td>
				<td>4C 93 D5</td>
				<td class="fit">JMP $D593</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get side sector pointers</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GSSPNT</td><td class="fit">DF45</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the active buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF47</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="1"><p>Load .A with the side sector buffer
number from SS,X ($CD,X)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF49</td>
				<td>4C EB D4</td>
				<td class="fit">JMP $D4EB</td><td rowspan="1"><p>JMP to SETDIR($D4EB) to set the DIRBUF
pointers .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Calculate side sectors</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCAL1</td><td class="fit">DF4C</td>
				<td>A9 78</td>
				<td class="fit">LDA #$78</td><td rowspan="1"><p>Load .A with $78, the number of side
sector pointers in a buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF4E</td>
				<td>20 5C DF</td>
				<td class="fit">JSR $DF5C</td><td rowspan="1"><p>JSR to ADDT12 ($DF5C) to add the number
of side sectors needed * 120.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSCALC</td><td class="fit">DF51</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement .X. If .X &gt;= $00, branch to
SCAL1.</p>
</td></tr>
				<tr><td></td><td class="fit">DF52</td>
				<td>10 F8</td>
				<td class="fit">BPL $DF4C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF54</td>
				<td>A5 72</td>
				<td class="fit">LDA $72</td><td rowspan="2"><p>Load .A with the number of SS indices
needed from T3($72) and multiply it
by 2 (ASL) since two bytes (track &amp; sec)
are needed for each index,</p>
</td></tr>
				<tr><td></td><td class="fit">DF56</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF57</td>
				<td>20 5C DF</td>
				<td class="fit">JSR $DF5C</td><td rowspan="1"><p>JSR to ADDT12 to add .A to T1 &amp; T2.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF5A</td>
				<td>A5 73</td>
				<td class="fit">LDA $73</td><td rowspan="1"><p>Load .A with the number of SS blocks
needed from T4($73)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDT12</td><td class="fit">DF5C</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Clear the carry flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF5D</td>
				<td>65 70</td>
				<td class="fit">ADC $70</td><td rowspan="2"><p>Add the contents of Tl ($70) to the
contents of the accumulator and store
the result back in Tl ($70).</p>
</td></tr>
				<tr><td></td><td class="fit">DF5F</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF61</td>
				<td>90 02</td>
				<td class="fit">BCC $DF65</td><td rowspan="1"><p>If carry is clear, branch to ADDRTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF63</td>
				<td>E6 71</td>
				<td class="fit">INC $71</td><td rowspan="1"><p>Increment the value in T2 ($71) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDRTS</td><td class="fit">DF65</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test SSNUM &amp; SSIND for range &amp; residence</h1>
<p>Flag meanings on exit:</p>
<pre><code> N | Range | V | Residence |    Err
---|-------|---|-----------|--------
 0 |  OK   | 0 |   YES     |    ER0
 1 | MAYBE | 1 |    NO     |    ER1
 1 |  BAD  | 0 |   YES     |    ER2
 1 |  BAD  | 1 |    NO     |    ER3
</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSTEST</td><td class="fit">DF66</td>
				<td>20 D2 DE</td>
				<td class="fit">JSR $DED2</td><td rowspan="1"><p>JSR to SSSET ($DED2) to set the pointer
to $00 and get the SS number (in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF69</td>
				<td>C5 D5</td>
				<td class="fit">CMP $D5</td><td rowspan="2"><p>Compare the SS number in .A with the
one in SSNUM ($D5). If they are not
equal, branch to ST20.</p>
</td></tr>
				<tr><td></td><td class="fit">DF6B</td>
				<td>D0 0E</td>
				<td class="fit">BNE $DF7B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF6D</td>
				<td>A4 D6</td>
				<td class="fit">LDY $D6</td><td rowspan="1"><p>Load .Y with the pointer into the SS
buffer from SSIND ($D6)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF6F</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A from (DIRBUF) ,Y; ($94), Y. If
this value is $00, the proper side
sector is not present so branch to ST10.</p>
</td></tr>
				<tr><td></td><td class="fit">DF71</td>
				<td>F0 04</td>
				<td class="fit">BEQ $DF77</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF73</td>
				<td>2C CD FE</td>
				<td class="fit">BIT $FECD</td><td rowspan="2"><p>BIT ERO ($FECD) to clear the N and V
flags. All OK so exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DF76</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ST10</td><td class="fit">DF77</td>
				<td>2C CF FE</td>
				<td class="fit">BIT $FECF</td><td rowspan="2"><p>Definitely out of range so BIT with E2
($FECF) and exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DF7A</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ST20</td><td class="fit">DF7B</td>
				<td>A5 D5</td>
				<td class="fit">LDA $D5</td><td rowspan="3"><p>Load .A with the SS number from SSNUM
($D5) and compare it with $06, the
number of side sector links. If the
value in SSNUM &gt; $06, branch to ST30.</p>
</td></tr>
				<tr><td></td><td class="fit">DF7D</td>
				<td>C9 06</td>
				<td class="fit">CMP #$06</td></tr>
				<tr><td></td><td class="fit">DF7F</td>
				<td>B0 0A</td>
				<td class="fit">BCS $DF8B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF81</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the SS number in .A by 2 (ASL)
and transfer the result into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">DF82</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF83</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>Load .A with $04, and store this value
in DIRBUF ($94), lo byte of the pointer,</p>
</td></tr>
				<tr><td></td><td class="fit">DF85</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF87</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A with the value from (DIRBUF) ,Y
($94) ,Y. If thisvalue is not $00,
branch to ST40.</p>
</td></tr>
				<tr><td></td><td class="fit">DF89</td>
				<td>D0 04</td>
				<td class="fit">BNE $DF8F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ST30</td><td class="fit">DF8B</td>
				<td>2C D0 FE</td>
				<td class="fit">BIT $FED0</td><td rowspan="2"><p>Way out of range so BIT with E3 ($FED0)
and exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">DF8E</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ST40</td><td class="fit">DF8F</td>
				<td>2C CE FE</td>
				<td class="fit">BIT $FECE</td><td rowspan="2"><p>Not in residence and range is unknown
so BIT with El ($FECE) and exit with RTS</p>
</td></tr>
				<tr><td></td><td class="fit">DF92</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get active buffer number</h1>
<pre><code>On exit: .A = active buffer number
	 .X = LINDX
     Flag N = 1 if no active buffer</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETACT</td><td class="fit">DF93</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF95</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="2"><p>Load .A with the buffer number from
BUF0,X ($A7,X). If bit 7 is not set,
this buffer is active so branch to GA1 .</p>
</td></tr>
				<tr><td></td><td class="fit">DF97</td>
				<td>10 02</td>
				<td class="fit">BPL $DF9B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF99</td>
				<td>B5 AE</td>
				<td class="fit">LDA $AE,X</td><td rowspan="1"><p>Load .A with the buffer number from
BUF1,X ($AE,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GA1</td><td class="fit">DF9B</td>
				<td>29 BF</td>
				<td class="fit">AND #$BF</td><td rowspan="1"><p>AND the buffer number with $BF to strip
the dirty bit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DF9D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get active buffer &amp; set LBUSED</h1>
<pre><code>On exit: .A = active buffer number
	 .X = LINDX
     Flag N = 1 if no active buffer
     Flag V = 1 if buffer is dirty</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GAFLGS</td><td class="fit">DF9E</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current buffer number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GA2</td><td class="fit">DFA0</td>
				<td>8E 57 02</td>
				<td class="fit">STX $0257</td><td rowspan="1"><p>Save buffer number into LBUSED ($0257) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFA3</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="2"><p>Load .A with the buffer number from
BUF0,X ($A7,X). If bit 7 is not set,
this buffer is active so branch to GA3 .</p>
</td></tr>
				<tr><td></td><td class="fit">DFA5</td>
				<td>10 09</td>
				<td class="fit">BPL $DFB0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFA7</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="4"><p>Transfer the buffer number from .X to
.A, clear the carry flag, add $07 (the
maximum number of channels + 1). and
store the result in LBUSED ($0257) .</p>
</td></tr>
				<tr><td></td><td class="fit">DFA8</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">DFA9</td>
				<td>69 07</td>
				<td class="fit">ADC #$07</td></tr>
				<tr><td></td><td class="fit">DFAB</td>
				<td>8D 57 02</td>
				<td class="fit">STA $0257</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFAE</td>
				<td>B5 AE</td>
				<td class="fit">LDA $AE,X</td><td rowspan="1"><p>Load .A with the buffer number from
BUF1,X ($AE,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GA3</td><td class="fit">DFB0</td>
				<td>85 70</td>
				<td class="fit">STA $70</td><td rowspan="1"><p>Store the buffer number in Tl ($70) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFB2</td>
				<td>29 1F</td>
				<td class="fit">AND #$1F</td><td rowspan="2"><p>AND the buffer number with $1F and BIT
the result with T1 ($70) to set the
N and V flags.</p>
</td></tr>
				<tr><td></td><td class="fit">DFB4</td>
				<td>24 70</td>
				<td class="fit">BIT $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFB6</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get a channel's inactive buffer number</h1>
<pre><code>On entry: LINDX = channel number
On exit: .A = buffer # or $FF if none</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETINA</td><td class="fit">DFB7</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFB9</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="2"><p>Load .A with the buffer number from
BUF0,X ($A7,X). If bit 7 is set, this
buffer is inactive so branch to GI10.</p>
</td></tr>
				<tr><td></td><td class="fit">DFBB</td>
				<td>30 02</td>
				<td class="fit">BMI $DFBF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFBD</td>
				<td>B5 AE</td>
				<td class="fit">LDA $AE,X</td><td rowspan="1"><p>Load .A with the buffer number from
BUF1,X ($AE,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GI10</td><td class="fit">DFBF</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td><td rowspan="1"><p>Compare the buffer number with $FF to
set the Z flag if inactive buffer found.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFC1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set the inactive buffer's buffer number</h1>
<p>On entry: .A = buffer number</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUTINA</td><td class="fit">DFC2</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFC4</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td><td rowspan="1"><p>OR the buffer number in .A with $80 to
set the inactive buffer bit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFC6</td>
				<td>B4 A7</td>
				<td class="fit">LDY $A7,X</td><td rowspan="2"><p>Load. Y with the buffer number from
BUF0,X ($A7,X). If bit 7 is clear, the
other buffer is the inactive one so
branch to PI1.</p>
</td></tr>
				<tr><td></td><td class="fit">DFC8</td>
				<td>10 03</td>
				<td class="fit">BPL $DFCD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFCA</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td><td rowspan="1"><p>This buffer is inactive so store new
buffer number in BUF0,X ($A7,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFCC</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PI1</td><td class="fit">DFCD</td>
				<td>95 AE</td>
				<td class="fit">STA $AE,X</td><td rowspan="1"><p>This buffer is inactive so store new
buffer number in BUF1,X ($AE,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFCF</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up next relative record</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTREC</td><td class="fit">DFD0</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Load .A with $20 (overflow flag) and
JSR to CLRFLG ($DD9D) to clear the
record overflow flag.</p>
</td></tr>
				<tr><td></td><td class="fit">DFD2</td>
				<td>20 9D DD</td>
				<td class="fit">JSR $DD9D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFD5</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="3"><p>Load .A with $80 (last record flag) and
JSR to TSTFLG ($DDA6) to test if we are
out beyond the last record. If not,
branch to NXTR40.</p>
</td></tr>
				<tr><td></td><td class="fit">DFD7</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
				<tr><td></td><td class="fit">DFDA</td>
				<td>D0 41</td>
				<td class="fit">BNE $E01D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFDC</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFDE</td>
				<td>F6 B5</td>
				<td class="fit">INC $B5,X</td><td rowspan="2"><p>Increment the lo byte of the record
counter in RECL,X ($B5,X). If the result
is not $00, branch to NXTR15.</p>
</td></tr>
				<tr><td></td><td class="fit">DFE0</td>
				<td>D0 02</td>
				<td class="fit">BNE $DFE4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFE2</td>
				<td>F6 BB</td>
				<td class="fit">INC $BB,X</td><td rowspan="1"><p>Increment the hi byte of the record
counter in RECH,X ($BB,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTR15</td><td class="fit">DFE4</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFE6</td>
				<td>B5 C1</td>
				<td class="fit">LDA $C1,X</td><td rowspan="1"><p>Load .A with the pointer to the next
record from NR,X ($C1,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFE8</td>
				<td>F0 2E</td>
				<td class="fit">BEQ $E018</td><td rowspan="1"><p>If the next record pointer is $00. there
is no next record so branch to NXTR45.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFEA</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="1"><p>JSR to GETPNT ($D4E8) to get the buffer
pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFED</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFEF</td>
				<td>D5 C1</td>
				<td class="fit">CMP $C1,X</td><td rowspan="2"><p>Compare the buffer pointer in .A with
the pointer in NR,X ($C1,X). If BT&lt;NR
then branch to NXTR20.</p>
</td></tr>
				<tr><td></td><td class="fit">DFF1</td>
				<td>90 03</td>
				<td class="fit">BCC $DFF6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFF3</td>
				<td>20 3C E0</td>
				<td class="fit">JSR $E03C</td><td rowspan="1"><p>Not in this buffer, must be in the next-
one so JSR to NRBUF ($E03C) to set up
the next. one.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTR20</td><td class="fit">DFF6</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFF8</td>
				<td>B5 C1</td>
				<td class="fit">LDA $C1,X</td><td rowspan="1"><p>Load .A with the pointer to the next
record from NR,X ($C1,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFFA</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td><td rowspan="1"><p>JSR to SETPNT ($D4C8) to advance to the
next record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFFD</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="1"><p>Load .A with the first byte of the
record from (BUFTAB,X) ($99, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">DFFF</td>
				<td>85 85</td>
				<td class="fit">STA $85</td><td rowspan="1"><p>Save the first data byte into DATA ($85)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E001</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Load .A with $20 (overflow flag) and
JSR to CLRFLG ($DD9D) to clear the
record overflow flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E003</td>
				<td>20 9D DD</td>
				<td class="fit">JSR $DD9D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E006</td>
				<td>20 04 E3</td>
				<td class="fit">JSR $E304</td><td rowspan="1"><p>JSR to ADDNR ($E304) to advance the NR
pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXOUT</td><td class="fit">E009</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="2"><p>Save the new value of NR (in .A) onto
the stack. If the carry flag is clear,
we have NOT crossed a block boundary so
branch to NXTR30.</p>
</td></tr>
				<tr><td></td><td class="fit">E00A</td>
				<td>90 28</td>
				<td class="fit">BCC $E034</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E00C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Load .A with $00 and JSR to DRDBYT
($D4F6) to read the track link of the
data block. If the track link is not
$00, this is not the last block so
branch to NXTR30.</p>
</td></tr>
				<tr><td></td><td class="fit">E00E</td>
				<td>20 F6 D4</td>
				<td class="fit">JSR $D4F6</td></tr>
				<tr><td></td><td class="fit">E011</td>
				<td>D0 21</td>
				<td class="fit">BNE $E034</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E013</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the new NR value off the stack and
compare it to $02. If it equals $02,
branch to NXTR50</p>
</td></tr>
				<tr><td></td><td class="fit">E014</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">E016</td>
				<td>F0 12</td>
				<td class="fit">BEQ $E02A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTR45</td><td class="fit">E018</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80 (last record flag) and
JSR to SETFLG ($DDD97) to set this flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E01A</td>
				<td>20 97 DD</td>
				<td class="fit">JSR $DD97</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTR40</td><td class="fit">E01D</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>JSR to GETPRE ($D12F) to get pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E020</td>
				<td>B5 99</td>
				<td class="fit">LDA $99,X</td><td rowspan="2"><p>Move the data byte from BUFTAB,X ($99, X)
to LSTCHR ($0244.</p>
</td></tr>
				<tr><td></td><td class="fit">E022</td>
				<td>99 44 02</td>
				<td class="fit">STA $0244,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E025</td>
				<td>A9 0D</td>
				<td class="fit">LDA #$0D</td><td rowspan="2"><p>Store $0D (carriage return) in DATA($85)</p>
</td></tr>
				<tr><td></td><td class="fit">E027</td>
				<td>85 85</td>
				<td class="fit">STA $85</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E029</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTR50</td><td class="fit">E02A</td>
				<td>20 35 E0</td>
				<td class="fit">JSR $E035</td><td rowspan="1"><p>JSR to NXTR35 ($E035) to store NR value</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E02D</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="3"><p>Load .X with the channel number from
LINDX ($82). Store $00 in NR,X ($C1,X).</p>
</td></tr>
				<tr><td></td><td class="fit">E02F</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">E031</td>
				<td>95 C1</td>
				<td class="fit">STA $C1,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E033</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTR30</td><td class="fit">E034</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the new NR value off the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTR35</td><td class="fit">E035</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="2"><p>Load .X with the channel number from
LINDX ($82). Store the byte in .A into
NR,X ($C1,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">E037</td>
				<td>95 C1</td>
				<td class="fit">STA $C1,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E039</td>
				<td>4C 6E E1</td>
				<td class="fit">JMP $E16E</td><td rowspan="1"><p>Terminate routine with a JMP to SETLST
($E16E) to set. the pointer to the last
character.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up next record in buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NRBUF</td><td class="fit">E03C</td>
				<td>20 D3 D1</td>
				<td class="fit">JSR $D1D3</td><td rowspan="1"><p>JSR to SETDRN ($D1D3) to set drive
number to agree with the last job.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E03F</td>
				<td>20 95 DE</td>
				<td class="fit">JSR $DE95</td><td rowspan="1"><p>JSR to RDLNK ($DE95) to set TRACK and
SECTOR from the track &amp; sector link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E042</td>
				<td>20 9E DF</td>
				<td class="fit">JSR $DF9E</td><td rowspan="2"><p>JSR to GAFLGS ($DF9E) to test, if the
current buffer is dirty (changed). If
V flag clear, it is clean; branch to
NRBU50 so we don't write it out.</p>
</td></tr>
				<tr><td></td><td class="fit">E045</td>
				<td>50 16</td>
				<td class="fit">BVC $E05D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E047</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write it out.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E04A</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E04D</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Load .A with $02 and JSR to SETPNT
($D4C8) to set the pointer to point to
the first data byte in the new sector.</p>
</td></tr>
				<tr><td></td><td class="fit">E04F</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E052</td>
				<td>20 AB DD</td>
				<td class="fit">JSR $DDAB</td><td rowspan="2"><p>JSR to TSTWRT ($DDAB) to test if the
last job was a write. If it was not a
write job, branch to NRBU20 ($E07B)
since buffer is OK.</p>
</td></tr>
				<tr><td></td><td class="fit">E055</td>
				<td>D0 24</td>
				<td class="fit">BNE $E07B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E057</td>
				<td>20 57 DE</td>
				<td class="fit">JSR $DE57</td><td rowspan="1"><p>JSR to RDAB ($DE57) to read in needed
buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E05A</td>
				<td>4C 99 D5</td>
				<td class="fit">JMP $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
read job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NRBU50</td><td class="fit">E05D</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E060</td>
				<td>20 AB DD</td>
				<td class="fit">JSR $DDAB</td><td rowspan="2"><p>JSR to TSTWRT ($DDAB) to test if the
last job was a write. If it was not a
write job, branch to NRBU70.</p>
</td></tr>
				<tr><td></td><td class="fit">E063</td>
				<td>D0 06</td>
				<td class="fit">BNE $E06B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E065</td>
				<td>20 57 DE</td>
				<td class="fit">JSR $DE57</td><td rowspan="1"><p>JSR to RDAB ($DE57) to read in needed
buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E068</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
read job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NRBU70</td><td class="fit">E06B</td>
				<td>20 95 DE</td>
				<td class="fit">JSR $DE95</td><td rowspan="1"><p>JSR to RDLNK ($DE95) to set TRACK and
SECTOR from the track &amp; sector link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E06E</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A with the track link from TRACK
($80). If track link is $00, this is the
last block with no double buffering
needed so branch to NRBU20.</p>
</td></tr>
				<tr><td></td><td class="fit">E070</td>
				<td>F0 09</td>
				<td class="fit">BEQ $E07B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E072</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E075</td>
				<td>20 57 DE</td>
				<td class="fit">JSR $DE57</td><td rowspan="1"><p>JSR to RDAB ($DE5E) to start a read job
for the inactive buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E078</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NRBU20</td><td class="fit">E07B</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Put relative record into buffer</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELPUT</td><td class="fit">E07C</td>
				<td>20 05 E1</td>
				<td class="fit">JSR $E105</td><td rowspan="1"><p>JSR to SDIRTY ($E105) to flag buffer as
dirty (RAM version changed) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E07F</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E082</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number (in .A) by
two (ASL) and transfer the result to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">E083</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E084</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="2"><p>Copy the data byte from DATA ($85) into
the buffer at (BUFTAB,X) ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">E086</td>
				<td>81 99</td>
				<td class="fit">STA ($99,X)</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E088</td>
				<td>B4 99</td>
				<td class="fit">LDY $99,X</td><td rowspan="3"><p>Load .Y with the lo byte of the pointer
BUFTAB,X and increment the pointer in
. Y by 1. If the new pointer value is NOT
$00, branch to RELP05.</p>
</td></tr>
				<tr><td></td><td class="fit">E08A</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">E08B</td>
				<td>D0 09</td>
				<td class="fit">BNE $E096</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E08D</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E08F</td>
				<td>B9 C1 00</td>
				<td class="fit">LDA $00C1,Y</td><td rowspan="2"><p>Load .A with the next record pointer
from NR,Y. If this value is $00, branch
to RELP0 7.</p>
</td></tr>
				<tr><td></td><td class="fit">E092</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $E09E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELP06</td><td class="fit">E094</td>
				<td>A0 02</td>
				<td class="fit">LDY #$02</td><td rowspan="1"><p>Load .Y with $02.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELP05</td><td class="fit">E096</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer the contents of .Y to .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E097</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the channel number from
LINDX ($82).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E099</td>
				<td>D9 C1 00</td>
				<td class="fit">CMP $00C1,Y</td><td rowspan="2"><p>Compare the contents of .A to NR,Y
($C1,Y) to test if NR = pointer. If they
are not equal, NR is not a pointer so
branch to RELP10 to set new pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">E09C</td>
				<td>D0 05</td>
				<td class="fit">BNE $E0A3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELP07</td><td class="fit">E09E</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Load .A with $20 (the overflow flag)
and JMP to SETFLG ($DD9 7) to set the
overflow flag and exit.</p>
</td></tr>
				<tr><td></td><td class="fit">E0A0</td>
				<td>4C 97 DD</td>
				<td class="fit">JMP $DD97</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELP10</td><td class="fit">E0A3</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td><td rowspan="2"><p>Increment the lo byte of the pointer
BUFTAB,X ($99, X). If the result is not
$00, we don't need the next buffer so
branch to RELP20.</p>
</td></tr>
				<tr><td></td><td class="fit">E0A5</td>
				<td>D0 03</td>
				<td class="fit">BNE $E0AA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0A7</td>
				<td>20 3C E0</td>
				<td class="fit">JSR $E03C</td><td rowspan="1"><p>JSR to NRBUF($E03C) to get next buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RELP20</td><td class="fit">E0AA</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write out relative records</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTREL</td><td class="fit">E0AB</td>
				<td>A9 A0</td>
				<td class="fit">LDA #$A0</td><td rowspan="2"><p>Load .A with $A0 (last record flag +
overflow flag) and JSR to TSTFLG ($DDA6)
to check for last record &amp; overflow.</p>
</td></tr>
				<tr><td></td><td class="fit">E0AD</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0B0</td>
				<td>D0 27</td>
				<td class="fit">BNE $E0D9</td><td rowspan="1"><p>If Z flag clear, some flag is set so
branch to WR50.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR10</td><td class="fit">E0B2</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="2"><p>Load .A with the byte from DATA ($85)
and JSR to RELPUT ($E07C) to put the
data into the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E0B4</td>
				<td>20 7C E0</td>
				<td class="fit">JSR $E07C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR20</td><td class="fit">E0B7</td>
				<td>A5 F8</td>
				<td class="fit">LDA $F8</td><td rowspan="2"><p>Load .A with the EOIFLG ($F8). If it
equals $00, an EOI was NOT sent so
branch to WR40.</p>
</td></tr>
				<tr><td></td><td class="fit">E0B9</td>
				<td>F0 0D</td>
				<td class="fit">BEQ $E0C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0BB</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR30</td><td class="fit">E0BC</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Load .A with $20 (overflow flag) and
JSR to TSTFLG ($DDA6) to test for an
overflow error.</p>
</td></tr>
				<tr><td></td><td class="fit">E0BE</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0C1</td>
				<td>F0 05</td>
				<td class="fit">BEQ $E0C8</td><td rowspan="1"><p>If Z set, no error so branch to WR40.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0C3</td>
				<td>A9 51</td>
				<td class="fit">LDA #$51</td><td rowspan="2"><p>Overflow error so load .A with $51
(recover flag) and store it in ERWORD
($026C) to flag the error.</p>
</td></tr>
				<tr><td></td><td class="fit">E0C5</td>
				<td>8D 6C 02</td>
				<td class="fit">STA $026C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR40</td><td class="fit">E0C8</td>
				<td>20 F3 E0</td>
				<td class="fit">JSR $E0F3</td><td rowspan="1"><p>JSR to CLREC ($E0F3) to clear the rest
of the record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0CB</td>
				<td>20 53 E1</td>
				<td class="fit">JSR $E153</td><td rowspan="1"><p>JSR to RD40 ($E153) to set up for the
next record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0CE</td>
				<td>AD 6C 02</td>
				<td class="fit">LDA $026C</td><td rowspan="2"><p>Load .A from ERWORD ($026C). If it is
$00, no errors so branch to WR45.</p>
</td></tr>
				<tr><td></td><td class="fit">E0D1</td>
				<td>F0 03</td>
				<td class="fit">BEQ $E0D6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0D3</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td><td rowspan="1"><p>Abort with a JMP to CMDERR ($C1C8)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR45</td><td class="fit">E0D6</td>
				<td>4C BC E6</td>
				<td class="fit">JMP $E6BC</td><td rowspan="1"><p>Terminate with a JMP to OKERR ($E6BC) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR50</td><td class="fit">E0D9</td>
				<td>29 80</td>
				<td class="fit">AND #$80</td><td rowspan="2"><p>AND the error flag in .A with $80 (the
last record flag). If the result is not
$00, the last record flag was set so
branch to WR60 to add to file.</p>
</td></tr>
				<tr><td></td><td class="fit">E0DB</td>
				<td>D0 05</td>
				<td class="fit">BNE $E0E2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0DD</td>
				<td>A5 F8</td>
				<td class="fit">LDA $F8</td><td rowspan="2"><p>Load .A with the EOIFLG ($F8). If this
is $00, an EOI was not sent so branch
to WR3 0.</p>
</td></tr>
				<tr><td></td><td class="fit">E0DF</td>
				<td>F0 DB</td>
				<td class="fit">BEQ $E0BC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR51</td><td class="fit">E0E1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WR60</td><td class="fit">E0E2</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="2"><p>Load .A with the data byte from DATA
($85) and push it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E0E4</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0E5</td>
				<td>20 1C E3</td>
				<td class="fit">JSR $E31C</td><td rowspan="2"><p>JSR to ADDREL ($E31C) to add to the
relative file.</p>
</td></tr>
				<tr><td></td><td class="fit">E0E8</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0E9</td>
				<td>85 85</td>
				<td class="fit">STA $85</td><td rowspan="1"><p>Pull the data byte off the stack and
put it back in DATA ($85).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0EB</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80 (last record flag) and
JSR to CLRFLG ($DD9D) to clear the flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E0ED</td>
				<td>20 9D DD</td>
				<td class="fit">JSR $DD9D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0F0</td>
				<td>4C B2 E0</td>
				<td class="fit">JMP $E0B2</td><td rowspan="1"><p>JMP to WR10.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Clear rest of relative record</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLREC</td><td class="fit">E0F3</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Load .A with $20 (overflow flag) and
JSR to TSTFLG ($DDA6) to test the flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E0F5</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0F8</td>
				<td>D0 0A</td>
				<td class="fit">BNE $E104</td><td rowspan="1"><p>If Z flag not set, overflow has occured
so branch to CLR10 to exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E0FA</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Set DATA ($85) to $00 and JSR to RELPUT
($E07C) to put a null byte in the buffer</p>
</td></tr>
				<tr><td></td><td class="fit">E0FC</td>
				<td>85 85</td>
				<td class="fit">STA $85</td></tr>
				<tr><td></td><td class="fit">E0FE</td>
				<td>20 7C E0</td>
				<td class="fit">JSR $E07C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E101</td>
				<td>4C F3 E0</td>
				<td class="fit">JMP $E0F3</td><td rowspan="1"><p>Loop with a JMP to CLREC ($E0F3).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLR10</td><td class="fit">E104</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set buffer dirty flag</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SDIRTY</td><td class="fit">E105</td>
				<td>A9 40</td>
				<td class="fit">LDA #$40</td><td rowspan="1"><p>Load .A with $40 (dirty flag) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E107</td>
				<td>20 97 DD</td>
				<td class="fit">JSR $DD97</td><td rowspan="1"><p>JSR to SETFLG ($DD97) to set flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E10A</td>
				<td>20 9E DF</td>
				<td class="fit">JSR $DF9E</td><td rowspan="1"><p>JSR to GAFLGS ($DF9E) to get active
buffer number in .A and set flags.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E10D</td>
				<td>09 40</td>
				<td class="fit">ORA #$40</td><td rowspan="1"><p>OR the contents of .A with $40 to set
the dirty flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E10F</td>
				<td>AE 57 02</td>
				<td class="fit">LDX $0257</td><td rowspan="1"><p>Load .X with the number of the last
buffer used from LBUSED ($0257).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E112</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td><td rowspan="1"><p>Store the content of .A as the buffer
number in BUF0,X ($A7,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E114</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Clear buffer dirty flag</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CDIRTY</td><td class="fit">E115</td>
				<td>20 9E DF</td>
				<td class="fit">JSR $DF9E</td><td rowspan="1"><p>JSR to GAFLGS ($DF9E) to get active
buffer number and set flags.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E118</td>
				<td>29 BF</td>
				<td class="fit">AND #$BF</td><td rowspan="1"><p>AND the contents of .A with $BF to clear
the dirty flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E11A</td>
				<td>AE 57 02</td>
				<td class="fit">LDX $0257</td><td rowspan="1"><p>Load .X with the number of the last.
buffer used from LBUSED ($0257).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E11D</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td><td rowspan="1"><p>Store the content of .A as the buffer
number in BUF0,X ($A7,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E11F</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Read relative record</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RDREL</td><td class="fit">E120</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80 (last record flag) and
JSR to TSTFLG ($DDA6) to test the flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E122</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E125</td>
				<td>D0 37</td>
				<td class="fit">BNE $E15E</td><td rowspan="1"><p>If Z flag not set, last, record error has
occured so branch to RD05.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD10</td><td class="fit">E127</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>JSR to GETPRE ($D12F) to set pointers to
existing buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E12A</td>
				<td>B5 99</td>
				<td class="fit">LDA $99,X</td><td rowspan="1"><p>Load .A with the lo byte of the buffer
pointer from BUFTAB,X ($99, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E12C</td>
				<td>D9 44 02</td>
				<td class="fit">CMP $0244,Y</td><td rowspan="2"><p>Compare this value to the contents of
LSTCHR,Y ($0244). If they are equal,
branch to RD40 because we want the next
record not the last one.</p>
</td></tr>
				<tr><td></td><td class="fit">E12F</td>
				<td>F0 22</td>
				<td class="fit">BEQ $E153</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E131</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td><td rowspan="2"><p>Increment the buffer pointer in BUFTAB,X
($99, X). If the result is not equal to
$00, we don't need the next buffer so
branch to RD20.</p>
</td></tr>
				<tr><td></td><td class="fit">E133</td>
				<td>D0 06</td>
				<td class="fit">BNE $E13B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E135</td>
				<td>20 3C E0</td>
				<td class="fit">JSR $E03C</td><td rowspan="1"><p>JSR to NRBUF ($E03C) to read in the
next buffer of relative records.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD15</td><td class="fit">E138</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>JSR to GETPRE ($D12F) to set pointers to
existing buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD20</td><td class="fit">E13B</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="1"><p>Load .A with the data byte from
(BUFTAB,X) ; ($99, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD25</td><td class="fit">E13D</td>
				<td>99 3E 02</td>
				<td class="fit">STA $023E,Y</td><td rowspan="1"><p>Store the data byte in CHNDAT, Y ($023E, Y)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E140</td>
				<td>A9 89</td>
				<td class="fit">LDA #$89</td><td rowspan="2"><p>Load .A with $89 (random access - ready)
and store this as the channel status in
CHNRDY,Y ($F2,Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">E142</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E145</td>
				<td>B5 99</td>
				<td class="fit">LDA $99,X</td><td rowspan="3"><p>Load the pointer from BUFTAB,X ($99, Y)
and compare it to the pointer to the
last character in the record from
LSTCHR,Y ($0244, Y). If they are equal,
branch to RD30 to send EOI .</p>
</td></tr>
				<tr><td></td><td class="fit">E147</td>
				<td>D9 44 02</td>
				<td class="fit">CMP $0244,Y</td></tr>
				<tr><td></td><td class="fit">E14A</td>
				<td>F0 01</td>
				<td class="fit">BEQ $E14D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E14C</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD30</td><td class="fit">E14D</td>
				<td>A9 81</td>
				<td class="fit">LDA #$81</td><td rowspan="2"><p>Load .A with $81 (random access - EOI)
and store this as the channel status in
CHNRDY,Y ($F2,Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">E14F</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E152</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD40</td><td class="fit">E153</td>
				<td>20 D0 DF</td>
				<td class="fit">JSR $DFD0</td><td rowspan="1"><p>JSR to NXTREC ($DFD0) to get the next
record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E156</td>
				<td>20 2F D1</td>
				<td class="fit">JSR $D12F</td><td rowspan="1"><p>JSR to GETPRE ($D12F) to set pointers to
existing buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E159</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the byte from DATA ($85).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E15B</td>
				<td>4C 3D E1</td>
				<td class="fit">JMP $E13D</td><td rowspan="1"><p>JMP to RD25 to carry on.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RD05</td><td class="fit">E15E</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>No record error so load .X with the
channel number from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E160</td>
				<td>A9 0D</td>
				<td class="fit">LDA #$0D</td><td rowspan="2"><p>Store $0D (carriage return) as the data
byte in CHNDAT, X ($023E,X).</p>
</td></tr>
				<tr><td></td><td class="fit">E162</td>
				<td>9D 3E 02</td>
				<td class="fit">STA $023E,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E165</td>
				<td>A9 81</td>
				<td class="fit">LDA #$81</td><td rowspan="2"><p>Load .A with $81 (random access - EOI)
and store this as the channel status in
CHNRDY,Y ($F2,Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">E167</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E169</td>
				<td>A9 50</td>
				<td class="fit">LDA #$50</td><td rowspan="2"><p>Load .A with $50 (no record error) and
abort with a JMP to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">E16B</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETLST</td><td class="fit">E16E</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Set pointer to last character in record:
Load .X with the channel number from
LINDX ($82)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E170</td>
				<td>B5 C1</td>
				<td class="fit">LDA $C1,X</td><td rowspan="2"><p>Copy the next record pointer from NR,X
($C1,X) into Rl ($87) .</p>
</td></tr>
				<tr><td></td><td class="fit">E172</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E174</td>
				<td>C6 87</td>
				<td class="fit">DEC $87</td><td rowspan="3"><p>Decrement the pointer in Rl ($87) by 1
and compare the result to $02, the
pointer to the first data byte in the
sector. If the pointer does not equal
$02, branch to SETL01.</p>
</td></tr>
				<tr><td></td><td class="fit">E176</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">E178</td>
				<td>D0 04</td>
				<td class="fit">BNE $E17E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E17A</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF into Rl ($87) so it points to
the last byte in a sector.</p>
</td></tr>
				<tr><td></td><td class="fit">E17C</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETL01</td><td class="fit">E17E</td>
				<td>B5 C7</td>
				<td class="fit">LDA $C7,X</td><td rowspan="2"><p>Copy the record size from RS,X ($C7,X)
into R2 ($88) .</p>
</td></tr>
				<tr><td></td><td class="fit">E180</td>
				<td>85 88</td>
				<td class="fit">STA $88</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E182</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="5"><p>JSR to GETPNT ($D4E8) to get the pointer
into the active buffer (returned in .A)
Compare this value with the pointer in
R1 ($87). If Rl &gt;= .A branch to SETL10.</p>
</td></tr>
				<tr><td></td><td class="fit">E185</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td></tr>
				<tr><td></td><td class="fit">E187</td>
				<td>C5 87</td>
				<td class="fit">CMP $87</td></tr>
				<tr><td></td><td class="fit">E189</td>
				<td>90 19</td>
				<td class="fit">BCC $E1A4</td></tr>
				<tr><td></td><td class="fit">E18B</td>
				<td>F0 17</td>
				<td class="fit">BEQ $E1A4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E18D</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E190</td>
				<td>20 B2 E1</td>
				<td class="fit">JSR $E1B2</td><td rowspan="2"><p>JSR to FNDLST ($E1B2) to find the last
character. On return, if carry is clear,
branch to SETL05.</p>
</td></tr>
				<tr><td></td><td class="fit">E193</td>
				<td>90 08</td>
				<td class="fit">BCC $E19D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E195</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E197</td>
				<td>9D 44 02</td>
				<td class="fit">STA $0244,X</td><td rowspan="1"><p>Store the character in .A into LSTCHR,X
($0244, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E19A</td>
				<td>4C 1E CF</td>
				<td class="fit">JMP $CF1E</td><td rowspan="1"><p>JMP to DBLBUF ($CF1E) to toggle the
active and inactive buffers and exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETL05</td><td class="fit">E19D</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1A0</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF into Rl ($87) so it points to
the last byte in a sector.</p>
</td></tr>
				<tr><td></td><td class="fit">E1A2</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETL10</td><td class="fit">E1A4</td>
				<td>20 B2 E1</td>
				<td class="fit">JSR $E1B2</td><td rowspan="2"><p>JSR to FNDLST ($E1B2) to find the last
non-zero character in the record. On
return, if carry set, branch to SETL40.</p>
</td></tr>
				<tr><td></td><td class="fit">E1A7</td>
				<td>B0 03</td>
				<td class="fit">BCS $E1AC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1A9</td>
				<td>20 E8 D4</td>
				<td class="fit">JSR $D4E8</td><td rowspan="1"><p>JSR to GETPNT ($D4E8) to get the pointer
into the active buffer (returned in .A)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETL40</td><td class="fit">E1AC</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1AE</td>
				<td>9D 44 02</td>
				<td class="fit">STA $0244,X</td><td rowspan="1"><p>Store the character in .A into LSTCHR,X
($0244, X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1B1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find last non-zero character in record</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDLST</td><td class="fit">E1B2</td>
				<td>20 2B DE</td>
				<td class="fit">JSR $DE2B</td><td rowspan="1"><p>JSR to SET00 ($DE2B) to set up pointer
to start of buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1B5</td>
				<td>A4 87</td>
				<td class="fit">LDY $87</td><td rowspan="1"><p>Load .Y with the offset to start at
from Rl ($87) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDL10</td><td class="fit">E1B7</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A with the data byte from the
buffer at (DIRBUF) ,Y; ($94), Y. If the
data byte is not $00, branch to FNDL20.</p>
</td></tr>
				<tr><td></td><td class="fit">E1B9</td>
				<td>D0 0D</td>
				<td class="fit">BNE $E1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1BB</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="3"><p>Decrement the pointer in .Y. If the
resulting pointer is less than or equal
to $02, branch to FNDL30 since the
start of the record is not in here.</p>
</td></tr>
				<tr><td></td><td class="fit">E1BC</td>
				<td>C0 02</td>
				<td class="fit">CPY #$02</td></tr>
				<tr><td></td><td class="fit">E1BE</td>
				<td>90 04</td>
				<td class="fit">BCC $E1C4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1C0</td>
				<td>C6 88</td>
				<td class="fit">DEC $88</td><td rowspan="2"><p>Decrement the record size in R2 ($88) .
If R2 has not counted down to $00 yet,
branch FNDL10.</p>
</td></tr>
				<tr><td></td><td class="fit">E1C2</td>
				<td>D0 F3</td>
				<td class="fit">BNE $E1B7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDL30</td><td class="fit">E1C4</td>
				<td>C6 88</td>
				<td class="fit">DEC $88</td><td rowspan="3"><p>Decrement the record size in R2 ($88) .
Clear the carry flag to indicate that
the record was not found here and exit
from the routine with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">E1C6</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">E1C7</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDL20</td><td class="fit">E1C8</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Found the last non-zero character so
transfer the pointer from .Y to .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1C9</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>Set the carry flag to indicate it was
found here and terminate with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">E1CA</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
				<tr><td></td><td class="fit">E1CB</td>
				<td>20 D2 DE</td>
				<td class="fit">JSR $DED2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSEND</td><td class="fit">E1CE</td>
				<td>85 D5</td>
				<td class="fit">STA $D5</td><td rowspan="1"><p>Set SS &amp; BUFTAB to end of last record:
JSR to SSSET ($DED2) to set the SS
pointer to $00.
Store the side sector number returned
in .A into SSNUM ($D5) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1D0</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>Set the lo byte of the pointer in
DIRBUF ($94) to $04.</p>
</td></tr>
				<tr><td></td><td class="fit">E1D2</td>
				<td>85 94</td>
				<td class="fit">STA $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1D4</td>
				<td>A0 0A</td>
				<td class="fit">LDY #$0A</td><td rowspan="2"><p>Load .Y with $A0 (the side sector offset,
less 6) and branch to SE20 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">E1D6</td>
				<td>D0 04</td>
				<td class="fit">BNE $E1DC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SE10</td><td class="fit">E1D8</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="3"><p>Decrement pointer in. Y by 2. If the
result is less than $00, branch to BREAK</p>
</td></tr>
				<tr><td></td><td class="fit">E1D9</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">E1DA</td>
				<td>30 26</td>
				<td class="fit">BMI $E202</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SE20</td><td class="fit">E1DC</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Look for the last SS number by loading
.A from (DIRBUF) ,Y; ($94) ,Y. If the
byte is $00, we have not found it yet
so branch back to SE10.</p>
</td></tr>
				<tr><td></td><td class="fit">E1DE</td>
				<td>F0 F8</td>
				<td class="fit">BEQ $E1D8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1E0</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer the pointer in .Y into .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1E1</td>
				<td>4A</td>
				<td class="fit">LSR</td><td rowspan="3"><p>Multiply the pointer in .A by 2 (ASL)
and compare the result to the side
sector number in SSNUM ($D5). If they
are equal, this is the last SS number
so branch to SE30.</p>
</td></tr>
				<tr><td></td><td class="fit">E1E2</td>
				<td>C5 D5</td>
				<td class="fit">CMP $D5</td></tr>
				<tr><td></td><td class="fit">E1E4</td>
				<td>F0 09</td>
				<td class="fit">BEQ $E1EF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1E6</td>
				<td>85 D5</td>
				<td class="fit">STA $D5</td><td rowspan="1"><p>Store the SS number in .A into SSNUM
($D5) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1E8</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1EA</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="2"><p>Load .A with the side sector from
SS,X ($CD,X) and JSR to IBRD ($DF1B)
to do an indirect block read of the
last side sector.</p>
</td></tr>
				<tr><td></td><td class="fit">E1EC</td>
				<td>20 1B DF</td>
				<td class="fit">JSR $DF1B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SE30</td><td class="fit">E1EF</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Zero .Y and set the lo byte of the
pointer in DIRBUF ($94) to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">E1F1</td>
				<td>84 94</td>
				<td class="fit">STY $94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1F3</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A with track link from (DIRBUF) ,Y
($94), Y. If the link is not $00, branch
to BREAK.</p>
</td></tr>
				<tr><td></td><td class="fit">E1F5</td>
				<td>D0 0B</td>
				<td class="fit">BNE $E202</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1F7</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1F8</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="5"><p>Load .A with sector link from (DIRBUF) ,Y
($94) ,Y. This points to the last good
byte in the buffer. Transfer the pointer
to .Y, decrement it by 1, store it in
SSIND ($D6). and transfer it back to .A.</p>
</td></tr>
				<tr><td></td><td class="fit">E1FA</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">E1FB</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">E1FC</td>
				<td>84 D6</td>
				<td class="fit">STY $D6</td></tr>
				<tr><td></td><td class="fit">E1FE</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E1FF</td>
				<td>4C E9 DE</td>
				<td class="fit">JMP $DEE9</td><td rowspan="1"><p>JMP to SETSSP ($DEE9) to set DIRBUF and
BUFTAB with current SS pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BREAK</td><td class="fit">E202</td>
				<td>A9 67</td>
				<td class="fit">LDA #$67</td><td rowspan="2"><p>Load .A with $67 to indicate a SYSTEM
TRACK OR SECTOR error and JSR to CMDERR2
($E645) .</p>
</td></tr>
				<tr><td></td><td class="fit">E204</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Record command</h1>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Position pointer to given record</h1>
<p>Note: set to last record if out of range</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RECORD</td><td class="fit">E207</td>
				<td>20 B3 C2</td>
				<td class="fit">JSR $C2B3</td><td rowspan="1"><p>JSR to CMDSET($C2B3) to initialize the
pointers and tables .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E20A</td>
				<td>AD 01 02</td>
				<td class="fit">LDA $0201</td><td rowspan="2"><p>Load .A with the second character in the
command from CMDBUF+1 ($0201) and use it
to set the secondary address in SA ($83)</p>
</td></tr>
				<tr><td></td><td class="fit">E20D</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E20F</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E212</td>
				<td>90 05</td>
				<td class="fit">BCC $E219</td><td rowspan="1"><p>If carry flag clear, channel found so
branch to R20</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E214</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td><td rowspan="2"><p>Load .A with $70 to indicate a NO
CHANNEL error and JSR to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">E216</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">R20</td><td class="fit">E219</td>
				<td>A9 A0</td>
				<td class="fit">LDA #$A0</td><td rowspan="2"><p>Load .A with $A0 (last record flag plus
overflow flag) and JSR to CLRFLG ($DD9D)
to clear these flags.</p>
</td></tr>
				<tr><td></td><td class="fit">E21B</td>
				<td>20 9D DD</td>
				<td class="fit">JSR $DD9D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E21E</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="2"><p>JSR to TYPFIL ($D125) to determine the
file type. If the Z flag is set, it is
a relative file so branch to R30.</p>
</td></tr>
				<tr><td></td><td class="fit">E221</td>
				<td>F0 05</td>
				<td class="fit">BEQ $E228</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E223</td>
				<td>A9 64</td>
				<td class="fit">LDA #$64</td><td rowspan="2"><p>Load .A with $64 to indicate a FILE TYPE
MISMATCH error and JSR to CMDERR ($C1C8)</p>
</td></tr>
				<tr><td></td><td class="fit">E225</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">R30</td><td class="fit">E228</td>
				<td>B5 EC</td>
				<td class="fit">LDA $EC,X</td><td rowspan="3"><p>Load .A with the file type from FILTYP,X
($EC,X), AND the type with $01 to mask
off the non-drive bits, and store the
result as the drive # in DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">E22A</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">E22C</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E22E</td>
				<td>AD 02 02</td>
				<td class="fit">LDA $0202</td><td rowspan="2"><p>Load .A with the third character in the
command from CMDBUF+2 ($0202) and use it
to set the lo byte of the record number
in RECL,X ($B5,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">E231</td>
				<td>95 B5</td>
				<td class="fit">STA $B5,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E233</td>
				<td>AD 03 02</td>
				<td class="fit">LDA $0203</td><td rowspan="2"><p>Load .A with the fourth character in the
command from CMDBUF+3 ($0203) and use it
to set the hi byte of the record number
in RECH,X ($BB,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">E236</td>
				<td>95 BB</td>
				<td class="fit">STA $BB,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E238</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E23A</td>
				<td>A9 89</td>
				<td class="fit">LDA #$89</td><td rowspan="2"><p>Store $89 (random access - ready) as the
channel status in CHNRDY,X ($F2,X).</p>
</td></tr>
				<tr><td></td><td class="fit">E23C</td>
				<td>95 F2</td>
				<td class="fit">STA $F2,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E23E</td>
				<td>AD 04 02</td>
				<td class="fit">LDA $0204</td><td rowspan="2"><p>Load .A with the fifth character in the
command from CMDBUF+4 ($0204). This is
the byte pointer into the record. If the
byte pointer is $00, branch to R40.</p>
</td></tr>
				<tr><td></td><td class="fit">E241</td>
				<td>F0 10</td>
				<td class="fit">BEQ $E253</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E243</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>Set the carry flag and subtract $01 from
the byte pointer. If the result is $00,
branch to R40.</p>
</td></tr>
				<tr><td></td><td class="fit">E244</td>
				<td>E9 01</td>
				<td class="fit">SBC #$01</td></tr>
				<tr><td></td><td class="fit">E246</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $E253</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E248</td>
				<td>D5 C7</td>
				<td class="fit">CMP $C7,X</td><td rowspan="2"><p>Compare the adjusted byte pointer to the
record size in RS,X ($C7,X). If the byte
pointer is within the record, branch to
R40.</p>
</td></tr>
				<tr><td></td><td class="fit">E24A</td>
				<td>90 07</td>
				<td class="fit">BCC $E253</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E24C</td>
				<td>A9 51</td>
				<td class="fit">LDA #$51</td><td rowspan="3"><p>Load .A with $51 (record overflow) and
store it in ERWORD ($026C). Zero .A.</p>
</td></tr>
				<tr><td></td><td class="fit">E24E</td>
				<td>8D 6C 02</td>
				<td class="fit">STA $026C</td></tr>
				<tr><td></td><td class="fit">E251</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">R40</td><td class="fit">E253</td>
				<td>85 D4</td>
				<td class="fit">STA $D4</td><td rowspan="1"><p>Store the byte pointer (in .A) into
RECPTR ($D4) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E255</td>
				<td>20 0E CE</td>
				<td class="fit">JSR $CE0E</td><td rowspan="1"><p>JSR to FNDREL ($CE0E) to calculate the
side sector pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E258</td>
				<td>20 F8 DE</td>
				<td class="fit">JSR $DEF8</td><td rowspan="2"><p>JSR to SSPOS ($DEF8) to set the side
sector pointers. If V flag is clear,
we have not attempted to go beyond the
last record so branch to R50.</p>
</td></tr>
				<tr><td></td><td class="fit">E25B</td>
				<td>50 08</td>
				<td class="fit">BVC $E265</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E25D</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Load .A with $80 (last record flag) and
JSR to SETFLG ($DD97) to set the flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E25F</td>
				<td>20 97 DD</td>
				<td class="fit">JSR $DD97</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E262</td>
				<td>4C 5E E1</td>
				<td class="fit">JMP $E15E</td><td rowspan="1"><p>JMP to RD05 ($E15E) to set pointers to
the last record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">R50</td><td class="fit">E265</td>
				<td>20 75 E2</td>
				<td class="fit">JSR $E275</td><td rowspan="1"><p>JSR to POSITN ($E275) to position to the
desired record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E268</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="3"><p>Load .A with $80 (last record flag) and
JSR to TSTFLG ($DDA6) to test if this
flag has been set. If not, branch to
R60 to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">E26A</td>
				<td>20 A6 DD</td>
				<td class="fit">JSR $DDA6</td></tr>
				<tr><td></td><td class="fit">E26D</td>
				<td>F0 03</td>
				<td class="fit">BEQ $E272</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E26F</td>
				<td>4C 5E E1</td>
				<td class="fit">JMP $E15E</td><td rowspan="1"><p>JMP to RD05 ($E15E) to set pointers to
the last record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">R60</td><td class="fit">E272</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>JMP to ENDCMD ($C194) to terminate.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Position to record</h1>
<p>Moves relative record into active buffer
and the next block into inactive buffer,</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">POSITN</td><td class="fit">E275</td>
				<td>20 9C E2</td>
				<td class="fit">JSR $E29C</td><td rowspan="1"><p>JSR to POSBUF ($E29C) to position data
blocks into buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E278</td>
				<td>A5 D7</td>
				<td class="fit">LDA $D7</td><td rowspan="2"><p>Load .A with the pointer from RELPNT
($D7) and JSR to SETPNT ($D4C8) to set
up the buffer pointers.</p>
</td></tr>
				<tr><td></td><td class="fit">E27A</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E27D</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E27F</td>
				<td>B5 C7</td>
				<td class="fit">LDA $C7,X</td><td rowspan="2"><p>Load .A with the record size from RS,X
(C7,X) and set the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E281</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E282</td>
				<td>E5 D4</td>
				<td class="fit">SBC $D4</td><td rowspan="2"><p>Subtract the pointer in RECPNT ($D4)
from the record size in .A to find the
offset. If offset &gt; $00,branch to P2.</p>
</td></tr>
				<tr><td></td><td class="fit">E284</td>
				<td>B0 03</td>
				<td class="fit">BCS $E289</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E286</td>
				<td>4C 02 E2</td>
				<td class="fit">JMP $E202</td><td rowspan="1"><p>Trouble! JMP to BREAK ($E202) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">P2</td><td class="fit">E289</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="3"><p>Clear the carry flag and add the pointer
in RELPNT ($D7). If there is no carry,
branch to P30.</p>
</td></tr>
				<tr><td></td><td class="fit">E28A</td>
				<td>65 D7</td>
				<td class="fit">ADC $D7</td></tr>
				<tr><td></td><td class="fit">E28C</td>
				<td>90 03</td>
				<td class="fit">BCC $E291</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E28E</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td><td rowspan="2"><p>Add another $01 and set the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E290</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">P30</td><td class="fit">E291</td>
				<td>20 09 E0</td>
				<td class="fit">JSR $E009</td><td rowspan="1"><p>JSR to NXOUT ($E009) to set up the next
record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E294</td>
				<td>4C 38 E1</td>
				<td class="fit">JMP $E138</td><td rowspan="1"><p>JMP to RD15 ($E138) to complete set up.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Unused code</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E297</td>
				<td>A9 51</td>
				<td class="fit">LDA #$51</td><td rowspan="2"><p>Load .A with $51 (record overflow) and
JSR to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">E299</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Position proper data blocks into buffers</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">POSBUF</td><td class="fit">E29C</td>
				<td>A5 94</td>
				<td class="fit">LDA $94</td><td rowspan="2"><p>Save the lo byte of the DIRBUF ($94/5)
pointer into R3 ($89).</p>
</td></tr>
				<tr><td></td><td class="fit">E29E</td>
				<td>85 89</td>
				<td class="fit">STA $89</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2A0</td>
				<td>A5 95</td>
				<td class="fit">LDA $95</td><td rowspan="2"><p>Save the hi byte of the DIRBUF ($94/5)
pointer into R4 ($8A) .</p>
</td></tr>
				<tr><td></td><td class="fit">E2A2</td>
				<td>85 8A</td>
				<td class="fit">STA $8A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2A4</td>
				<td>20 D0 E2</td>
				<td class="fit">JSR $E2D0</td><td rowspan="2"><p>JSR to BHERE ($E2D0) to check if desired
block is in the buffer. If not, branch
to P10 to read it in.</p>
</td></tr>
				<tr><td></td><td class="fit">E2A7</td>
				<td>D0 01</td>
				<td class="fit">BNE $E2AA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2A9</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">P10</td><td class="fit">E2AA</td>
				<td>20 F1 DD</td>
				<td class="fit">JSR $DDF1</td><td rowspan="1"><p>JSR to SCRUB ($DDF1) to clean the buffer</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2AD</td>
				<td>20 0C DE</td>
				<td class="fit">JSR $DE0C</td><td rowspan="1"><p>JSR to GETLNK ($DE0C) to set TRACK and
SECTOR from the link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2B0</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>If TRACK ($80) is $00, there is no next
track so branch to P80.</p>
</td></tr>
				<tr><td></td><td class="fit">E2B2</td>
				<td>F0 0E</td>
				<td class="fit">BEQ $E2C2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2B4</td>
				<td>20 D3 E2</td>
				<td class="fit">JSR $E2D3</td><td rowspan="2"><p>JSR to BHERE ($E2D0) to check if desired
block is in the buffer. If not, branch
to P75 to read it in.</p>
</td></tr>
				<tr><td></td><td class="fit">E2B7</td>
				<td>D0 06</td>
				<td class="fit">BNE $E2BF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2B9</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle the
active and inactive buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2BC</td>
				<td>4C DA D2</td>
				<td class="fit">JMP $D2DA</td><td rowspan="1"><p>JMP to FREIAC ($D2DA) to free the
inactive buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">P75</td><td class="fit">E2BF</td>
				<td>20 DA D2</td>
				<td class="fit">JSR $D2DA</td><td rowspan="1"><p>JSR to FREIAC ($D2DA) to free the
inactive buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">P80</td><td class="fit">E2C2</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2C4</td>
				<td>B1 89</td>
				<td class="fit">LDA ($89),Y</td><td rowspan="3"><p>Move the desired track from (R3),Y
($89), Y into TRACK ($80). Increment .Y</p>
</td></tr>
				<tr><td></td><td class="fit">E2C6</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
				<tr><td></td><td class="fit">E2C8</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2C9</td>
				<td>B1 89</td>
				<td class="fit">LDA ($89),Y</td><td rowspan="2"><p>Move the desired sector from (R3),Y
($89), Y into SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">E2CB</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2CD</td>
				<td>4C AF D0</td>
				<td class="fit">JMP $D0AF</td><td rowspan="1"><p>JMP to STRDBL ($D0AF) to read in the
desired block and the next one too.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BHERE</td><td class="fit">E2D0</td>
				<td>20 3E DE</td>
				<td class="fit">JSR $DE3E</td><td rowspan="1"><p>Check if desired block is in buffer:
JSR to GETHDR ($DE3E) to set TRACK and
SECTOR from the header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BHERE2</td><td class="fit">E2D3</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2D5</td>
				<td>B1 89</td>
				<td class="fit">LDA ($89),Y</td><td rowspan="2"><p>Compare the desired track from (R3) ,Y
($89), Y with the value in TRACK ($80).
If they are equal, branch to BH10 to
compare the sectors.</p>
</td></tr>
				<tr><td></td><td class="fit">E2D7</td>
				<td>C5 80</td>
				<td class="fit">CMP $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2D9</td>
				<td>F0 01</td>
				<td class="fit">BEQ $E2DC</td><td rowspan="2"><p>No match (Z=0) so exit with an RTS</p>
</td></tr>
				<tr><td></td><td class="fit">E2DB</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BH10</td><td class="fit">E2DC</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2DD</td>
				<td>B1 89</td>
				<td class="fit">LDA ($89),Y</td><td rowspan="2"><p>Compare the desired sector from (R3),Y
($89) ,Y with the value in SECTOR ($81) .
This sets Z=l if they are equal.</p>
</td></tr>
				<tr><td></td><td class="fit">E2DF</td>
				<td>C5 81</td>
				<td class="fit">CMP $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2E1</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NULBUF</td><td class="fit">E2E2</td>
				<td>20 2B DE</td>
				<td class="fit">JSR $DE2B</td><td rowspan="1"><p>Set null records in active buffer:
JSR to SETOO ($DE2B) to set pointers to
start of data buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2E5</td>
				<td>A0 02</td>
				<td class="fit">LDY #$02</td><td rowspan="5"><p>Loop to fill data buffer with $00' s
from $xx02 to $xxFF.</p>
</td></tr>
				<tr><td></td><td class="fit">E2E7</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">E2E9</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">E2EB</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">E2EC</td>
				<td>D0 FB</td>
				<td class="fit">BNE $E2E9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2EE</td>
				<td>20 04 E3</td>
				<td class="fit">JSR $E304</td><td rowspan="1"><p>JSR to ADDNR ($E304) to calculate the
position of the next record (in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NB20</td><td class="fit">E2F1</td>
				<td>95 C1</td>
				<td class="fit">STA $C1,X</td><td rowspan="1"><p>Store the new pointer value in NR,X
($C1,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2F3</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="1"><p>Transfer the next record pointer to .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2F4</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF as the first character in the
next record at (DIRBUF) ,Y; ($94), Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E2F6</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2F8</td>
				<td>20 04 E3</td>
				<td class="fit">JSR $E304</td><td rowspan="1"><p>JSR to ADDNR ($E304) to calculate the
position of the next record (in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2FB</td>
				<td>90 F4</td>
				<td class="fit">BCC $E2F1</td><td rowspan="1"><p>If carry flag is clear, we haven't done
all the records in this block yet so
branch to NB20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2FD</td>
				<td>D0 04</td>
				<td class="fit">BNE $E303</td><td rowspan="1"><p>If the Z flag is not set, branch to NB30</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E2FF</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 into NR,X ($C1,X) to flag the
last record.</p>
</td></tr>
				<tr><td></td><td class="fit">E301</td>
				<td>95 C1</td>
				<td class="fit">STA $C1,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NB30</td><td class="fit">E303</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDNR</td><td class="fit">E304</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Add record size &amp; next record pointer:
On exit: C=l if crossed buffer boundary
Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E306</td>
				<td>B5 C1</td>
				<td class="fit">LDA $C1,X</td><td rowspan="2"><p>Load .A with the next record pointer
from NR,X ($C1,X) and set the carry flag</p>
</td></tr>
				<tr><td></td><td class="fit">E308</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E309</td>
				<td>F0 0D</td>
				<td class="fit">BEQ $E318</td><td rowspan="1"><p>If NR pointer is $00 branch to AN05.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E30B</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Clear the carry flag and add the record
size from RS,X ($C7,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">E30C</td>
				<td>75 C7</td>
				<td class="fit">ADC $C7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E30E</td>
				<td>90 0B</td>
				<td class="fit">BCC $E31B</td><td rowspan="1"><p>If carry clear, branch to AN10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E310</td>
				<td>D0 06</td>
				<td class="fit">BNE $E318</td><td rowspan="1"><p>If result is not $00, branch to AN05.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E312</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="1"><p>Load .A with $02(bypass link)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E314</td>
				<td>2C CC FE</td>
				<td class="fit">BIT $FECC</td><td rowspan="1"><p>BIT with ER00 ($FECC) to set flags,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E317</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AN05</td><td class="fit">E318</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td><td rowspan="2"><p>Add $01 to the contents of .A to adjust
for the link and set the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E31A</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AN10</td><td class="fit">E31B</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDREL</td><td class="fit">E31C</td>
				<td>20 D3 D1</td>
				<td class="fit">JSR $D1D3</td><td rowspan="1"><p>Add blocks to a relative file:
JSR to SETDRN ($D1D3) to set drive #.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E31F</td>
				<td>20 CB E1</td>
				<td class="fit">JSR $E1CB</td><td rowspan="1"><p>JSR to SSEND ($E1CB) to set up end of
file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E322</td>
				<td>20 9C E2</td>
				<td class="fit">JSR $E29C</td><td rowspan="1"><p>JSR to POSBUF ($E29C) to position the
proper data blocks into the buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E325</td>
				<td>20 7B CF</td>
				<td class="fit">JSR $CF7B</td><td rowspan="1"><p>JSR to DBSET ($CF7C) to set up double
buffering.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E328</td>
				<td>A5 D6</td>
				<td class="fit">LDA $D6</td><td rowspan="2"><p>Copy side sector index from SSIND ($D6)
into R1 ($87) .</p>
</td></tr>
				<tr><td></td><td class="fit">E32A</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E32C</td>
				<td>A5 D5</td>
				<td class="fit">LDA $D5</td><td rowspan="2"><p>Copy side sector number from SSNUM ($D5)
into R0 ($86) .</p>
</td></tr>
				<tr><td></td><td class="fit">E32E</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E330</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set R2 ($88) to $00 to clear the flag
fcr one block.</p>
</td></tr>
				<tr><td></td><td class="fit">E332</td>
				<td>85 88</td>
				<td class="fit">STA $88</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E334</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set RECPTR ($D4) to $00 to clear this
for calculations.</p>
</td></tr>
				<tr><td></td><td class="fit">E336</td>
				<td>85 D4</td>
				<td class="fit">STA $D4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E338</td>
				<td>20 0E CE</td>
				<td class="fit">JSR $CE0E</td><td rowspan="1"><p>JSR to FNDREL ($CE0E) to calculate the
side sector pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDR1</td><td class="fit">E33B</td>
				<td>20 4D EF</td>
				<td class="fit">JSR $EF4D</td><td rowspan="1"><p>JSR to NUMFRE ($EF4D) to calculate the
number of blocks free.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E33E</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E340</td>
				<td>B6 C7</td>
				<td class="fit">LDX $C7,Y</td><td rowspan="3"><p>Load .X with the record size from RS,Y
($C7,Y), decrement the size by 1, and
transfer the result into .A.</p>
</td></tr>
				<tr><td></td><td class="fit">E342</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">E343</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E344</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Clear the carry flag and add the record
pointer, RELPTR ($D7) to the record size
in .A.</p>
</td></tr>
				<tr><td></td><td class="fit">E345</td>
				<td>65 D7</td>
				<td class="fit">ADC $D7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E347</td>
				<td>90 0C</td>
				<td class="fit">BCC $E355</td><td rowspan="1"><p>If no carry results, there is no span
to the next block so branch to AR10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E349</td>
				<td>E6 D6</td>
				<td class="fit">INC $D6</td><td rowspan="3"><p>Increment the SS pointer, SSIND ($D6)
twice. If the result is not zero, branch
to AR10.</p>
</td></tr>
				<tr><td></td><td class="fit">E34B</td>
				<td>E6 D6</td>
				<td class="fit">INC $D6</td></tr>
				<tr><td></td><td class="fit">E34D</td>
				<td>D0 06</td>
				<td class="fit">BNE $E355</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E34F</td>
				<td>E6 D5</td>
				<td class="fit">INC $D5</td><td rowspan="3"><p>Increment the side sector number, SSNUM
(D5) by 1 and store $10 (the side sector
offset) into SSIND ($D6) since we are
starting a new block.</p>
</td></tr>
				<tr><td></td><td class="fit">E351</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td></tr>
				<tr><td></td><td class="fit">E353</td>
				<td>85 D6</td>
				<td class="fit">STA $D6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR10</td><td class="fit">E355</td>
				<td>A5 87</td>
				<td class="fit">LDA $87</td><td rowspan="4"><p>Load .A with the SS index from Rl. clear
the carry flag, add $02, and JSR to
SETSSP ($DEE9) to set DIRBUF &amp; BUFTAB.</p>
</td></tr>
				<tr><td></td><td class="fit">E357</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">E358</td>
				<td>69 02</td>
				<td class="fit">ADC #$02</td></tr>
				<tr><td></td><td class="fit">E35A</td>
				<td>20 E9 DE</td>
				<td class="fit">JSR $DEE9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E35D</td>
				<td>A5 D5</td>
				<td class="fit">LDA $D5</td><td rowspan="3"><p>Load the side sector number from SSNUM
($D5) and compare it with $06, the
number of side sector links. If SSNUM
is less than or equal to $06, the range
is valid so branch to AR25.</p>
</td></tr>
				<tr><td></td><td class="fit">E35F</td>
				<td>C9 06</td>
				<td class="fit">CMP #$06</td></tr>
				<tr><td></td><td class="fit">E361</td>
				<td>90 05</td>
				<td class="fit">BCC $E368</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR20</td><td class="fit">E363</td>
				<td>A9 52</td>
				<td class="fit">LDA #$52</td><td rowspan="2"><p>Load .A with $52 to indicate a TOO BIG
RELATIVE FILE error and JSR to CMDERR
($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">E365</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR25</td><td class="fit">E368</td>
				<td>A5 D6</td>
				<td class="fit">LDA $D6</td><td rowspan="2"><p>Load .A with the side sector index from
SSIND ($D6) and set the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E36A</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E36B</td>
				<td>E5 87</td>
				<td class="fit">SBC $87</td><td rowspan="2"><p>Subtract the SS index from Rl ($87). If
the result is positive, branch to AR30.</p>
</td></tr>
				<tr><td></td><td class="fit">E36D</td>
				<td>B0 03</td>
				<td class="fit">BCS $E372</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E36F</td>
				<td>E9 0F</td>
				<td class="fit">SBC #$0F</td><td rowspan="2"><p>Subtract $0F (the side sector index
offset less 1) and clear the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">E371</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR30</td><td class="fit">E372</td>
				<td>85 72</td>
				<td class="fit">STA $72</td><td rowspan="1"><p>Store the number of side sector indicies
(in .A) into T3 ($72) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E374</td>
				<td>A5 D5</td>
				<td class="fit">LDA $D5</td><td rowspan="3"><p>Load .A with the SS number from SSNUM
($D5). Subtract the SS number from R0
($86) to find the number of side sectors
needed. Store the number needed into
T4 ($73) .</p>
</td></tr>
				<tr><td></td><td class="fit">E376</td>
				<td>E5 86</td>
				<td class="fit">SBC $86</td></tr>
				<tr><td></td><td class="fit">E378</td>
				<td>85 73</td>
				<td class="fit">STA $73</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E37A</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="3"><p>Zero Tl ($70) and T2 ($71) to serve as
a results accumulator.</p>
</td></tr>
				<tr><td></td><td class="fit">E37C</td>
				<td>86 70</td>
				<td class="fit">STX $70</td></tr>
				<tr><td></td><td class="fit">E37E</td>
				<td>86 71</td>
				<td class="fit">STX $71</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E380</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="2"><p>Transfer the number of side sectors
needed from .A to .X and JSR to SSCALC
($DF51) to calculate the number of
blocks needed.</p>
</td></tr>
				<tr><td></td><td class="fit">E381</td>
				<td>20 51 DF</td>
				<td class="fit">JSR $DF51</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E384</td>
				<td>A5 71</td>
				<td class="fit">LDA $71</td><td rowspan="2"><p>Load .A with the hi byte of the number
needed from T2 ($71). If the hi byte is
not $00, branch to AR35.</p>
</td></tr>
				<tr><td></td><td class="fit">E386</td>
				<td>D0 07</td>
				<td class="fit">BNE $E38F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E388</td>
				<td>A6 70</td>
				<td class="fit">LDX $70</td><td rowspan="3"><p>Load .X with the lo byte of the number
needed from Tl ($70). Decrement .X by 1.
If the result is not $00, branch to AR35</p>
</td></tr>
				<tr><td></td><td class="fit">E38A</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">E38B</td>
				<td>D0 02</td>
				<td class="fit">BNE $E38F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E38D</td>
				<td>E6 88</td>
				<td class="fit">INC $88</td><td rowspan="1"><p>Increment R2 ($88) by 1.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Check if there are enough blocks left</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR35</td><td class="fit">E38F</td>
				<td>CD 73 02</td>
				<td class="fit">CMP $0273</td><td rowspan="3"><p>Compare the hi byte of the number of
blocks needed (in .A) with the hi byte
of the number of blocks free in NBTEMP+1
($0273). If there are more than enough,
branch to AR40. If there are NOT enough,
branch to AR20. If we have just enough,
we had better check the lo byte.</p>
</td></tr>
				<tr><td></td><td class="fit">E392</td>
				<td>90 09</td>
				<td class="fit">BCC $E39D</td></tr>
				<tr><td></td><td class="fit">E394</td>
				<td>D0 CD</td>
				<td class="fit">BNE $E363</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E396</td>
				<td>AD 72 02</td>
				<td class="fit">LDA $0272</td><td rowspan="3"><p>Load .A with the lo byte of the number
free from NBTEMP ($0272) and compare it
with the lo byte of the number needed in
T1 ($70). If there are not enough,
branch to AR20 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">E399</td>
				<td>C5 70</td>
				<td class="fit">CMP $70</td></tr>
				<tr><td></td><td class="fit">E39B</td>
				<td>90 C6</td>
				<td class="fit">BCC $E363</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR40</td><td class="fit">E39D</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Load .A with $01 and JSR to DRDBYT
($D4F6) to read the sector link.</p>
</td></tr>
				<tr><td></td><td class="fit">E39F</td>
				<td>20 F6 D4</td>
				<td class="fit">JSR $D4F6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3A2</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Clear the carry flag and add $01 to .A
to give the NR.</p>
</td></tr>
				<tr><td></td><td class="fit">E3A3</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3A5</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3A7</td>
				<td>95 C1</td>
				<td class="fit">STA $C1,X</td><td rowspan="1"><p>Store the NR value (in .A) into NR,X
($C1,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3A9</td>
				<td>20 1E F1</td>
				<td class="fit">JSR $F11E</td><td rowspan="1"><p>JSR to NXTTS ($F11E) to get the next
available track and sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3AC</td>
				<td>20 FD DD</td>
				<td class="fit">JSR $DDFD</td><td rowspan="1"><p>JSR to SETLNK ($DDFD) to set the track
and sector link in the current block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3AF</td>
				<td>A5 88</td>
				<td class="fit">LDA $88</td><td rowspan="2"><p>Load .A with the add-1-block flag from
R2 ($88). If the flag is set, branch
to AR50.</p>
</td></tr>
				<tr><td></td><td class="fit">E3B1</td>
				<td>D0 15</td>
				<td class="fit">BNE $E3C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3B3</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write the
current block to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR45</td><td class="fit">E3B6</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E)to switch buffers,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3B9</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>JSR to SETHDR ($D6D0)to set header from
TRACK and SECTOR.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3BC</td>
				<td>20 1E F1</td>
				<td class="fit">JSR $F11E</td><td rowspan="1"><p>JSR to NXTTS ($F11E) to get. the next,
available track and sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3BF</td>
				<td>20 FD DD</td>
				<td class="fit">JSR $DDFD</td><td rowspan="1"><p>JSR to SETLNK ($DDFD) to set the track
and sector link in the current block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3C2</td>
				<td>20 E2 E2</td>
				<td class="fit">JSR $E2E2</td><td rowspan="1"><p>JSR to NULBUF ($E2E2) to clean out the
buffer</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3C5</td>
				<td>4C D4 E3</td>
				<td class="fit">JMP $E3D4</td><td rowspan="1"><p>JMP to AR55 ($E3D4) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR50</td><td class="fit">E3C8</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to switch buffers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3CB</td>
				<td>20 D0 D6</td>
				<td class="fit">JSR $D6D0</td><td rowspan="1"><p>JSR to SETHDR ($D6D0) to set header from
TRACK and SECTOR.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3CE</td>
				<td>20 E2 E2</td>
				<td class="fit">JSR $E2E2</td><td rowspan="1"><p>JSR to NULBUF ($E2E2) to clean out the
buffer</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3D1</td>
				<td>20 19 DE</td>
				<td class="fit">JSR $DE19</td><td rowspan="1"><p>JSR to NULLNK ($DE19) to set link for
the last block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR55</td><td class="fit">E3D4</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write the
current block to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3D7</td>
				<td>20 0C DE</td>
				<td class="fit">JSR $DE0C</td><td rowspan="1"><p>JSR to GETLNK ($DE0C) to set TRACK and
SECTOR from the track &amp; sector link.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3DA</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="4"><p>Save the value of TRACK ($80) and SECTOR
($81) onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E3DC</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">E3DD</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td></tr>
				<tr><td></td><td class="fit">E3DF</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3E0</td>
				<td>20 3E DE</td>
				<td class="fit">JSR $DE3E</td><td rowspan="1"><p>JSR to GETHDR ($DE3E) to set TRACK and
SECTOR from the last sector read.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3E3</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="4"><p>Save the value of TRACK ($80) and SECTOR
($81) onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E3E5</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">E3E6</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">E3E8</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3E9</td>
				<td>20 45 DF</td>
				<td class="fit">JSR $DF45</td><td rowspan="1"><p>JSR to GSSPNT ($DF45) to calculate the
side sector pointer (returned in .A)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3EC</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="2"><p>Transfer the pointer in .A to .X. If the
pointer value is not $00, we don't need
another side sector so branch to AR60.</p>
</td></tr>
				<tr><td></td><td class="fit">E3ED</td>
				<td>D0 0A</td>
				<td class="fit">BNE $E3F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3EF</td>
				<td>20 4E E4</td>
				<td class="fit">JSR $E44E</td><td rowspan="1"><p>JSR to NEWSS ($E44E) to get another side
sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3F2</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td><td rowspan="2"><p>Load .A with $10, side sector offset,
and JSR to SETSSP ($DEE9) to set the
side sector pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">E3F4</td>
				<td>20 E9 DE</td>
				<td class="fit">JSR $DEE9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3F7</td>
				<td>E6 86</td>
				<td class="fit">INC $86</td><td rowspan="1"><p>Increment the side sector count in R0
($86) by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR60</td><td class="fit">E3F9</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull this sector's track off the stack
and JSR to PUTSS ($DD8D) to write it
into the side sector buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E3FA</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E3FD</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull this sector's sector off the stack
and JSR to PUTSS ($DD8D) to write it
into the side sector buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E3FE</td>
				<td>20 8D DD</td>
				<td class="fit">JSR $DD8D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E401</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull this sector's sector link off the
stack and store it in SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">E402</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E404</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull this sector's track link off the
stack and store it in TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">E405</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E407</td>
				<td>F0 0F</td>
				<td class="fit">BEQ $E418</td><td rowspan="1"><p>If track link is $00, there are no more
blocks in this file so branch to AR65</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E409</td>
				<td>A5 86</td>
				<td class="fit">LDA $86</td><td rowspan="3"><p>Compare the side sector counter in R0
($86) with the end count in SSNUM ($D5) .
If they are not equal, we haven't done
enough new blocks yet so branch to AR45.</p>
</td></tr>
				<tr><td></td><td class="fit">E40B</td>
				<td>C5 D5</td>
				<td class="fit">CMP $D5</td></tr>
				<tr><td></td><td class="fit">E40D</td>
				<td>D0 A7</td>
				<td class="fit">BNE $E3B6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E40F</td>
				<td>20 45 DF</td>
				<td class="fit">JSR $DF45</td><td rowspan="1"><p>Almost done so JSR to GSSPNT ($DF45) to
get the side sector pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E412</td>
				<td>C5 D6</td>
				<td class="fit">CMP $D6</td><td rowspan="3"><p>Compare the pointer in .A with the end
pointer in SSIND($D6). If SSIND&gt;.A, we
are almost done so branch to AR45. If
SSIND=.A there is one more block left so
branch to AR50.</p>
</td></tr>
				<tr><td></td><td class="fit">E414</td>
				<td>90 A0</td>
				<td class="fit">BCC $E3B6</td></tr>
				<tr><td></td><td class="fit">E416</td>
				<td>F0 B0</td>
				<td class="fit">BEQ $E3C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR65</td><td class="fit">E418</td>
				<td>20 45 DF</td>
				<td class="fit">JSR $DF45</td><td rowspan="2"><p>All done. JSR to GSSPNT ($DF45) to get
the side sector pointer. Save it onto
the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E41B</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E41C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with a $00 and JSR to SSDIR
($DEDC) to set DIRBUF with the current
SS pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">E41E</td>
				<td>20 DC DE</td>
				<td class="fit">JSR $DEDC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E421</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Zero .A and .Y. Zero the track link of
the side-sector sector in (DIRBUF) ,Y
($94) ,Y. Increment .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E423</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">E424</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">E426</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E427</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the pointer into this sector off
the stack, subtract $01, and store the
result as the sector link of the side-
sector sector in (DIRBUF) ,Y; ($94) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E428</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">E429</td>
				<td>E9 01</td>
				<td class="fit">SBC #$01</td></tr>
				<tr><td></td><td class="fit">E42B</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E42D</td>
				<td>20 6C DE</td>
				<td class="fit">JSR $DE6C</td><td rowspan="1"><p>JSR to WRTSS ($DE6C) to write out the
current block of side sectors to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E430</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
write job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E433</td>
				<td>20 F4 EE</td>
				<td class="fit">JSR $EEF4</td><td rowspan="1"><p>JSR to MAPOUT ($EEF4) to write the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E436</td>
				<td>20 0E CE</td>
				<td class="fit">JSR $CE0E</td><td rowspan="1"><p>JSR to FNDREL ($CE0E) to find the
relative file and calculate SSNUM and
SSIND for the desired record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E439</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to get back to
the leading buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E43C</td>
				<td>20 F8 DE</td>
				<td class="fit">JSR $DEF8</td><td rowspan="1"><p>JSR to SSPOS ($DEF8) to position SS and
BUFTAB to SSNUM and SSIND.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E43F</td>
				<td>70 03</td>
				<td class="fit">BVS $E444</td><td rowspan="1"><p>On return, if V flag is set, the record
is still beyond the end of the relative
file so branch to AR70.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E441</td>
				<td>4C 75 E2</td>
				<td class="fit">JMP $E275</td><td rowspan="1"><p>All OK so exit from routine with a JMP
to POSITN ($E275) to position to the
record.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AR70</td><td class="fit">E444</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="4"><p>Still beyond end of file so: load .A
with $80 (the last record flag). JSR to
SETFLG ($DD97) to set the flag, load .A
with $50 (no record error) and exit with
a JSR to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">E446</td>
				<td>20 97 DD</td>
				<td class="fit">JSR $DD97</td></tr>
				<tr><td></td><td class="fit">E449</td>
				<td>A9 50</td>
				<td class="fit">LDA #$50</td></tr>
				<tr><td></td><td class="fit">E44B</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Create a new side sector and change the old side sectors to reflect, it.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NEWSS</td><td class="fit">E44E</td>
				<td>20 1E F1</td>
				<td class="fit">JSR $F11E</td><td rowspan="1"><p>JSR to NXTTS ($F11E) to find the next-
available track and sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E451</td>
				<td>20 1E CF</td>
				<td class="fit">JSR $CF1E</td><td rowspan="1"><p>JSR to DBLBUF ($CF1E) to toggle to the
inactive buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E454</td>
				<td>20 F1 DD</td>
				<td class="fit">JSR $DDF1</td><td rowspan="1"><p>JSR to SCRUB ($DDF1) to write out the
buffer if it is dirty (doesn't match
copy on disk) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E457</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="2"><p>JSR to GETACT ($DF93) to determine the
active buffer number (returned in .A) .
Save the buffer number onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E45A</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E45B</td>
				<td>20 C1 DE</td>
				<td class="fit">JSR $DEC1</td><td rowspan="1"><p>JSR to CLRBUF ($DEC1) to zero the buffer</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E45E</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E460</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="2"><p>Load .A with the number of the buffer
containing the side sectors from SS,X
($CD,X) and transfer this value into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E462</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E463</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the active buffer number off the
stack and transfer it into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">E464</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E465</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td><td rowspan="1"><p>Load .A with $10, the side sector offset</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E467</td>
				<td>20 A5 DE</td>
				<td class="fit">JSR $DEA5</td><td rowspan="1"><p>JSR to B0TOB0 ($DEA5) to move $10 (.A)
bytes from buffer #(.X) to buffer #(.Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E46A</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to SSDIR($DEDC)
to set the pointer at DIRBUF ($94) to
point to the start of the old SS buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E46C</td>
				<td>20 DC DE</td>
				<td class="fit">JSR $DEDC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E46F</td>
				<td>A0 02</td>
				<td class="fit">LDY #$02</td><td rowspan="3"><p>Load .Y with $02. and load .A with the
side sector number from (DIRBUF) ,Y and
save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E471</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td></tr>
				<tr><td></td><td class="fit">E473</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E474</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and JSR to SETPNT ($D4C8) to set
the pointer at DIRBUF ($94) to point to
the start of the new SS buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E476</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E479</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the SS number off the stack, add 1,
and store the result in the new side
sector table at (DIRBUF) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E47A</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">E47B</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
				<tr><td></td><td class="fit">E47D</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E47F</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="4"><p>Multiply the SS number in .A by 2 (ASL) ,
add 4, store the result (points to the
new SS value in the buffer) in R3 ($89) ,
and transfer this value into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E480</td>
				<td>69 04</td>
				<td class="fit">ADC #$04</td></tr>
				<tr><td></td><td class="fit">E482</td>
				<td>85 89</td>
				<td class="fit">STA $89</td></tr>
				<tr><td></td><td class="fit">E484</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E485</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>Subtract $02 from the result and store
this pointer in R2 ($88) .</p>
</td></tr>
				<tr><td></td><td class="fit">E486</td>
				<td>E9 02</td>
				<td class="fit">SBC #$02</td></tr>
				<tr><td></td><td class="fit">E488</td>
				<td>85 8A</td>
				<td class="fit">STA $8A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E48A</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="3"><p>Copy the current value of TRACK ($80)
into Rl ($87) for use in SS update and
into the new SS buffer at (DIRBUF) ,Y</p>
</td></tr>
				<tr><td></td><td class="fit">E48C</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
				<tr><td></td><td class="fit">E48E</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E490</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E491</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="3"><p>Copy the current value of SECTOR ($81)
into R2 ($88) for use in SS update and
into the new SS buffer at (DIRBUF) ,Y</p>
</td></tr>
				<tr><td></td><td class="fit">E493</td>
				<td>85 88</td>
				<td class="fit">STA $88</td></tr>
				<tr><td></td><td class="fit">E495</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E497</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="3"><p>Set the track link at the start of the
new SS block to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">E499</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">E49A</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E49C</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Set the sector link at the start of the
new SS block to $11 to indicate that the
last, non-zero character in the buffer is
the one following the SS offset.</p>
</td></tr>
				<tr><td></td><td class="fit">E49D</td>
				<td>A9 11</td>
				<td class="fit">LDA #$11</td></tr>
				<tr><td></td><td class="fit">E49F</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4A1</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td><td rowspan="2"><p>Load .A with $10 (the SS offset) and JSR
to SETPNT ($D4C8) to set the pointer
to the new SS block.</p>
</td></tr>
				<tr><td></td><td class="fit">E4A3</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4A6</td>
				<td>20 50 DE</td>
				<td class="fit">JSR $DE50</td><td rowspan="1"><p>JSR to WRTAB ($DE50) to write out the
new side sector block to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4A9</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
write job to be completed.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: Finished creating new block. Now,
      revise old SS to reflect the new.</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NS20</td><td class="fit">E4AC</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4AE</td>
				<td>B5 CD</td>
				<td class="fit">LDA $CD,X</td><td rowspan="2"><p>Load .A with the side sector buffer
number from SS,X ($CD,X) and save this
number onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E4B0</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4B1</td>
				<td>20 9E DF</td>
				<td class="fit">JSR $DF9E</td><td rowspan="1"><p>JSR to GAFLGS ($DF9E) to get active
buffer number and set flags.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4B4</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the new channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4B6</td>
				<td>95 CD</td>
				<td class="fit">STA $CD,X</td><td rowspan="1"><p>Store the side sector buffer number from
.A into SS,X ($CD,X). Note: this swaps
the active buffer and the SS buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4B8</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the old side sector buffer number
off the stack, load .X with the last
buffer used from LBUSED ($0257). and
store the old SS buffer # (in .A) into
BUF0,X ($A7,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">E4B9</td>
				<td>AE 57 02</td>
				<td class="fit">LDX $0257</td></tr>
				<tr><td></td><td class="fit">E4BC</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4BE</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and JSR to SETPNT ($D4C8) to set
the buffer pointer to the start of the
buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E4C0</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4C3</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Zero .Y and set the track link to point-
to the new SS block using the value from
TRACK ($80). Increment .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E4C5</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">E4C7</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">E4C9</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4CA</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="2"><p>Set the sector link to point to the new
SS block using the value from SECTOR
($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">E4CC</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4CE</td>
				<td>4C DE E4</td>
				<td class="fit">JMP $E4DE</td><td rowspan="1"><p>JMP to NS50 ($E4DE) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NS40</td><td class="fit">E4D1</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4D4</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4D6</td>
				<td>20 1B DF</td>
				<td class="fit">JSR $DF1B</td><td rowspan="2"><p>JSR to IBRD ($DF1B) to read the next SS.
buffer number (returned in .A) .</p>
</td></tr>
				<tr><td></td><td class="fit">E4D9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4DB</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td><td rowspan="1"><p>Zero .A and JSR to SETPNT ($D4C8) to set
the buffer pointer to the start of the
buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NS50</td><td class="fit">E4DE</td>
				<td>C6 8A</td>
				<td class="fit">DEC $8A</td><td rowspan="2"><p>Decrement the pointer in R4 ($8A) twice.</p>
</td></tr>
				<tr><td></td><td class="fit">E4E0</td>
				<td>C6 8A</td>
				<td class="fit">DEC $8A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4E2</td>
				<td>A4 89</td>
				<td class="fit">LDY $89</td><td rowspan="1"><p>Load .Y with the pointer into the buffer
from R3 ($89) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4E4</td>
				<td>A5 87</td>
				<td class="fit">LDA $87</td><td rowspan="2"><p>Load .A with the new SS track pointer
from Rl ($87) and store this value into
the data buffer at (DIRBUF) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E4E6</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4E8</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4E9</td>
				<td>A5 88</td>
				<td class="fit">LDA $88</td><td rowspan="2"><p>Load .A with the new SS sector pointer
from R2 ($88) and store this value into
the data buffer at (DIRBUF) ,Y .</p>
</td></tr>
				<tr><td></td><td class="fit">E4EB</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4ED</td>
				<td>20 5E DE</td>
				<td class="fit">JSR $DE5E</td><td rowspan="1"><p>JSR to WRTOUT ($DE5E) to write out the
revised side sector block.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4F0</td>
				<td>20 99 D5</td>
				<td class="fit">JSR $D599</td><td rowspan="1"><p>JSR to WATJOB ($D599) to wait for the
write job to be completed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4F3</td>
				<td>A4 8A</td>
				<td class="fit">LDY $8A</td><td rowspan="3"><p>Load .Y with the pointer from $R4 ($8A)
and compare it to $03. If .Y&gt;$03 / there
are more side sectors to update so
branch back to NS40.</p>
</td></tr>
				<tr><td></td><td class="fit">E4F5</td>
				<td>C0 03</td>
				<td class="fit">CPY #$03</td></tr>
				<tr><td></td><td class="fit">E4F7</td>
				<td>B0 D8</td>
				<td class="fit">BCS $E4D1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4F9</td>
				<td>4C 1E CF</td>
				<td class="fit">JMP $CF1E</td><td rowspan="1"><p>Terminate routine with a JMP to DBLBUF
($CF1E) to reset the active buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E4FC</td>
				<td>00 A0 4F CB 20 21 22 23 24 27 D2 45 41 44 89 52 83 20 54 4F 4F 20 4C 41 52 47 C5 50 8B 06 20 50 52 45 53 45 4E D4 51 CF 56 45 52 46 4C 4F 57 20 49 4E 8B 25 28 8A 89 26 8A 20 50 52 4F 54 45 43 54 20 4F CE 29 88 20 49 44 85 30 31 32 33 34 D3 59 4E 54 41 58 89 60 8A 03 84 63 83 20 45 58 49 53 54 D3 64 83 20 54 59 50 45 85 65 CE 4F 20 42 4C 4F 43 CB 66 67 C9 4C 4C 45 47 41 4C 20 54 52 41 43 4B 20 4F 52 20 53 45 43 54 4F D2 61 83 06 84 39 62 83 06 87 01 83 53 20 53 43 52 41 54 43 48 45 C4 70 CE 4F 20 43 48 41 4E 4E 45 CC 71 C4 49 52 89 72 88 20 46 55 4C CC 73 C3 42 4D 20 44 4F 53 20 56 32 2E 36 20 31 35 34 B1 74 C4 52 49 56 45 06 20 52 45 41 44 D9</td>
				<td class="fit"></td><td rowspan="1"><h1>Error message table $E4FC - $E5D4</h1>
<p>Each entry consists of the applicable error numbers
followed by the message test with the first and last
characters OR'ed with $80. The key words in the text
are tokenized (values $80 - $8F). The tokenized word
list follows the main error message table.</p>
<pre><code>Error numbers            | Error Message
-------------------------|------------------------
$00                      | OK
$20,$21,$22,$23,$24,$27  | READ ERROR
$52                      | FILE TOO LARGE
$50                      | RECORD NOT PRESENT
$51                      | OVERFLOW IN RECORD
$25, $28                 | WRITE ERROR
$26                      | WRITE PROTECT ON
$29                      | DISK ID MISMATCH
$30,$31,$32,$33,$34      | SYNTAX ERROR
$60                      | WRITE FILE OPEN
$63                      | FILE EXISTS
$64                      | FILE TYPE MISMATCH
$65                      | NO BLOCK
$66,$67                  | ILLEGAL TRACK OR SECTOR
$61                      | FILE NOT OPEN
$39                      | FILE NOT FOUND
$01                      | FILES SCRATCHED
$70                      | NO CHANNEL
$71                      | DIR ERROR
$72                      | DISK FULL
$73                      | CBM DOS V2.6 4030
$74                      | DRIVE NOT READY</code></pre>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E5D5</td>
				<td>09 C5 52 52 4F D2 0A D7 52 49 54 C5 03 C6 49 4C C5 04 CF 50 45 CE 05 CD 49 53 4D 41 54 43 C8 06 CE 4F D4 07 C6 4F 55 4E C4 08 C4 49 53 CB 0B D2 45 43 4F 52 C4</td>
				<td class="fit"></td><td rowspan="1"><h1>Table of tokenized words $E5D5 - $E609</h1>
<pre><code>$09 ERROR
$0A WRITE
$03 FILE
$04 OPEN
$05 MISMATCH
$06 NOT
$07 FOUND
$08 DISK
$0B RECORD</code></pre>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Handle errors reported by controller</h1>
<pre><code>On entry: .A = error code number
	  .X = job number</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERROR</td><td class="fit">E60A</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save the error code onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E60B</td>
				<td>86 F9</td>
				<td class="fit">STX $F9</td><td rowspan="1"><p>Store the job number into JOBNUM ($F9) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E60D</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer job number (from .X) to .A,
multiply it by 2 (ASL). and transfer the
result back into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">E60E</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">E60F</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E610</td>
				<td>B5 06</td>
				<td class="fit">LDA $06,X</td><td rowspan="4"><p>Set TRACK ($80) and SECTOR ($81) using
the values from the last header read in
HDRS,X ($06, X) and HDRS+1,X ($07, X).</p>
</td></tr>
				<tr><td></td><td class="fit">E612</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
				<tr><td></td><td class="fit">E614</td>
				<td>B5 07</td>
				<td class="fit">LDA $07,X</td></tr>
				<tr><td></td><td class="fit">E616</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E618</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the disk controller error code off
the stack and convert it into a DOS
error code by:</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E619</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="2"><p>AND the error code in .A with $0F. If
the result is $00, branch to ERR1 to
handle error codes $10 - $14.</p>
</td></tr>
				<tr><td></td><td class="fit">E61B</td>
				<td>F0 08</td>
				<td class="fit">BEQ $E625</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E61D</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td><td rowspan="2"><p>Compare the result to $0F (no drive) .
If the code is NOT $0F, branch to ERR2 .</p>
</td></tr>
				<tr><td></td><td class="fit">E61F</td>
				<td>D0 06</td>
				<td class="fit">BNE $E627</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E621</td>
				<td>A9 74</td>
				<td class="fit">LDA #$74</td><td rowspan="2"><p>Load .A with $74 (DOS no drive code)
and branch to ERR3 (always) .</p>
</td></tr>
				<tr><td></td><td class="fit">E623</td>
				<td>D0 08</td>
				<td class="fit">BNE $E62D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERR1</td><td class="fit">E625</td>
				<td>A9 06</td>
				<td class="fit">LDA #$06</td><td rowspan="1"><p>Load .A with $06.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERR2</td><td class="fit">E627</td>
				<td>09 20</td>
				<td class="fit">ORA #$20</td><td rowspan="5"><p>OR the code in .A with $20 and subtract
2 from the result.</p>
</td></tr>
				<tr><td></td><td class="fit">E629</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">E62A</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">E62B</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">E62C</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERR3</td><td class="fit">E62D</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save the DOS error code onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E62E</td>
				<td>AD 2A 02</td>
				<td class="fit">LDA $022A</td><td rowspan="3"><p>Compare the command number from CMDNUM
($022A) with $00 to see if this was a
VALIDATE command. If not, branch to ERR4</p>
</td></tr>
				<tr><td></td><td class="fit">E631</td>
				<td>C9 00</td>
				<td class="fit">CMP #$00</td></tr>
				<tr><td></td><td class="fit">E633</td>
				<td>D0 0F</td>
				<td class="fit">BNE $E644</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E635</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Set CMDNUM ($022A) to $FF.</p>
</td></tr>
				<tr><td></td><td class="fit">E637</td>
				<td>8D 2A 02</td>
				<td class="fit">STA $022A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E63A</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the DOS error code off the stack
and JSR to ERRMSG ($E6C7) to transfer
the error message to the error buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E63B</td>
				<td>20 C7 E6</td>
				<td class="fit">JSR $E6C7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E63E</td>
				<td>20 42 D0</td>
				<td class="fit">JSR $D042</td><td rowspan="1"><p>JSR to INITDR ($D042) to initialize the
drive and eliminate the bad BAM in RAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E641</td>
				<td>4C 48 E6</td>
				<td class="fit">JMP $E648</td><td rowspan="1"><p>JMP to CMDER3 ($E648) to complete the
error handling.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERR4</td><td class="fit">E644</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the DOS error code off the stack. *</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMDER2</td><td class="fit">E645</td>
				<td>20 C7 E6</td>
				<td class="fit">JSR $E6C7</td><td rowspan="1"><p>JSR to ERRMSG ($E6C7) to transfer the
the error message to the error buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMDER3</td><td class="fit">E648</td>
				<td>20 BD C1</td>
				<td class="fit">JSR $C1BD</td><td rowspan="1"><p>JSR to CLRCB ($C1BD) to clear out the
command buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E64B</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Clear the write-BAM flag, WBAM ($02F9)
so a bad copy of the BAM will not be
written to disk.</p>
</td></tr>
				<tr><td></td><td class="fit">E64D</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E650</td>
				<td>20 2C C1</td>
				<td class="fit">JSR $C12C</td><td rowspan="1"><p>JSR to ERRON ($C12C) to start the error
LED flashing.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E653</td>
				<td>20 DA D4</td>
				<td class="fit">JSR $D4DA</td><td rowspan="1"><p>JSR to FREICH ($D4DA) to free the
internal read or write channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E656</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero BUFTAB+CBPTR ($A3) to clear the
pointers .</p>
</td></tr>
				<tr><td></td><td class="fit">E658</td>
				<td>85 A3</td>
				<td class="fit">STA $A3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E65A</td>
				<td>A2 45</td>
				<td class="fit">LDX #$45</td><td rowspan="2"><p>Load .X with $45 (#TOPWRT) and transfer
this value to the STACK POINTER to purge
the stack</p>
</td></tr>
				<tr><td></td><td class="fit">E65C</td>
				<td>9A</td>
				<td class="fit">TXS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E65D</td>
				<td>A5 84</td>
				<td class="fit">LDA $84</td><td rowspan="3"><p>Load .A with the original secondary
address from ORGSA ($84). AND it with
$0F, and store the result as the current
secondary address in SA ($83).</p>
</td></tr>
				<tr><td></td><td class="fit">E65F</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">E661</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E663</td>
				<td>C9 0F</td>
				<td class="fit">CMP #$0F</td><td rowspan="2"><p>Compare the secondary address (in .A)
with $0F. If it is $0F (the command
channel), branch to ERR10.</p>
</td></tr>
				<tr><td></td><td class="fit">E665</td>
				<td>F0 31</td>
				<td class="fit">BEQ $E698</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E667</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set the interrupt flag to prevent any
interrupts !</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E668</td>
				<td>A5 79</td>
				<td class="fit">LDA $79</td><td rowspan="2"><p>If the listener active flag in LSNACT
($79) is not $00, we are an active
listener so branch to LSNERR.</p>
</td></tr>
				<tr><td></td><td class="fit">E66A</td>
				<td>D0 1C</td>
				<td class="fit">BNE $E688</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E66C</td>
				<td>A5 7A</td>
				<td class="fit">LDA $7A</td><td rowspan="2"><p>If the talker active flag in TLKACT
($7A) is not $00, we are an active
talker so branch to TLKERR.</p>
</td></tr>
				<tr><td></td><td class="fit">E66E</td>
				<td>D0 10</td>
				<td class="fit">BNE $E680</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E670</td>
				<td>A6 83</td>
				<td class="fit">LDX $83</td><td rowspan="1"><p>Load .X with the current secondary
address from SA ($83) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E672</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td><td rowspan="3"><p>Load .A with the active channel number
from LINTAB,X ($022B / X). If this channel
number is $FF, the channel is inactive
so branch to ERR10.</p>
</td></tr>
				<tr><td></td><td class="fit">E675</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">E677</td>
				<td>F0 1F</td>
				<td class="fit">BEQ $E698</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E679</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="3"><p>AND the channel number (in .A) with $0F,
store it as the current channel number
in LINDX ($82) and JMP to TLERR ($E68E).</p>
</td></tr>
				<tr><td></td><td class="fit">E67B</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
				<tr><td></td><td class="fit">E67D</td>
				<td>4C 8E E6</td>
				<td class="fit">JMP $E68E</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Talker error recovery</h1>
<p>Release all bus lines and go idle.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TLKERR</td><td class="fit">E680</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E683</td>
				<td>20 4E EA</td>
				<td class="fit">JSR $EA4E</td><td rowspan="2"><p>JSR to ITERR ($EA4E) to release all bus
lines and JMP to IDLE ($EBE7) .</p>
</td></tr>
				<tr><td></td><td class="fit">E686</td>
				<td>D0 06</td>
				<td class="fit">BNE $E68E</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Listener error recovery</h1>
<p>Release all bus lines and go idle.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LSNERR</td><td class="fit">E688</td>
				<td>20 07 D1</td>
				<td class="fit">JSR $D107</td><td rowspan="1"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E68B</td>
				<td>20 4E EA</td>
				<td class="fit">JSR $EA4E</td><td rowspan="1"><p>JSR to ITERR ($EA4E) to release all bus
lines and JMP to IDLE ($EBE7) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TLERR</td><td class="fit">E68E</td>
				<td>20 25 D1</td>
				<td class="fit">JSR $D125</td><td rowspan="4"><p>Unused on the 1541</p>
</td></tr>
				<tr><td></td><td class="fit">E691</td>
				<td>C9 04</td>
				<td class="fit">CMP #$04</td></tr>
				<tr><td></td><td class="fit">E693</td>
				<td>B0 03</td>
				<td class="fit">BCS $E698</td></tr>
				<tr><td></td><td class="fit">E695</td>
				<td>20 27 D2</td>
				<td class="fit">JSR $D227</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERR10</td><td class="fit">E698</td>
				<td>4C E7 EB</td>
				<td class="fit">JMP $EBE7</td><td rowspan="1"><p>Terminate routine with a JMP to IDLE
($EBE7) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert hex to BCD</h1>
<pre><code>On entry: .A contains hex number
On exit: .A contains BCD number</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HEXDEC</td><td class="fit">E69B</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer hex from .A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E69C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and set decimal mode (SED) .</p>
</td></tr>
				<tr><td></td><td class="fit">E69E</td>
				<td>F8</td>
				<td class="fit">SED</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HEX0</td><td class="fit">E69F</td>
				<td>E0 00</td>
				<td class="fit">CPX #$00</td><td rowspan="2"><p>Compare .X value to $00. If equal,
branch to HEX5 to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">E6A1</td>
				<td>F0 07</td>
				<td class="fit">BEQ $E6AA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6A3</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="4"><p>Clear carry flag, add 1 to value in .A
decrement .X, and JMP backto HEX0.</p>
</td></tr>
				<tr><td></td><td class="fit">E6A4</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
				<tr><td></td><td class="fit">E6A6</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">E6A7</td>
				<td>4C 9F E6</td>
				<td class="fit">JMP $E69F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">HEX5</td><td class="fit">E6AA</td>
				<td>D8</td>
				<td class="fit">CLD</td><td rowspan="1"><p>Clear decimal mode (CLD) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert BCD to ASCII decimal digit</h1>
<pre><code>On exit: .X contains BCD number
	 (CB+2)Y contains ASCII</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BCDDEC</td><td class="fit">E6AB</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer BCD from .A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6AC</td>
				<td>4A</td>
				<td class="fit">LSR</td><td rowspan="4"><p>Divide BCD value in .X by 16 (4 x LSR)</p>
</td></tr>
				<tr><td></td><td class="fit">E6AD</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">E6AE</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">E6AF</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6B0</td>
				<td>20 B4 E6</td>
				<td class="fit">JSR $E6B4</td><td rowspan="1"><p>JSR to BCD2 ($E6B4) to convert the most
significant digit to ASCII.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6B3</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Transfer original BCD byte from .X to .A</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BCD2</td><td class="fit">E6B4</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="3"><p>AND the BCD value in .A with $0F to mask
off the higher order nybble, OR the
result with $30 (convert to ASCII), and
store the ASCII value in (CB+2)Y; ($A5)Y</p>
</td></tr>
				<tr><td></td><td class="fit">E6B6</td>
				<td>09 30</td>
				<td class="fit">ORA #$30</td></tr>
				<tr><td></td><td class="fit">E6B8</td>
				<td>91 A5</td>
				<td class="fit">STA ($A5),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6BA</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6BB</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">OKERR</td><td class="fit">E6BC</td>
				<td>20 23 C1</td>
				<td class="fit">JSR $C123</td><td rowspan="1"><p>Transfer error message to error buffer:
JSR to ERROFF ($C123) to turn off error
LED.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6BF</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="1"><p>Load .A with $00 (no error) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERRTSO</td><td class="fit">E6C1</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="3"><p>Set TRACK ($80) and SECTOR ($81) to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">E6C3</td>
				<td>84 80</td>
				<td class="fit">STY $80</td></tr>
				<tr><td></td><td class="fit">E6C5</td>
				<td>84 81</td>
				<td class="fit">STY $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERRMSG</td><td class="fit">E6C7</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Load .Y with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6C9</td>
				<td>A2 D5</td>
				<td class="fit">LDX #$D5</td><td rowspan="4"><p>Set pointer at CB+2/3 ($A5/6) to point
to the error buffer ($02D5).</p>
</td></tr>
				<tr><td></td><td class="fit">E6CB</td>
				<td>86 A5</td>
				<td class="fit">STX $A5</td></tr>
				<tr><td></td><td class="fit">E6CD</td>
				<td>A2 02</td>
				<td class="fit">LDX #$02</td></tr>
				<tr><td></td><td class="fit">E6CF</td>
				<td>86 A6</td>
				<td class="fit">STX $A6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6D1</td>
				<td>20 AB E6</td>
				<td class="fit">JSR $E6AB</td><td rowspan="1"><p>JSR to BCDDEC ($E6AB) to convert the
BCD number in .A to ASCII and store it
at the start of the error buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6D4</td>
				<td>A9 2C</td>
				<td class="fit">LDA #$2C</td><td rowspan="2"><p>Store $2C &quot;. &quot; after the error code in
the error buffer (CB+2) ,Y; ($A5) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E6D6</td>
				<td>91 A5</td>
				<td class="fit">STA ($A5),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6D8</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y (points into error buffer) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6D9</td>
				<td>AD D5 02</td>
				<td class="fit">LDA $02D5</td><td rowspan="2"><p>Copy the first character of the error
buffer from ERRBUF ($02D5) into the
channel data area CHNDAT+ERRCHN ($0243).</p>
</td></tr>
				<tr><td></td><td class="fit">E6DC</td>
				<td>8D 43 02</td>
				<td class="fit">STA $0243</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6DF</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer the error number from .X to .A
and JSR to ERMOVE ($E706) to move the
error message into the error buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">E6E0</td>
				<td>20 06 E7</td>
				<td class="fit">JSR $E706</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6E3</td>
				<td>A9 2C</td>
				<td class="fit">LDA #$2C</td><td rowspan="2"><p>Store $2C &quot;. &quot; after the error message in
the error buffer (CB+2),Y; ($A5),Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E6E5</td>
				<td>91 A5</td>
				<td class="fit">STA ($A5),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6E7</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y (points into error buffer) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6E8</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="1"><p>Load .A with the track number from
TRACK ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6EA</td>
				<td>20 9B E6</td>
				<td class="fit">JSR $E69B</td><td rowspan="1"><p>JSR to BCDDEC ($E6AB) to convert the
track number in .A to ASCII and store
it in the error buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6ED</td>
				<td>A9 2C</td>
				<td class="fit">LDA #$2C</td><td rowspan="2"><p>Store $2C &quot;. &quot; after the track number in
the error buffer (CB+2),Y; ($A5),Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E6EF</td>
				<td>91 A5</td>
				<td class="fit">STA ($A5),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6F1</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y (points into error buffer) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6F2</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="1"><p>Load .A with the sector number from
SECTOR ($81) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6F4</td>
				<td>20 9B E6</td>
				<td class="fit">JSR $E69B</td><td rowspan="1"><p>JSR to BCDDEC ($E6AB) to convert the
sector number in .A to ASCII and store
it in the error buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6F7</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="5"><p>Decrement the .Y pointer by 1, transfer
the result to .A, clear the carry flag,
add $D5 (the start of the error buffer) ,
and store the final result (points to
the last character) into LSTCHR+ERRCHN
($0249) .</p>
</td></tr>
				<tr><td></td><td class="fit">E6F8</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">E6F9</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">E6FA</td>
				<td>69 D5</td>
				<td class="fit">ADC #$D5</td></tr>
				<tr><td></td><td class="fit">E6FC</td>
				<td>8D 49 02</td>
				<td class="fit">STA $0249</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E6FF</td>
				<td>E6 A5</td>
				<td class="fit">INC $A5</td><td rowspan="1"><p>Increment the lo byte of the pointer
in CB+2 ($A5) by 1 so it points to the
second character of the message (we put
the first character into the channel
data area already.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E701</td>
				<td>A9 88</td>
				<td class="fit">LDA #$88</td><td rowspan="2"><p>Set error channel status CHNRDY+ERRCHN
($F7) to $88 to indicate that it is
ready-to-talk.</p>
</td></tr>
				<tr><td></td><td class="fit">E703</td>
				<td>85 F7</td>
				<td class="fit">STA $F7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E705</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERMOVE</td><td class="fit">E706</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Move the error message from the error
table to the error buffer. The tokens
in the table are converted to words
Transfer the error message number from
.A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E707</td>
				<td>A5 86</td>
				<td class="fit">LDA $86</td><td rowspan="4"><p>Save the current values of R0 ($86) and
R0+1 ($87) onto the stack so we can use
this as a temporary pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">E709</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">E70A</td>
				<td>A5 87</td>
				<td class="fit">LDA $87</td></tr>
				<tr><td></td><td class="fit">E70C</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E70D</td>
				<td>A9 FC</td>
				<td class="fit">LDA #$FC</td><td rowspan="4"><p>Set up a pointer in R0/R0+1 to point to
the error message table in ROM ($E4FC) .</p>
</td></tr>
				<tr><td></td><td class="fit">E70F</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
				<tr><td></td><td class="fit">E711</td>
				<td>A9 E4</td>
				<td class="fit">LDA #$E4</td></tr>
				<tr><td></td><td class="fit">E713</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E715</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Transfer the error number back into .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E716</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="1"><p>Zero .X to use as an indirect pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E10</td><td class="fit">E718</td>
				<td>C1 86</td>
				<td class="fit">CMP ($86,X)</td><td rowspan="2"><p>Compare the error number (in .A) with
the error number in the table (R0,X)
($86, X). If a match is found, branch
to E50.</p>
</td></tr>
				<tr><td></td><td class="fit">E71A</td>
				<td>F0 21</td>
				<td class="fit">BEQ $E73D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E71C</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save error number onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E71D</td>
				<td>20 75 E7</td>
				<td class="fit">JSR $E775</td><td rowspan="1"><p>JSR to EADV2 ($E775) to advance the
pointer to the error table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E720</td>
				<td>90 05</td>
				<td class="fit">BCC $E727</td><td rowspan="1"><p>If carry flag is clear, there are more
messages to check so branch to E30</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E20</td><td class="fit">E722</td>
				<td>20 75 E7</td>
				<td class="fit">JSR $E775</td><td rowspan="1"><p>No more messages so JSR to EADV2 ($E775)
to advance the pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E725</td>
				<td>90 FB</td>
				<td class="fit">BCC $E722</td><td rowspan="1"><p>If carry flag is clear, we are not done
with the message yet so branch to E20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E30</td><td class="fit">E727</td>
				<td>A5 87</td>
				<td class="fit">LDA $87</td><td rowspan="4"><p>Compare the hi byte of the pointer in
R0+1 ($87) to $E6. If the pointer is
less than $E6, there is more table left
so branch to E40. If the pointer is
greater then $E6, we are past the end
the table so branch to E45.</p>
</td></tr>
				<tr><td></td><td class="fit">E729</td>
				<td>C9 E6</td>
				<td class="fit">CMP #$E6</td></tr>
				<tr><td></td><td class="fit">E72B</td>
				<td>90 08</td>
				<td class="fit">BCC $E735</td></tr>
				<tr><td></td><td class="fit">E72D</td>
				<td>D0 0A</td>
				<td class="fit">BNE $E739</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E72F</td>
				<td>A9 0A</td>
				<td class="fit">LDA #$0A</td><td rowspan="3"><p>The hi bytes match so compare the lo
bytes of the pointer in R0 ($86) with
$0A (the end of the table). If we are
past the end, branch to E45.</p>
</td></tr>
				<tr><td></td><td class="fit">E731</td>
				<td>C5 86</td>
				<td class="fit">CMP $86</td></tr>
				<tr><td></td><td class="fit">E733</td>
				<td>90 04</td>
				<td class="fit">BCC $E739</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E40</td><td class="fit">E735</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the error number off the stack and
JMP to E10 to continue checking.</p>
</td></tr>
				<tr><td></td><td class="fit">E736</td>
				<td>4C 18 E7</td>
				<td class="fit">JMP $E718</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E45</td><td class="fit">E739</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Can't find error number in table so
pop the error number off the stack and
JMP to E90 ($E74D) to quit.</p>
</td></tr>
				<tr><td></td><td class="fit">E73A</td>
				<td>4C 4D E7</td>
				<td class="fit">JMP $E74D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E50</td><td class="fit">E73D</td>
				<td>20 67 E7</td>
				<td class="fit">JSR $E767</td><td rowspan="1"><p>The error number has been located so
JSR to EADV1 ($E767) to advance past
the other error numbers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E740</td>
				<td>90 FB</td>
				<td class="fit">BCC $E73D</td><td rowspan="1"><p>If carry flag is clear, we have not-
advanced far enough so branch to E50.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E55</td><td class="fit">E742</td>
				<td>20 54 E7</td>
				<td class="fit">JSR $E754</td><td rowspan="1"><p>JSR to E60 ($E754) to check for token
and put character (s) into buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E745</td>
				<td>20 67 E7</td>
				<td class="fit">JSR $E767</td><td rowspan="1"><p>JSR to EADV1 ($E767) to advance pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E748</td>
				<td>90 F8</td>
				<td class="fit">BCC $E742</td><td rowspan="1"><p>If carry flag is clear, there is more to
do so branch back to E55.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E74A</td>
				<td>20 54 E7</td>
				<td class="fit">JSR $E754</td><td rowspan="1"><p>JSR to E60 ($E754) to check for token
or last word.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E90</td><td class="fit">E74D</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>All done! Pull original RO and RO+1
values off the stack and replace them.</p>
</td></tr>
				<tr><td></td><td class="fit">E74E</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
				<tr><td></td><td class="fit">E750</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">E751</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E753</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Sub to check for token or word and put it into the buffer.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E60</td><td class="fit">E754</td>
				<td>C9 20</td>
				<td class="fit">CMP #$20</td><td rowspan="2"><p>Compare the character in .A with $20
(the maximum token number +1). If .A is
greater, this is not a token so branch
to E70.</p>
</td></tr>
				<tr><td></td><td class="fit">E756</td>
				<td>B0 0B</td>
				<td class="fit">BCS $E763</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E758</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Save token (in .A) into .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E759</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Store $20 (implied leading space) into
the buffer at (CB+2),Y; ($A5),Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E75B</td>
				<td>91 A5</td>
				<td class="fit">STA ($A5),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E75D</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E75E</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Move the token from .X back into .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E75F</td>
				<td>20 06 E7</td>
				<td class="fit">JSR $E706</td><td rowspan="1"><p>JSR to ERMOVE ($E706) to add the token
word to the message.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E762</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">E70</td><td class="fit">E763</td>
				<td>91 A5</td>
				<td class="fit">STA ($A5),Y</td><td rowspan="1"><p>Store character (in .A) into the buffer
at. (CB + 2) ,Y; ($A5) ,Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E765</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y pointer into error buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E766</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Advance error pointer before move</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">EADV1</td><td class="fit">E767</td>
				<td>E6 86</td>
				<td class="fit">INC $86</td><td rowspan="2"><p>Increment the lo byte of the pointer in
RO ($86). If the new value is not $00,
branch to EA10.</p>
</td></tr>
				<tr><td></td><td class="fit">E769</td>
				<td>D0 02</td>
				<td class="fit">BNE $E76D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E76B</td>
				<td>E6 87</td>
				<td class="fit">INC $87</td><td rowspan="1"><p>Increment the hi byte of the pointer in
RO+1 ($87).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">EA10</td><td class="fit">E76D</td>
				<td>A1 86</td>
				<td class="fit">LDA ($86,X)</td><td rowspan="1"><p>Load .A with the next character from
the error message table (R0,X); ($A1,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E76F</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="1"><p>Shift the byte in .A left to set the
carry flag if this is the first or last
character in the message.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E770</td>
				<td>A1 86</td>
				<td class="fit">LDA ($86,X)</td><td rowspan="1"><p>Load .A with the next character from
the error message table (R0,X); ($A1,X),</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E772</td>
				<td>29 7F</td>
				<td class="fit">AND #$7F</td><td rowspan="1"><p>AND the character in .A with $7F to mask
off bit 7.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E774</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Advance error pointer after move</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">EADV2</td><td class="fit">E775</td>
				<td>20 6D E7</td>
				<td class="fit">JSR $E76D</td><td rowspan="1"><p>JSR to EA10 ($E76D) to get the next
byte from the error message table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E778</td>
				<td>E6 86</td>
				<td class="fit">INC $86</td><td rowspan="2"><p>Increment the lo byte of the pointer in
RO ($86). If the new value is not $00,
branch to EA20.</p>
</td></tr>
				<tr><td></td><td class="fit">E77A</td>
				<td>D0 02</td>
				<td class="fit">BNE $E77E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E77C</td>
				<td>E6 87</td>
				<td class="fit">INC $87</td><td rowspan="1"><p>Increment the hi byte of the pointer in
R0+1 ($87) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">EA20</td><td class="fit">E77E</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Utility loader program</h1>
<p>This utility is used to load and execute user proarams
or system utilities from disk.</p>
<p>This utility may be used in two ways:
a) On power-up:
If the data and clock lines are grounded at power up,
the routine is entered. It waits until the ground clip
is removed and then loads the first file found in the
directory into disk RAM using the first two bytes of
the file as the load address. Once the file is loaded,
it is executed starting at the first byte.
b) Normal entry:
The disk command &quot;&amp;: filename&quot; will load and execute
the file whose filename is specified. For examole:
PRINT#15,&quot;&amp;0:DISK TASK&quot;</p>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h2>File structure:</h2>
<p>The utility or program must be of the following form.</p>
<pre><code>File type: USR
Bytes 1/2: Load address in disk RAM (lo/hi).
Byte 3:    Lo byte of the length of the routine
Bytes 4/N: Disk routine machine code.
Byte N+1:  Checksum. Note that the checksum includes
           all bytes including the load address.
Formula: CHECKSUM = CHECKSUM + BYTE + CARRY</code></pre>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: Routines may be longer than 256 bytes. However,
      there MUST be a valid checksum byte after the
      number of bytes specified in byte #3 and after
      each subsequent 256 bytes!</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BOOT2</td><td class="fit">E77F</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BOOT</td><td class="fit">E780</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="2"><p>Load .A with input port data from PB
($1800). Transfer data from .A to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">E783</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E784</td>
				<td>29 04</td>
				<td class="fit">AND #$04</td><td rowspan="2"><p>AND the data byte (in .A) with $04 to
see if clock is grounded. If not, branch
to BOOT2 to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">E786</td>
				<td>F0 F7</td>
				<td class="fit">BEQ $E77F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E788</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Transfer data byte from .X to .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E789</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the data byte (in .A) with $01 to
see if data line is grounded. If not,
branch to BOOT2 to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">E78B</td>
				<td>F0 F2</td>
				<td class="fit">BEQ $E77F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E78D</td>
				<td>58</td>
				<td class="fit">CLI</td><td rowspan="1"><p>Clear interrupt flag so that background
routines will run.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Boot clip must be on!</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BOOT3</td><td class="fit">E78E</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="1"><p>Load .A with input port data from PB
($1800) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E791</td>
				<td>29 05</td>
				<td class="fit">AND #$05</td><td rowspan="2"><p>AND the data byte (in .A) with $05 to
see if clip has been removed. If not,
branch to BOOT3 to wait until it is.</p>
</td></tr>
				<tr><td></td><td class="fit">E793</td>
				<td>D0 F9</td>
				<td class="fit">BNE $E78E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E795</td>
				<td>EE 78 02</td>
				<td class="fit">INC $0278</td><td rowspan="1"><p>Set the number of files to $01 by
incrementing F2CNT ($0278).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E798</td>
				<td>EE 74 02</td>
				<td class="fit">INC $0274</td><td rowspan="1"><p>Set the command string length to $01 by
incrementing CMDSIZ ($0274).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E79B</td>
				<td>A9 2A</td>
				<td class="fit">LDA #$2A</td><td rowspan="2"><p>Set the first character in the command
buffer, CMDBUF ($0200), to $2A (&quot;*&quot;) to
match any file name.</p>
</td></tr>
				<tr><td></td><td class="fit">E79D</td>
				<td>8D 00 02</td>
				<td class="fit">STA $0200</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7A0</td>
				<td>4C A8 E7</td>
				<td class="fit">JMP $E7A8</td><td rowspan="1"><p>JMP to BOOT4 ($E7A8) to continue.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Normal entry point</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UTLODR</td><td class="fit">E7A3</td>
				<td>A9 8D</td>
				<td class="fit">LDA #$8D</td><td rowspan="2"><p>Load .A with $8D and JSR to PARSE
($C268) to parse the command string.</p>
</td></tr>
				<tr><td></td><td class="fit">E7A5</td>
				<td>20 68 C2</td>
				<td class="fit">JSR $C268</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BOOT4</td><td class="fit">E7A8</td>
				<td>20 58 F2</td>
				<td class="fit">JSR $F258</td><td rowspan="1"><p>JSR to KILLP ($F258) to kill protect.
Does nothing on the 15 41!</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7AB</td>
				<td>AD 78 02</td>
				<td class="fit">LDA $0278</td><td rowspan="2"><p>Load .A with the file count from F2CNT
($0278) and save it on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E7AE</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7AF</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Set file count in F2CNT ($0278) to $01.</p>
</td></tr>
				<tr><td></td><td class="fit">E7B1</td>
				<td>8D 78 02</td>
				<td class="fit">STA $0278</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7B4</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Set first-byte flag in R0 ($86) to $FF.</p>
</td></tr>
				<tr><td></td><td class="fit">E7B6</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7B8</td>
				<td>20 4F C4</td>
				<td class="fit">JSR $C44F</td><td rowspan="1"><p>JSR to LOOKUP($C44F) to locate the file
name on the disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7BB</td>
				<td>AD 80 02</td>
				<td class="fit">LDA $0280</td><td rowspan="2"><p>Check the track link for the file found
in FILTRK ($0280). If it is $00, the
file was not found so branch to UTLDOO.</p>
</td></tr>
				<tr><td></td><td class="fit">E7BE</td>
				<td>D0 05</td>
				<td class="fit">BNE $E7C5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7C0</td>
				<td>A9 39</td>
				<td class="fit">LDA #$39</td><td rowspan="2"><p>Load .A with $39 to indicate a FILE NOT
FOUND error and JSR to CMDERR ($C1C8) to
exit.</p>
</td></tr>
				<tr><td></td><td class="fit">E7C2</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UTLD00</td><td class="fit">E7C5</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull original file count off the stack
and restore it into F2CNT ($0278) .</p>
</td></tr>
				<tr><td></td><td class="fit">E7C6</td>
				<td>8D 78 02</td>
				<td class="fit">STA $0278</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7C9</td>
				<td>AD 80 02</td>
				<td class="fit">LDA $0280</td><td rowspan="2"><p>Set TRACK ($80) from the track link
for the file from FILTRK ($0280) .</p>
</td></tr>
				<tr><td></td><td class="fit">E7CC</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7CE</td>
				<td>AD 85 02</td>
				<td class="fit">LDA $0285</td><td rowspan="2"><p>Set SECTOR ($81) from the sector link
for the file from FILSEC ($0285) .</p>
</td></tr>
				<tr><td></td><td class="fit">E7D1</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7D3</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td><td rowspan="2"><p>Load .A with $03 (USER FILE TYPE) and
JSR to OPNTYP ($D477) to open the file.</p>
</td></tr>
				<tr><td></td><td class="fit">E7D5</td>
				<td>20 77 D4</td>
				<td class="fit">JSR $D477</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UTLD10</td><td class="fit">E7D8</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and store it in Rl($87)
to initialize the checksum.</p>
</td></tr>
				<tr><td></td><td class="fit">E7DA</td>
				<td>85 87</td>
				<td class="fit">STA $87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7DC</td>
				<td>20 39 E8</td>
				<td class="fit">JSR $E839</td><td rowspan="1"><p>JSR to GTABYT ($E839) to get the first
byte from the file (lo of load address),</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7DF</td>
				<td>85 88</td>
				<td class="fit">STA $88</td><td rowspan="1"><p>Store the lo byte of the load address
in R2 ($88) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7E1</td>
				<td>20 4B E8</td>
				<td class="fit">JSR $E84B</td><td rowspan="1"><p>JSR to ADDSUM ($E84B) to add the byte
into the checksum.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7E4</td>
				<td>20 39 E8</td>
				<td class="fit">JSR $E839</td><td rowspan="1"><p>JSR to GTABYT ($E839) to get the second
byte from the file (hi of load address) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7E7</td>
				<td>85 89</td>
				<td class="fit">STA $89</td><td rowspan="1"><p>Store the hi byte of the load address
in R3 ($89) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7E9</td>
				<td>20 4B E8</td>
				<td class="fit">JSR $E84B</td><td rowspan="1"><p>JSR to ADDSUM ($E84B) to add the byte
into the checksum.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7EC</td>
				<td>A5 86</td>
				<td class="fit">LDA $86</td><td rowspan="2"><p>Load .A with the flag from RO ($86). If
the flag is $00, this is not the load
address so branch to UTLD20.</p>
</td></tr>
				<tr><td></td><td class="fit">E7EE</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $E7FA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7F0</td>
				<td>A5 88</td>
				<td class="fit">LDA $88</td><td rowspan="2"><p>Load lo byte of load address from R2
($88) and save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E7F2</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7F3</td>
				<td>A5 89</td>
				<td class="fit">LDA $89</td><td rowspan="2"><p>Load hi byte of load address from R3
($89) and save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E7F5</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7F6</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set first-byte flag in RO ($86) to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">E7F8</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UTLD20</td><td class="fit">E7FA</td>
				<td>20 39 E8</td>
				<td class="fit">JSR $E839</td><td rowspan="1"><p>JSR to GTABYT ($E839) to get the data
byte count from the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7FD</td>
				<td>85 8A</td>
				<td class="fit">STA $8A</td><td rowspan="1"><p>Store the data byte count in R4 ($8A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E7FF</td>
				<td>20 4B E8</td>
				<td class="fit">JSR $E84B</td><td rowspan="1"><p>JSR to ADDSUM ($E84B) to add the byte
into the checksum.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UTLD30</td><td class="fit">E802</td>
				<td>20 39 E8</td>
				<td class="fit">JSR $E839</td><td rowspan="1"><p>JSR to GTABYT ($E839) to get a data byte
from the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E805</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Zero .Y and store the data byte (in .A)
at desired address, (R2),Y; ($88), Y.</p>
</td></tr>
				<tr><td></td><td class="fit">E807</td>
				<td>91 88</td>
				<td class="fit">STA ($88),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E809</td>
				<td>20 4B E8</td>
				<td class="fit">JSR $E84B</td><td rowspan="1"><p>JSR to ADDSUM ($E84B) to add the byte
into the checksum.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E80C</td>
				<td>A5 88</td>
				<td class="fit">LDA $88</td><td rowspan="4"><p>Increment the lo byte of the pointer in
R2 ($88) by $01. If the result is not
$00, branch to UTLD35.</p>
</td></tr>
				<tr><td></td><td class="fit">E80E</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">E80F</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
				<tr><td></td><td class="fit">E811</td>
				<td>85 88</td>
				<td class="fit">STA $88</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E813</td>
				<td>90 02</td>
				<td class="fit">BCC $E817</td><td rowspan="2"><p>Increment the hi byte of the pointer in
R3 ($89) by $01.</p>
</td></tr>
				<tr><td></td><td class="fit">E815</td>
				<td>E6 89</td>
				<td class="fit">INC $89</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UTLD35</td><td class="fit">E817</td>
				<td>C6 8A</td>
				<td class="fit">DEC $8A</td><td rowspan="2"><p>Decrement the byte counter in R4 ($8A) .
If the result is not $00, there are more
bytes to get so branch back to UTLD30.</p>
</td></tr>
				<tr><td></td><td class="fit">E819</td>
				<td>D0 E7</td>
				<td class="fit">BNE $E802</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E81B</td>
				<td>20 35 CA</td>
				<td class="fit">JSR $CA35</td><td rowspan="1"><p>JSR to GIBYTE ($CA35) to get a data byte
from the file without an EOI check.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E81E</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="3"><p>Load .A with the checksum from DATA ($85)
and compare it with the computed check-
sum in Rl ($87), If they match, all is
OK so branch to UTLD50.</p>
</td></tr>
				<tr><td></td><td class="fit">E820</td>
				<td>C5 87</td>
				<td class="fit">CMP $87</td></tr>
				<tr><td></td><td class="fit">E822</td>
				<td>F0 08</td>
				<td class="fit">BEQ $E82C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E824</td>
				<td>20 3E DE</td>
				<td class="fit">JSR $DE3E</td><td rowspan="1"><p>Bad checksum so JSR to GETHDR ($DE3E) to
set TRACK and SECTOR from the header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E827</td>
				<td>A9 50</td>
				<td class="fit">LDA #$50</td><td rowspan="2"><p>Load .A with $50 to indicate a NO RECORD
error and JSR to CMDER2 ($E645).</p>
</td></tr>
				<tr><td></td><td class="fit">E829</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">UTLD50</td><td class="fit">E82C</td>
				<td>A5 F8</td>
				<td class="fit">LDA $F8</td><td rowspan="2"><p>Load .A with the EOI flag from EIOFLG
($F8). If the flag is NOT $00, we are
not done yet so branch back to UTLD10
to do another 256 bytes.</p>
</td></tr>
				<tr><td></td><td class="fit">E82E</td>
				<td>D0 A8</td>
				<td class="fit">BNE $E7D8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E830</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="5"><p>Routine all loaded so pull load address
off the stack (lo/hi), set up a jump
vector in R2/3 ($88/9). and do an
indirect JMP to the routine via (R2) .</p>
</td></tr>
				<tr><td></td><td class="fit">E831</td>
				<td>85 89</td>
				<td class="fit">STA $89</td></tr>
				<tr><td></td><td class="fit">E833</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">E834</td>
				<td>85 88</td>
				<td class="fit">STA $88</td></tr>
				<tr><td></td><td class="fit">E836</td>
				<td>6C 88 00</td>
				<td class="fit">JMP ($0088)</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Subroutines for UTLODR</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GTABYT</td><td class="fit">E839</td>
				<td>20 35 CA</td>
				<td class="fit">JSR $CA35</td><td rowspan="1"><p>Get a byte from the file opened using
the internal read channel. There is an
end-of-file check done. If EOI occurs,
a #51 DOS error is reported.
JSR to GIBYTE ($CA35) to fetch a byte
and store it in DATA ($85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E83C</td>
				<td>A5 F8</td>
				<td class="fit">LDA $F8</td><td rowspan="2"><p>Test the end of information flag, EOIFLG
($F8). If NOT $00, we have not come to
the end so branch to GTABYE.</p>
</td></tr>
				<tr><td></td><td class="fit">E83E</td>
				<td>D0 08</td>
				<td class="fit">BNE $E848</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E840</td>
				<td>20 3E DE</td>
				<td class="fit">JSR $DE3E</td><td rowspan="1"><p>We have an EOI condition. JSR to GETHDR
($DE3E) to set TRACK and SECTOR from
the header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E843</td>
				<td>A9 51</td>
				<td class="fit">LDA #$51</td><td rowspan="2"><p>Load .A with $51 to indicate a RECORD
SIZE error and JSR to CMDER2 ($E645).</p>
</td></tr>
				<tr><td></td><td class="fit">E845</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GTABYE</td><td class="fit">E848</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the byte from DATA ($85)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E84A</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ADDSUM</td><td class="fit">E84B</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Compute the running checksum in R1:
On entry: .A = new byte to add
Clear the carry flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E84C</td>
				<td>65 87</td>
				<td class="fit">ADC $87</td><td rowspan="2"><p>Add the byte in Rl ($8 7) to the byte in
.A and then add $00 to the result to
add in the carry bit.</p>
</td></tr>
				<tr><td></td><td class="fit">E84E</td>
				<td>69 00</td>
				<td class="fit">ADC #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E850</td>
				<td>85 87</td>
				<td class="fit">STA $87</td><td rowspan="1"><p>Store the new checksum into Rl.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E852</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Serial bus communication routines</h1>
<p>Entry point for irq routine to service
attention (ATN) signals from the C-64.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATNIRQ</td><td class="fit">E853</td>
				<td>AD 01 18</td>
				<td class="fit">LDA $1801</td><td rowspan="1"><p>Load .A with the contents of PA1 ($1801)
to clear the interrupt (IRQ) flag (CA1).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E856</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Store $01 in ATNPND ($7C) to indicate
that an ATN request is pending.</p>
</td></tr>
				<tr><td></td><td class="fit">E858</td>
				<td>85 7C</td>
				<td class="fit">STA $7C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E85A</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Service the attention request from the C-64.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATNSRV</td><td class="fit">E85B</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set the interrupt flag (SEI) to prevent
any interrupts.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E85C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in ATNPND ($7C) to indicate
that no ATN request is pending.</p>
</td></tr>
				<tr><td></td><td class="fit">E85E</td>
				<td>85 7C</td>
				<td class="fit">STA $7C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E860</td>
				<td>85 79</td>
				<td class="fit">STA $79</td><td rowspan="2"><p>Zero the listener and talker active
flags LSNACT ($79) and TLKACT ($7A).</p>
</td></tr>
				<tr><td></td><td class="fit">E862</td>
				<td>85 7A</td>
				<td class="fit">STA $7A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E864</td>
				<td>A2 45</td>
				<td class="fit">LDX #$45</td><td rowspan="2"><p>Load .X with $45 and transfer this value
to the stack pointer to reset the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E866</td>
				<td>9A</td>
				<td class="fit">TXS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E867</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>Store $80 in the EOI flag, EOIFLG ($F8)
to indicate a non-EOI state.</p>
</td></tr>
				<tr><td></td><td class="fit">E869</td>
				<td>85 F8</td>
				<td class="fit">STA $F8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E86B</td>
				<td>85 7D</td>
				<td class="fit">STA $7D</td><td rowspan="1"><p>Store $80 in the ATN mode flag, ATNMOD
($7D) to set ATN mode for ACPT routine</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E86D</td>
				<td>20 B7 E9</td>
				<td class="fit">JSR $E9B7</td><td rowspan="1"><p>JSR to CLKHI ($E9B7) to wait for the
clock line go high.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E870</td>
				<td>20 A5 E9</td>
				<td class="fit">JSR $E9A5</td><td rowspan="1"><p>JSR to DATLOW ($E9A5) to set the data
line low as a response.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E873</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>To get hardware control of the data line
acknowledge the attention signal by:
loading .A with the contents of port B,
PB ($1800), OR the byte with $10 to set
the ACK ATN bit, and store the result-
back into port B, PB ($1800) .</p>
</td></tr>
				<tr><td></td><td class="fit">E876</td>
				<td>09 10</td>
				<td class="fit">ORA #$10</td></tr>
				<tr><td></td><td class="fit">E878</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATNS15</td><td class="fit">E87B</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="2"><p>Check to see if the ATN signal is still
present, by: loading .A with the contents
of port B, PB ($1800). If bit 7 is not
set, the ATN signal is gone so branch
to ATNS20 ($E8D7) .</p>
</td></tr>
				<tr><td></td><td class="fit">E87E</td>
				<td>10 57</td>
				<td class="fit">BPL $E8D7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E880</td>
				<td>29 04</td>
				<td class="fit">AND #$04</td><td rowspan="2"><p>AND the contents of .A with $04 to see
if the clock line is still low. If bit
2 is set (result of AND is not $00). the
clock line is still low so branch back
to ATNS15 to wait.</p>
</td></tr>
				<tr><td></td><td class="fit">E882</td>
				<td>D0 F7</td>
				<td class="fit">BNE $E87B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E884</td>
				<td>20 C9 E9</td>
				<td class="fit">JSR $E9C9</td><td rowspan="1"><p>Clock line went high so there is a
command byte waiting for us.
JSR to ACPTR (SE9C9) to get the command
byte.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E887</td>
				<td>C9 3F</td>
				<td class="fit">CMP #$3F</td><td rowspan="2"><p>Compare the command byte (in .A) with
$3F (unlisten). If this is not an
unlisten command, branch to ATN35.</p>
</td></tr>
				<tr><td></td><td class="fit">E889</td>
				<td>D0 06</td>
				<td class="fit">BNE $E891</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E88B</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>General unlisten command received.
Zero the listener active flag, LSNACT
($7A) and branch to ATN122 ($E902).</p>
</td></tr>
				<tr><td></td><td class="fit">E88D</td>
				<td>85 79</td>
				<td class="fit">STA $79</td></tr>
				<tr><td></td><td class="fit">E88F</td>
				<td>F0 71</td>
				<td class="fit">BEQ $E902</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN35</td><td class="fit">E891</td>
				<td>C9 5F</td>
				<td class="fit">CMP #$5F</td><td rowspan="2"><p>Compare the command byte (in .A) with
$5F (untalk). If this is not an untalk
command, branch to ATN40.</p>
</td></tr>
				<tr><td></td><td class="fit">E893</td>
				<td>D0 06</td>
				<td class="fit">BNE $E89B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E895</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>General untalk command received.
Zero the talker active flag, TLKACT
($7A) and branch to ATN122 ($E902).</p>
</td></tr>
				<tr><td></td><td class="fit">E897</td>
				<td>85 7A</td>
				<td class="fit">STA $7A</td></tr>
				<tr><td></td><td class="fit">E899</td>
				<td>F0 67</td>
				<td class="fit">BEQ $E902</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN40</td><td class="fit">E89B</td>
				<td>C5 78</td>
				<td class="fit">CMP $78</td><td rowspan="2"><p>Compare the command byte (in .A) with
our talk address in TLKADR ($78). If
this is not our talk address, branch to
ATN45.</p>
</td></tr>
				<tr><td></td><td class="fit">E89D</td>
				<td>D0 0A</td>
				<td class="fit">BNE $E8A9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E89F</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="5"><p>Talk command for us.
Set the talker active flag, TLKACT ($7A)
to $01, the listener active flag, LSNACT
($79) to $00, and branch to ATN95.</p>
</td></tr>
				<tr><td></td><td class="fit">E8A1</td>
				<td>85 7A</td>
				<td class="fit">STA $7A</td></tr>
				<tr><td></td><td class="fit">E8A3</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">E8A5</td>
				<td>85 79</td>
				<td class="fit">STA $79</td></tr>
				<tr><td></td><td class="fit">E8A7</td>
				<td>F0 29</td>
				<td class="fit">BEQ $E8D2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN45</td><td class="fit">E8A9</td>
				<td>C5 77</td>
				<td class="fit">CMP $77</td><td rowspan="2"><p>Compare the command byte (in .A) with
our listen address in LSNADR ($77). If
this is not our listen address, branch
to ATN5 0.</p>
</td></tr>
				<tr><td></td><td class="fit">E8AB</td>
				<td>D0 0A</td>
				<td class="fit">BNE $E8B7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8AD</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="5"><p>Listen command for us.
Set the listener active flag, LSNACT
($79) to $01, the talker active flag,
TLKACT ($7A) to $00, and branch to ATN95</p>
</td></tr>
				<tr><td></td><td class="fit">E8AF</td>
				<td>85 79</td>
				<td class="fit">STA $79</td></tr>
				<tr><td></td><td class="fit">E8B1</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">E8B3</td>
				<td>85 7A</td>
				<td class="fit">STA $7A</td></tr>
				<tr><td></td><td class="fit">E8B5</td>
				<td>F0 1B</td>
				<td class="fit">BEQ $E8D2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN50</td><td class="fit">E8B7</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Save the command byte by transferring it
from .A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8B8</td>
				<td>29 60</td>
				<td class="fit">AND #$60</td><td rowspan="3"><p>Test if the command byte is a secondary
address by AND'ing it with $60. If the
result is not $60, this is not a
secondary address so branch to ATN120.
NCTE: SA = $60 + N
A secondary address for the drive.</p>
</td></tr>
				<tr><td></td><td class="fit">E8BA</td>
				<td>C9 60</td>
				<td class="fit">CMP #$60</td></tr>
				<tr><td></td><td class="fit">E8BC</td>
				<td>D0 3F</td>
				<td class="fit">BNE $E8FD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8BE</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Transfer the original command byte from
.X back into .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8BF</td>
				<td>85 84</td>
				<td class="fit">STA $84</td><td rowspan="1"><p>Store the original secondary address
byte into ORGSA ($84).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8C1</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="2"><p>AND the secondary address (in .A) with
$0F to strip off any junk and store the
result as the current secondary address
in SA ($83) .
Test if this is a CLOSE command for this
secondary address .</p>
</td></tr>
				<tr><td></td><td class="fit">E8C3</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8C5</td>
				<td>A5 84</td>
				<td class="fit">LDA $84</td><td rowspan="4"><p>Load .A with the original secondary
address from ORGSA ($84). AND this value
with $F0 to mask off the low nybble. If
the result is not $E0, this is not a
CLOSE command so branch to ATN122.
CLOSE the file with this SA.</p>
</td></tr>
				<tr><td></td><td class="fit">E8C7</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">E8C9</td>
				<td>C9 E0</td>
				<td class="fit">CMP #$E0</td></tr>
				<tr><td></td><td class="fit">E8CB</td>
				<td>D0 35</td>
				<td class="fit">BNE $E902</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8CD</td>
				<td>58</td>
				<td class="fit">CLI</td><td rowspan="1"><p>Clear the interrupt flag (CLI) to enable
interrupts .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8CE</td>
				<td>20 C0 DA</td>
				<td class="fit">JSR $DAC0</td><td rowspan="1"><p>JSR to CLOSE ($DAC0) to close the file.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Warning: CLOSE routine does not return
	 in time to be handled by ATN122</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8D1</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set the interrupt flag (SEI) to prevent
any interrupts.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN95</td><td class="fit">E8D2</td>
				<td>2C 00 18</td>
				<td class="fit">BIT $1800</td><td rowspan="2"><p>Test if the ATN signal is still present.
If it is, branch back to ATN30.
ATN SIGNAL GONE - CARRY OUT COMMAND</p>
</td></tr>
				<tr><td></td><td class="fit">E8D5</td>
				<td>30 AD</td>
				<td class="fit">BMI $E884</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATSN20</td><td class="fit">E8D7</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in ATNMOD ($7D) to clear the
attention mode.</p>
</td></tr>
				<tr><td></td><td class="fit">E8D9</td>
				<td>85 7D</td>
				<td class="fit">STA $7D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8DB</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>Release the ATN ACK line by loading the
byte from port B, PB ($1800), AND'ing
it with $EF ($FF-ATNA), and storing the
result back into port B ($1800) .</p>
</td></tr>
				<tr><td></td><td class="fit">E8DE</td>
				<td>29 EF</td>
				<td class="fit">AND #$EF</td></tr>
				<tr><td></td><td class="fit">E8E0</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8E3</td>
				<td>A5 79</td>
				<td class="fit">LDA $79</td><td rowspan="2"><p>Test the listener active flag, LSNACT
($79) to se if we are supposed to be a
listener. If flag is $00, branch to ATN100</p>
</td></tr>
				<tr><td></td><td class="fit">E8E5</td>
				<td>F0 06</td>
				<td class="fit">BEQ $E8ED</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>BE AN ACTIVE TALKER.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8E7</td>
				<td>20 2E EA</td>
				<td class="fit">JSR $EA2E</td><td rowspan="1"><p>JSR to DATHI ($E99C) to free data line,
serial bus.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8EA</td>
				<td>4C E7 EB</td>
				<td class="fit">JMP $EBE7</td><td rowspan="1"><p>JMP to IDLE ($EBE7) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN100</td><td class="fit">E8ED</td>
				<td>A5 7A</td>
				<td class="fit">LDA $7A</td><td rowspan="2"><p>Test the talker active flag, TLKACT($7A)
to see if we are supposed to talk. If
flag is $00, branch to ATN110.</p>
</td></tr>
				<tr><td></td><td class="fit">E8EF</td>
				<td>F0 09</td>
				<td class="fit">BEQ $E8FA</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>BE AN ACTIVE TALKER.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8F1</td>
				<td>20 9C E9</td>
				<td class="fit">JSR $E99C</td><td rowspan="1"><p>JSR to DATHI ($E99C) to free data line.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8F4</td>
				<td>20 AE E9</td>
				<td class="fit">JSR $E9AE</td><td rowspan="1"><p>JSR to CLKLOW ($E9AE) to pull clock low.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E8F7</td>
				<td>20 09 E9</td>
				<td class="fit">JSR $E909</td><td rowspan="1"><p>JSR to TALK ($E909) to talk on the bus.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN110</td><td class="fit">E8FA</td>
				<td>4C 4E EA</td>
				<td class="fit">JMP $EA4E</td><td rowspan="1"><p>JMP to ILERR ($EA4E) to release all the
lines and shift to idle mode.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>FIX SO DEVICE NOT PRESENT IS REPORTED</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN120</td><td class="fit">E8FD</td>
				<td>A9 10</td>
				<td class="fit">LDA #$10</td><td rowspan="2"><p>Store $10 in PB ($1800) to kill all the
lines except ATN ACK (ATN ACKnowledge) .</p>
</td></tr>
				<tr><td></td><td class="fit">E8FF</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATN122</td><td class="fit">E902</td>
				<td>2C 00 18</td>
				<td class="fit">BIT $1800</td><td rowspan="3"><p>Test if ATN signal is still present (bit
7 of PB set). If gone, branch to ATSN20.
If still present, loop to ATN122.</p>
</td></tr>
				<tr><td></td><td class="fit">E905</td>
				<td>10 D0</td>
				<td class="fit">BPL $E8D7</td></tr>
				<tr><td></td><td class="fit">E907</td>
				<td>30 F9</td>
				<td class="fit">BMI $E902</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Serial bus talk routines</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TALK</td><td class="fit">E909</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set the interrupt flag (SEI) to prevent
any interrupts.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E90A</td>
				<td>20 EB D0</td>
				<td class="fit">JSR $D0EB</td><td rowspan="2"><p>JSR to FNDRCH ($D0EB) to find an unused
read channel. If no channel is available
branch to NOTLK to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">E90D</td>
				<td>B0 06</td>
				<td class="fit">BCS $E915</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TALK1</td><td class="fit">E90F</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E911</td>
				<td>B5 F2</td>
				<td class="fit">LDA $F2,X</td><td rowspan="2"><p>Load .A with the channel status from
CHNRDY,X ($F2,X). If bit 7 is set, the
status is OK so branch to TLK05.</p>
</td></tr>
				<tr><td></td><td class="fit">E913</td>
				<td>30 01</td>
				<td class="fit">BMI $E916</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NOTLK</td><td class="fit">E915</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Note: CODE ADDED TO FIX VERIFY ERROR</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TLK05</td><td class="fit">E916</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E919</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
clock signal is gone. NOTE: this must be
80 microseconds or more from JMP TALK1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E91C</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the data byte in .A with $01 and
save it on the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">E91E</td>
				<td>08</td>
				<td class="fit">PHP</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E91F</td>
				<td>20 B7 E9</td>
				<td class="fit">JSR $E9B7</td><td rowspan="1"><p>JSR to CLKHI ($E9B7) to set the clock
line high.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E922</td>
				<td>28</td>
				<td class="fit">PLP</td><td rowspan="2"><p>Pull the test byte off the stack. If it
is $00, this is a VERIFY ERROR so branch
to TLK02 to send an EOI .</p>
</td></tr>
				<tr><td></td><td class="fit">E923</td>
				<td>F0 12</td>
				<td class="fit">BEQ $E937</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TALK2</td><td class="fit">E925</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E928</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
data line has been set low.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E92B</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the test byte (in .A) with $01.
If the result is not $00, the line has
not been set hi (no response) so branch
back to TALK2 to wait for response.</p>
</td></tr>
				<tr><td></td><td class="fit">E92D</td>
				<td>D0 F6</td>
				<td class="fit">BNE $E925</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E92F</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E931</td>
				<td>B5 F2</td>
				<td class="fit">LDA $F2,X</td><td rowspan="3"><p>Load .A with the channel status from
CHNRDY,X ($F2,X), and AND it with $08 to
test if we have an EOI condition. If the
result is not $00, we do not have an
EOI so branch to NOEOI ($E94B) .</p>
</td></tr>
				<tr><td></td><td class="fit">E933</td>
				<td>29 08</td>
				<td class="fit">AND #$08</td></tr>
				<tr><td></td><td class="fit">E935</td>
				<td>D0 14</td>
				<td class="fit">BNE $E94B</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Send an EOI signal to the C-64 by:</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TLK02</td><td class="fit">E937</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E93A</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to&quot; DEBNC ($E9C0) to send an EOI and
test if the data line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E93D</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the test byte (in .A) with $01.
If the result is not $00, the line has
not been set hi (no response) so branch
back to TLK02 to wait for hi response.</p>
</td></tr>
				<tr><td></td><td class="fit">E93F</td>
				<td>D0 F6</td>
				<td class="fit">BNE $E937</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TLK03</td><td class="fit">E941</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E944</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
data line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E947</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the test byte (in .A) with $01.
If the result equals $00, the line has
not been set lo (no response) so branch
back to TLK02 to wait for lo response.</p>
</td></tr>
				<tr><td></td><td class="fit">E949</td>
				<td>F0 F6</td>
				<td class="fit">BEQ $E941</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NOEOI</td><td class="fit">E94B</td>
				<td>20 AE E9</td>
				<td class="fit">JSR $E9AE</td><td rowspan="1"><p>JSR to CLKLOW ($E9AE) to set the clock
line low.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E94E</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E951</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
data line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E954</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the test byte (in .A) with $01.
If the result is not $00, the line has
not been set hi (no response) so branch
back to NOEOI to wait for hi response.</p>
</td></tr>
				<tr><td></td><td class="fit">E956</td>
				<td>D0 F3</td>
				<td class="fit">BNE $E94B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E958</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td><td rowspan="2"><p>Store $08 in CONT ($98) to set up the
bit counter.</p>
</td></tr>
				<tr><td></td><td class="fit">E95A</td>
				<td>85 98</td>
				<td class="fit">STA $98</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ISR01</td><td class="fit">E95C</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to let the port
settle.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E95F</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the test byte (in .A) with $01 to
be sure the line is hi before we send.
If the result is not $00, the line has
not been set hi (no response) so branch
to FRMFRX($E999) to wait for hi response</p>
</td></tr>
				<tr><td></td><td class="fit">E961</td>
				<td>D0 36</td>
				<td class="fit">BNE $E999</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ISR02</td><td class="fit">E963</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the current channel number
from LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E965</td>
				<td>BD 3E 02</td>
				<td class="fit">LDA $023E,X</td><td rowspan="3"><p>Load .A with the channel data byte from
CHNDAT,X ($F2,X). Rotate the status byte
one bit right (ROR) and store the result
back into CHNDAT,X ($F2,X).</p>
</td></tr>
				<tr><td></td><td class="fit">E968</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">E969</td>
				<td>9D 3E 02</td>
				<td class="fit">STA $023E,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E96C</td>
				<td>B0 05</td>
				<td class="fit">BCS $E973</td><td rowspan="1"><p>If the carry bit is set, branch to ISRHI
to send a 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E96E</td>
				<td>20 A5 E9</td>
				<td class="fit">JSR $E9A5</td><td rowspan="1"><p>JSR to DATLOW ($E9A5) to send a 0.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E971</td>
				<td>D0 03</td>
				<td class="fit">BNE $E976</td><td rowspan="1"><p>Branch to ISRCLK to clock it.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ISRHI</td><td class="fit">E973</td>
				<td>20 9C E9</td>
				<td class="fit">JSR $E99C</td><td rowspan="1"><p>JSR to DATHI ($E99C) to send a 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ISRCLK</td><td class="fit">E976</td>
				<td>20 B7 E9</td>
				<td class="fit">JSR $E9B7</td><td rowspan="1"><p>JSR to CLKHI ($E9B7) to set the clock
line hi. (rising edge).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E979</td>
				<td>A5 23</td>
				<td class="fit">LDA $23</td><td rowspan="1"><p>Load .A with the speed flag from
DRVTRK+1 ($23). If the flag is not $00,
no slow down is required so branch to
ISR03.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E97B</td>
				<td>D0 03</td>
				<td class="fit">BNE $E980</td><td rowspan="2"><p>JSR to SLOWD ($FEF3) to slow down the
data transmission.</p>
</td></tr>
				<tr><td></td><td class="fit">E97D</td>
				<td>20 F3 FE</td>
				<td class="fit">JSR $FEF3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ISR03</td><td class="fit">E980</td>
				<td>20 FB FE</td>
				<td class="fit">JSR $FEFB</td><td rowspan="1"><p>JSR to CLKDAT ($FEFB) to pull the clock
low and release the data.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E983</td>
				<td>C6 98</td>
				<td class="fit">DEC $98</td><td rowspan="2"><p>Decrement the bit count in CONT ($98) .
If the count is not $00, there are more
bits to send from this byte so branch
back to ISR01.</p>
</td></tr>
				<tr><td></td><td class="fit">E985</td>
				<td>D0 D5</td>
				<td class="fit">BNE $E95C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ISR04</td><td class="fit">E987</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
data line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E98A</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="3"><p>AND the test byte (in .A) with $01.
If the result equals $00, the line has
not been set lo (no response) so branch
back to ISR0.4 to wait for lo response.</p>
</td></tr>
				<tr><td></td><td class="fit">E98D</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">E98F</td>
				<td>F0 F6</td>
				<td class="fit">BEQ $E987</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E991</td>
				<td>58</td>
				<td class="fit">CLI</td><td rowspan="1"><p>Clear the interrupt flag (CLI) to
allow interrupts in preparation for
sending the next byte.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E992</td>
				<td>20 AA D3</td>
				<td class="fit">JSR $D3AA</td><td rowspan="1"><p>JSR to GET ($D3AA) to get the next-
data byte to send.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E995</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set the interrupt flag (SEI) to prevent
any interrupts.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E996</td>
				<td>4C 0F E9</td>
				<td class="fit">JMP $E90F</td><td rowspan="1"><p>JMP to TALK1 to keep on talking.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Talk subroutines</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRMERX</td><td class="fit">E999</td>
				<td>4C 4E EA</td>
				<td class="fit">JMP $EA4E</td><td rowspan="1"><p>JMP to FRMERR ($EA4E) to release all
lines and go to idle mode.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DATHI</td><td class="fit">E99C</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>Set data out line high.
Load .A with the byte from port B, PB
($1800), AND it with $FD ( $FF-DATOUT) ,
and store the result back in PB ($1800) .</p>
</td></tr>
				<tr><td></td><td class="fit">E99F</td>
				<td>29 FD</td>
				<td class="fit">AND #$FD</td></tr>
				<tr><td></td><td class="fit">E9A1</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9A4</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set data out line lo</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DATLOW</td><td class="fit">E9A5</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>Load .A with the byte from port B, PB
($1800), OR it with $02 (DATOUT). and
store the result back in PB ($1800) .</p>
</td></tr>
				<tr><td></td><td class="fit">E9A8</td>
				<td>09 02</td>
				<td class="fit">ORA #$02</td></tr>
				<tr><td></td><td class="fit">E9AA</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9AD</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set clock line lo</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLKLOW</td><td class="fit">E9AE</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>Load .A with the byte from port B, PB
($1800), OR it with $08 (CLKOUT). and
store the result back in PB ($1800) .</p>
</td></tr>
				<tr><td></td><td class="fit">E9B1</td>
				<td>09 08</td>
				<td class="fit">ORA #$08</td></tr>
				<tr><td></td><td class="fit">E9B3</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9B6</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set clock line hi</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLKHI</td><td class="fit">E9B7</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>Load .A with the byte from port B, PB
($1800). AND it with $F7 ($FF-CLKOUT) ,
and store the result back in PB ($1800) .</p>
</td></tr>
				<tr><td></td><td class="fit">E9BA</td>
				<td>29 F7</td>
				<td class="fit">AND #$F7</td></tr>
				<tr><td></td><td class="fit">E9BC</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9BF</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Wait for response on bus</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DEBNC</td><td class="fit">E9C0</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>Load .A with the byte from port. B, PB
($1800). Compare the old port value (.A)
with the current value of PB ($1800). If
there is no change, branch to DEBNC.</p>
</td></tr>
				<tr><td></td><td class="fit">E9C3</td>
				<td>CD 00 18</td>
				<td class="fit">CMP $1800</td></tr>
				<tr><td></td><td class="fit">E9C6</td>
				<td>D0 F8</td>
				<td class="fit">BNE $E9C0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9C8</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Serial bus listen routines</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACPTR</td><td class="fit">E9C9</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td><td rowspan="2"><p>Store $08 in CONT ($98) to set up the
bit counter.</p>
</td></tr>
				<tr><td></td><td class="fit">E9CB</td>
				<td>85 98</td>
				<td class="fit">STA $98</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACP00A</td><td class="fit">E9CD</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9D0</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
clock line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9D3</td>
				<td>29 04</td>
				<td class="fit">AND #$04</td><td rowspan="2"><p>AND the test byte (in .A) with $04.
If the result is not $00, the line has
not been set hi (no response) so branch
back to ACP00A to wait for hi response.</p>
</td></tr>
				<tr><td></td><td class="fit">E9D5</td>
				<td>D0 F6</td>
				<td class="fit">BNE $E9CD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9D7</td>
				<td>20 9C E9</td>
				<td class="fit">JSR $E99C</td><td rowspan="1"><p>JSR to DATHI ($E99C) to make data line
high.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9DA</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Store $01 in T1HC1 ($1805) to set up
for a 255 microsecond delay,</p>
</td></tr>
				<tr><td></td><td class="fit">E9DC</td>
				<td>8D 05 18</td>
				<td class="fit">STA $1805</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACP00</td><td class="fit">E9DF</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9E2</td>
				<td>AD 0D 18</td>
				<td class="fit">LDA $180D</td><td rowspan="3"><p>Load .A with the interrupt flag register
from IFR1 ($180D) and AND the test byte
with $40. If the result is NOT $00, the
time has run out so it MUST be an EOI.
Since it is an EOI, branch to ACPOOB.</p>
</td></tr>
				<tr><td></td><td class="fit">E9E5</td>
				<td>29 40</td>
				<td class="fit">AND #$40</td></tr>
				<tr><td></td><td class="fit">E9E7</td>
				<td>D0 09</td>
				<td class="fit">BNE $E9F2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9E9</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
clock line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9EC</td>
				<td>29 04</td>
				<td class="fit">AND #$04</td><td rowspan="3"><p>AND the test byte (in .A) with $04.
If the result is $00, the clock line has
not been set lo (no response) so branch
back to ACP00 to wait for lo response,
If the result is not $00, the line has
been set lo so branch to ACP01 to go on.</p>
</td></tr>
				<tr><td></td><td class="fit">E9EE</td>
				<td>F0 EF</td>
				<td class="fit">BEQ $E9DF</td></tr>
				<tr><td></td><td class="fit">E9F0</td>
				<td>D0 19</td>
				<td class="fit">BNE $EA0B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACPOOB</td><td class="fit">E9F2</td>
				<td>20 A5 E9</td>
				<td class="fit">JSR $E9A5</td><td rowspan="1"><p>JSR to DATLOW ($E9A5) to set data line
low as a response.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9F5</td>
				<td>A2 0A</td>
				<td class="fit">LDX #$0A</td><td rowspan="3"><p>Load .X with $0A, and loop to count .X
down to $00 to delay for talker turn
around time.</p>
</td></tr>
				<tr><td></td><td class="fit">E9F7</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">E9F8</td>
				<td>D0 FD</td>
				<td class="fit">BNE $E9F7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">E9FA</td>
				<td>20 9C E9</td>
				<td class="fit">JSR $E99C</td><td rowspan="1"><p>JSR to DATHI ($E99C) to make data line
high.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACP02A</td><td class="fit">E9FD</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA00</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
clock line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA03</td>
				<td>29 04</td>
				<td class="fit">AND #$04</td><td rowspan="2"><p>AND the test byte (in .A) with $04.
If the result is $00, the clock line has
not been set lo (no response) so branch
back to ACP02A to wait for lo response.</p>
</td></tr>
				<tr><td></td><td class="fit">EA05</td>
				<td>F0 F6</td>
				<td class="fit">BEQ $E9FD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACP01</td><td class="fit">EA07</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in EOIFLG ($F8) to indicate
that an EOI has been received.</p>
</td></tr>
				<tr><td></td><td class="fit">EA09</td>
				<td>85 F8</td>
				<td class="fit">STA $F8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACP03</td><td class="fit">EA0B</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="4"><p>Load .A with the data byte from port B,
PB ($1800), EOR it with $01 to find the
complement of the data bit, shift the
data bit into the carry flag (LSR). AND
the result in .A with $02 to test if the
clock line has been set high to indicate
valid data. If the result is NOT $00,
the clock line has not been set hi yet
so branch back to ACP03 and try again.</p>
</td></tr>
				<tr><td></td><td class="fit">EA0E</td>
				<td>29 04</td>
				<td class="fit">AND #$04</td></tr>
				<tr><td></td><td class="fit">EA10</td>
				<td>D0 F9</td>
				<td class="fit">BNE $EA0B</td></tr>
				<tr><td></td><td class="fit">EA12</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA15</td>
				<td>49 01</td>
				<td class="fit">EOR #$01</td><td rowspan="2"><p>Three $EA (NOP) bytes to fill space
left by speed-up to fix VC20 901229-02
ROM ' s .</p>
</td></tr>
				<tr><td></td><td class="fit">EA17</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA18</td>
				<td>66 85</td>
				<td class="fit">ROR $85</td><td rowspan="1"><p>We have valid data bit in the carry so
do a rotate right (ROR) on DATA ($85) to
store the bit into the data byte.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ACP03A</td><td class="fit">EA1A</td>
				<td>20 59 EA</td>
				<td class="fit">JSR $EA59</td><td rowspan="1"><p>JSR to TSTATN ($EA59) to test for an
ATN signal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA1D</td>
				<td>20 C0 E9</td>
				<td class="fit">JSR $E9C0</td><td rowspan="1"><p>JSR to DEBNC ($E9C0) to test if the
clock line has been set.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA20</td>
				<td>29 04</td>
				<td class="fit">AND #$04</td><td rowspan="2"><p>AND the test byte (in .A) with $04.
If the result is $00, the clock line has
not been set lo (no response) so branch
back to ACP03A to wait for lo response.</p>
</td></tr>
				<tr><td></td><td class="fit">EA22</td>
				<td>F0 F6</td>
				<td class="fit">BEQ $EA1A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA24</td>
				<td>C6 98</td>
				<td class="fit">DEC $98</td><td rowspan="2"><p>Decrement the bit counter in CONT ($98) .
If the count is not $00, there are more
bits to get so branch back to ACP03.</p>
</td></tr>
				<tr><td></td><td class="fit">EA26</td>
				<td>D0 E3</td>
				<td class="fit">BNE $EA0B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA28</td>
				<td>20 A5 E9</td>
				<td class="fit">JSR $E9A5</td><td rowspan="1"><p>JSR to DATLOW ($E9A5) to set data line
low das a response.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA2B</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the data byte from DATA
($85).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA2D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Main listen routine</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LISTEN</td><td class="fit">EA2E</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set interrupt mask (SEI) to prevent any
interrupts .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA2F</td>
				<td>20 07 D1</td>
				<td class="fit">JSR $D107</td><td rowspan="2"><p>JSR to FNDWCH ($D107) to find an unused
write channel. If none available, branch
to LSN15.</p>
</td></tr>
				<tr><td></td><td class="fit">EA32</td>
				<td>B0 05</td>
				<td class="fit">BCS $EA39</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA34</td>
				<td>B5 F2</td>
				<td class="fit">LDA $F2,X</td><td rowspan="1"><p>Load .A with the write channel status
from CHNRDY,X ($F2,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA36</td>
				<td>6A</td>
				<td class="fit">ROR</td><td rowspan="2"><p>Rotate the status byte right (ROR). If
the carry bit is set, the write channel
is inactive so branch to LSN30.</p>
</td></tr>
				<tr><td></td><td class="fit">EA37</td>
				<td>B0 0B</td>
				<td class="fit">BCS $EA44</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LSN15</td><td class="fit">EA39</td>
				<td>A5 84</td>
				<td class="fit">LDA $84</td><td rowspan="4"><p>Test if this is an OPEN command by:
loading .A with the original secondary
address from ORGSA ($84)~ and AND'ing it
with $F0. If the result is $F0, it is
an OPEN command so branch to LSN30.</p>
</td></tr>
				<tr><td></td><td class="fit">EA3B</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">EA3D</td>
				<td>C9 F0</td>
				<td class="fit">CMP #$F0</td></tr>
				<tr><td></td><td class="fit">EA3F</td>
				<td>F0 03</td>
				<td class="fit">BEQ $EA44</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA41</td>
				<td>4C 4E EA</td>
				<td class="fit">JMP $EA4E</td><td rowspan="1"><p>Not an active channel so JMP to ILERR
($EA4E) to abort.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LSN30</td><td class="fit">EA44</td>
				<td>20 C9 E9</td>
				<td class="fit">JSR $E9C9</td><td rowspan="1"><p>JSR to ACPTR ($E9C9) to get a data byte.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA47</td>
				<td>58</td>
				<td class="fit">CLI</td><td rowspan="1"><p>Clear interrupt mask (CLI) to allow
interrupts.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA48</td>
				<td>20 B7 CF</td>
				<td class="fit">JSR $CFB7</td><td rowspan="1"><p>JSR to PUT ($CFB7) to put the data byte
into its proper place (DATA, EOI. SA) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA4B</td>
				<td>4C 2E EA</td>
				<td class="fit">JMP $EA2E</td><td rowspan="1"><p>JMP to LISTEN ($EA2E) to keep on
listening.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Release all bus lines and go idle</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRMERR</td><td class="fit">EA4E</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Store $00 into port B, PB ($1800) and
JMP to IDLE ($EBE7) .</p>
</td></tr>
				<tr><td></td><td class="fit">EA50</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
				<tr><td></td><td class="fit">EA53</td>
				<td>4C E7 EB</td>
				<td class="fit">JMP $EBE7</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Listen subroutines</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ATNLOW</td><td class="fit">EA56</td>
				<td>4C 5B E8</td>
				<td class="fit">JMP $E85B</td><td rowspan="1"><p>JMP to ATNSRV ($E85B) to service ATN
request.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test if in ATN mode</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTATN</td><td class="fit">EA59</td>
				<td>A5 7D</td>
				<td class="fit">LDA $7D</td><td rowspan="2"><p>Load .A with the attention mode flag
from ATNMOD ($7D). If $00, we are not
in attention mode so branch to TSTA50.</p>
</td></tr>
				<tr><td></td><td class="fit">EA5B</td>
				<td>F0 06</td>
				<td class="fit">BEQ $EA63</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA5D</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="2"><p>We are in attention mode. Load .A with
the byte from port B, PB ($1800). If
bit 7 of this byte is clear, the ATN
signal is gone so branch to TATN20 to
do what we were told.</p>
</td></tr>
				<tr><td></td><td class="fit">EA60</td>
				<td>10 09</td>
				<td class="fit">BPL $EA6B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTRTN</td><td class="fit">EA62</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>The ATN signal hasn't gone away yet so
exit with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTA50</td><td class="fit">EA63</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>We are not in attention mode now. Load
.A with the byte from port B, PB ($1800)</p>
<p>If bit 7 of this byte is clear, there is
no ATN signal present so branch to
TSTRTN to exit.</p>
<p>If bit 7 of this byte is set, there is
an ATN signal present so JMP to ATNSRV
($E85B) to service the ATN request.</p>
</td></tr>
				<tr><td></td><td class="fit">EA66</td>
				<td>10 FA</td>
				<td class="fit">BPL $EA62</td></tr>
				<tr><td></td><td class="fit">EA68</td>
				<td>4C 5B E8</td>
				<td class="fit">JMP $E85B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TATN20</td><td class="fit">EA6B</td>
				<td>4C D7 E8</td>
				<td class="fit">JMP $E8D7</td><td rowspan="1"><p>JMP to ATNS20 ($E8D7) to carry out the
attention command .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Flash led to signal error</h1>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h2>No-error status</h2>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PEZRO</td><td class="fit">EA6E</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="1"><p>Load .X with $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA70</td>
				<td>2C</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $2C skips next two bytes.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h2>Error status</h2>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PERR</td><td class="fit">EA71</td>
				<td>A6 6F</td>
				<td class="fit">LDX $6F</td><td rowspan="1"><p>Load .X with the error number from TEMP
($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA73</td>
				<td>9A</td>
				<td class="fit">TXS</td><td rowspan="1"><p>Transfer the error number from .X into
the stack pointer to use the stack as a
storage register.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PE20</td><td class="fit">EA74</td>
				<td>BA</td>
				<td class="fit">TSX</td><td rowspan="1"><p>Transfer the value of the stack pointer
(the error number) into .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PE30</td><td class="fit">EA75</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td><td rowspan="3"><p>Load .A with $08 (the LED mask). OR it
with the data port controlling the LED's
LEDPRT ($1C00). and JMP to PEA7A ($FEEA)
to turn on LED. NOTE: this is a patch to
be sure the data direction register for
the LED line is set to output.</p>
</td></tr>
				<tr><td></td><td class="fit">EA77</td>
				<td>0D 00 1C</td>
				<td class="fit">ORA $1C00</td></tr>
				<tr><td></td><td class="fit">EA7A</td>
				<td>4C EA FE</td>
				<td class="fit">JMP $FEEA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REA7D</td><td class="fit">EA7D</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer the byte in .Y to .A</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PD10</td><td class="fit">EA7E</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Clear the carry flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PD20</td><td class="fit">EA7F</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td><td rowspan="2"><p>Add $01 to the contents of .A. If the
result is not $00, branch to PD20.</p>
</td></tr>
				<tr><td></td><td class="fit">EA81</td>
				<td>D0 FC</td>
				<td class="fit">BNE $EA7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA83</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement .Y (the hi byte of the timer) .
If value of .Y is not $00, branch to
PD10.</p>
</td></tr>
				<tr><td></td><td class="fit">EA84</td>
				<td>D0 F8</td>
				<td class="fit">BNE $EA7E</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Turn off LED(s)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA86</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="3"><p>Load .A with the byte from the data port
controlling the LED, LEDPRT ($1C00). AND
the byte with $F7 ($FF - LED mask) and
store the result back into LEDPRT ($1C00)
to turn OFF the LED.</p>
</td></tr>
				<tr><td></td><td class="fit">EA89</td>
				<td>29 F7</td>
				<td class="fit">AND #$F7</td></tr>
				<tr><td></td><td class="fit">EA8B</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PE40</td><td class="fit">EA8E</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer the byte in .Y to .A</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PD11</td><td class="fit">EA8F</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Clear the carry flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PD21</td><td class="fit">EA90</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td><td rowspan="2"><p>Add $01 to the contents of .A. 'if the
result is not $00, branch to PD21.</p>
</td></tr>
				<tr><td></td><td class="fit">EA92</td>
				<td>D0 FC</td>
				<td class="fit">BNE $EA90</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA94</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement .Y (the hi byte of the timer) .
If value of .Y is not $00, branch to
PD11.</p>
</td></tr>
				<tr><td></td><td class="fit">EA95</td>
				<td>D0 F8</td>
				<td class="fit">BNE $EA8F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA97</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement the count in .X. If the result
is greater than or equal to $00, branch
to PE30 to flash again.</p>
</td></tr>
				<tr><td></td><td class="fit">EA98</td>
				<td>10 DB</td>
				<td class="fit">BPL $EA75</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EA9A</td>
				<td>E0 FC</td>
				<td class="fit">CPX #$FC</td><td rowspan="3"><p>Compare .X to $FC to see if we have
waited long enough between groups of
flashes. If .X &lt;&gt; $FC branch to PE40 to
wait some more. If .X = $FC, branch to
PE20 to repeat the sequence.</p>
</td></tr>
				<tr><td></td><td class="fit">EA9C</td>
				<td>D0 F0</td>
				<td class="fit">BNE $EA8E</td></tr>
				<tr><td></td><td class="fit">EA9E</td>
				<td>F0 D4</td>
				<td class="fit">BEQ $EA74</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Initialization of disk</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DSKINT</td><td class="fit">EAA0</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set the interrupt flag (SEI) to prevent
interrupts .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAA1</td>
				<td>D8</td>
				<td class="fit">CLD</td><td rowspan="1"><p>Clear the decimal mode flag (CLD) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAA2</td>
				<td>A2 FF</td>
				<td class="fit">LDX #$FF</td><td rowspan="2"><p>Store $FF into the data direction
register DDRA1 ($1803).</p>
</td></tr>
				<tr><td></td><td class="fit">EAA4</td>
				<td>8E 03 18</td>
				<td class="fit">STX $1803</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAA7</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Load .X and .Y with $00.</p>
</td></tr>
				<tr><td></td><td class="fit">EAA8</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">EAAA</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PV10</td><td class="fit">EAAC</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Fill zero page with ascend ing pattern
Transfer the byte from .X  into .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAAD</td>
				<td>95 00</td>
				<td class="fit">STA $00,X</td><td rowspan="1"><p>Store the byte from .A into $00, X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAAF</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment .X. If .X is not-$00, branch
back to PV10.
Check zero page bits.</p>
</td></tr>
				<tr><td></td><td class="fit">EAB0</td>
				<td>D0 FA</td>
				<td class="fit">BNE $EAAC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PV20</td><td class="fit">EAB2</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="1"><p>Transfer the byte from .X into .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAB3</td>
				<td>D5 00</td>
				<td class="fit">CMP $00,X</td><td rowspan="2"><p>Compare the byte in .A with $00, X.
If no match, branch to PEZRO ($EA6E) .</p>
</td></tr>
				<tr><td></td><td class="fit">EAB5</td>
				<td>D0 B7</td>
				<td class="fit">BNE $EA6E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PV30</td><td class="fit">EAB7</td>
				<td>F6 00</td>
				<td class="fit">INC $00,X</td><td rowspan="1"><p>Increment the contents of $00, X by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAB9</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="2"><p>Increment .Y. If .Y is not $00, branch
back to PV3 0.</p>
</td></tr>
				<tr><td></td><td class="fit">EABA</td>
				<td>D0 FB</td>
				<td class="fit">BNE $EAB7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EABC</td>
				<td>D5 00</td>
				<td class="fit">CMP $00,X</td><td rowspan="2"><p>Check if $00, X equals byte in .A. If no
match, something is wrong so branch to
PEZRO ($EA6E) .</p>
</td></tr>
				<tr><td></td><td class="fit">EABE</td>
				<td>D0 AE</td>
				<td class="fit">BNE $EA6E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAC0</td>
				<td>94 00</td>
				<td class="fit">STY $00,X</td><td rowspan="1"><p>Store the $00 byte from .Y into $00, X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAC2</td>
				<td>B5 00</td>
				<td class="fit">LDA $00,X</td><td rowspan="2"><p>Check if $00, X equals $00. If it does
not, something is wrong so branch to
PEZRO ($EA6E) .</p>
</td></tr>
				<tr><td></td><td class="fit">EAC4</td>
				<td>D0 A8</td>
				<td class="fit">BNE $EA6E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAC6</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment the counter in .X. If the
result is not $00, we have more of zero
page to check so branch back to PV20.</p>
</td></tr>
				<tr><td></td><td class="fit">EAC7</td>
				<td>D0 E9</td>
				<td class="fit">BNE $EAB2</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test the two 64K bit ROM's</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RM10</td><td class="fit">EAC9</td>
				<td>E6 6F</td>
				<td class="fit">INC $6F</td><td rowspan="1"><p>Increment TEMP ($6F) to set the next
error number ($01=$E/F; $02=$C/D ROM).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EACB</td>
				<td>86 76</td>
				<td class="fit">STX $76</td><td rowspan="2"><p>Store .X value (page number) into IP+1
($76) as the hi byte of the pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">EACD</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EACF</td>
				<td>85 75</td>
				<td class="fit">STA $75</td><td rowspan="1"><p>Set lo byte of pointer, IP ($75) to $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAD1</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="2"><p>Set .Y to $00 and .X to $20 (32 pages) .</p>
</td></tr>
				<tr><td></td><td class="fit">EAD2</td>
				<td>A2 20</td>
				<td class="fit">LDX #$20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAD4</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="1"><p>Clear the carry flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RT10</td><td class="fit">EAD5</td>
				<td>C6 76</td>
				<td class="fit">DEC $76</td><td rowspan="1"><p>Decrement the hi byte of the pointer in
IP+1 ($76) and we'll do it backwards.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RT20</td><td class="fit">EAD7</td>
				<td>71 75</td>
				<td class="fit">ADC ($75),Y</td><td rowspan="3"><p>Add the ROM value from (IP),Y to the
contents of .A, increment the Y pointer,
and if .Y is not $00, branch back to
RT20 to do another byte from this page.</p>
</td></tr>
				<tr><td></td><td class="fit">EAD9</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">EADA</td>
				<td>D0 FB</td>
				<td class="fit">BNE $EAD7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EADC</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement .X (page count). If the page
count is not zero, branch to RT10 to do
the next page of the ROM.</p>
</td></tr>
				<tr><td></td><td class="fit">EADD</td>
				<td>D0 F6</td>
				<td class="fit">BNE $EAD5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EADF</td>
				<td>69 00</td>
				<td class="fit">ADC #$00</td><td rowspan="1"><p>Add $00 to .A to add in the last carry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAE1</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the checksum from .A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAE2</td>
				<td>C5 76</td>
				<td class="fit">CMP $76</td><td rowspan="2"><p>Compare the checksum in .A with the
hi byte of the count in IP+1 ($76). If
the bytes do not match, branch to PERR2
($EB1F). $E/F ROM: checksum = $E0
$C/D ROM: checksum = $C0</p>
</td></tr>
				<tr><td></td><td class="fit">EAE4</td>
				<td>D0 39</td>
				<td class="fit">BNE $EB1F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAE6</td>
				<td>E0 C0</td>
				<td class="fit">CPX #$C0</td><td rowspan="2"><p>Compare checksum in .X with $C0 to check
if we are done. If not, branch to RM10.</p>
</td></tr>
				<tr><td></td><td class="fit">EAE8</td>
				<td>D0 DF</td>
				<td class="fit">BNE $EAC9</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Test the disk RAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CR20</td><td class="fit">EAEA</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="1"><p>Load .A with $01 (start of first block) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CR30</td><td class="fit">EAEC</td>
				<td>85 76</td>
				<td class="fit">STA $76</td><td rowspan="1"><p>Save contents of .A (page number) into
IP+1 ($76) as hi byte of pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAEE</td>
				<td>E6 6F</td>
				<td class="fit">INC $6F</td><td rowspan="1"><p>Increment TEMP ($6F) to bump the error
number ($03=RAM problem)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RAMTST</td><td class="fit">EAF0</td>
				<td>A2 07</td>
				<td class="fit">LDX #$07</td><td rowspan="1"><p>Load .X with $07 (number of RAM pages) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RA10</td><td class="fit">EAF2</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Transfer .Y value to .A and clear carry.</p>
</td></tr>
				<tr><td></td><td class="fit">EAF3</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAF4</td>
				<td>65 76</td>
				<td class="fit">ADC $76</td><td rowspan="2"><p>Add the hi byte of the pointer, IP+1
($76) to the accumulator and store the
result in (IP,Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">EAF6</td>
				<td>91 75</td>
				<td class="fit">STA ($75),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAF8</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="2"><p>Increment .Y and if .Y is not. $00,
branch to RA10 to fill RAM page.</p>
</td></tr>
				<tr><td></td><td class="fit">EAF9</td>
				<td>D0 F7</td>
				<td class="fit">BNE $EAF2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EAFB</td>
				<td>E6 76</td>
				<td class="fit">INC $76</td><td rowspan="3"><p>Increment the hi byte of the pointer in
IP+1 ($76) and decrement the page count-
in .X. If .X is not $00, we have more
pages to do so branch back to RA10.</p>
</td></tr>
				<tr><td></td><td class="fit">EAFD</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">EAFE</td>
				<td>D0 F2</td>
				<td class="fit">BNE $EAF2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB00</td>
				<td>A2 07</td>
				<td class="fit">LDX #$07</td><td rowspan="1"><p>Load .X with $07 (number of RAM pages) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RA30</td><td class="fit">EB02</td>
				<td>C6 76</td>
				<td class="fit">DEC $76</td><td rowspan="1"><p>Decrement the hi byte of the pointer in
IP+1 ($76). We'll check backwards.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RA40</td><td class="fit">EB04</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="3"><p>Decrement .Y, transfer the .Y value into
.A and clear the carry.</p>
</td></tr>
				<tr><td></td><td class="fit">EB05</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">EB06</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB07</td>
				<td>65 76</td>
				<td class="fit">ADC $76</td><td rowspan="3"><p>Add the hi byte of the pointer, IP+1
($76) to the accumulator and compare the
result with (IP,Y). If they don't match,
branch to PERR2 to report the error.</p>
</td></tr>
				<tr><td></td><td class="fit">EB09</td>
				<td>D1 75</td>
				<td class="fit">CMP ($75),Y</td></tr>
				<tr><td></td><td class="fit">EB0B</td>
				<td>D0 12</td>
				<td class="fit">BNE $EB1F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB0D</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td><td rowspan="2"><p>EOR the contents of .A with $FF to flip
the bits and store the result into the
RAM at (IP) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EB0F</td>
				<td>91 75</td>
				<td class="fit">STA ($75),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB11</td>
				<td>51 75</td>
				<td class="fit">EOR ($75),Y</td><td rowspan="3"><p>EOR the contents of .A with (IP),Y and
store the result (should be $00) back
into (IP),Y. If the result is not $00,
branch to PERR2 to report the error.</p>
</td></tr>
				<tr><td></td><td class="fit">EB13</td>
				<td>91 75</td>
				<td class="fit">STA ($75),Y</td></tr>
				<tr><td></td><td class="fit">EB15</td>
				<td>D0 08</td>
				<td class="fit">BNE $EB1F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB17</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Transfer the contents of .Y into .A. If
.Y is not $00, we have more to do on
this page so branch back to RA40.</p>
</td></tr>
				<tr><td></td><td class="fit">EB18</td>
				<td>D0 EA</td>
				<td class="fit">BNE $EB04</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB1A</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement the page count in .X. If there
are more pages to do, branch to RA30.</p>
</td></tr>
				<tr><td></td><td class="fit">EB1B</td>
				<td>D0 E5</td>
				<td class="fit">BNE $EB02</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB1D</td>
				<td>F0 03</td>
				<td class="fit">BEQ $EB22</td><td rowspan="1"><p>Branch to DIAGOK.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PERR2</td><td class="fit">EB1F</td>
				<td>4C 71 EA</td>
				<td class="fit">JMP $EA71</td><td rowspan="1"><p>JMP to PERR ($EA71) to report error.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIAGOK</td><td class="fit">EB22</td>
				<td>A2 45</td>
				<td class="fit">LDX #$45</td><td rowspan="2"><p>Load .X with $45 and transfer this value
to the stack pointer to reset the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EB24</td>
				<td>9A</td>
				<td class="fit">TXS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB25</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="3"><p>Load .A with the byte from the LED
control port, LEDPRT ($1C00), AND it
with $F7 ($FF-LED mask) and store the
result back in LEDPRT to turn off LED.</p>
</td></tr>
				<tr><td></td><td class="fit">EB28</td>
				<td>29 F7</td>
				<td class="fit">AND #$F7</td></tr>
				<tr><td></td><td class="fit">EB2A</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB2D</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Store $01 in PCR1 ($180C) to cause
interrupt on the negative edge of ATN.</p>
</td></tr>
				<tr><td></td><td class="fit">EB2F</td>
				<td>8D 0C 18</td>
				<td class="fit">STA $180C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB32</td>
				<td>A9 82</td>
				<td class="fit">LDA #$82</td><td rowspan="3"><p>Store $82 (10000010) in IFR1 ($180D)
and IER1 ($180E) .</p>
</td></tr>
				<tr><td></td><td class="fit">EB34</td>
				<td>8D 0D 18</td>
				<td class="fit">STA $180D</td></tr>
				<tr><td></td><td class="fit">EB37</td>
				<td>8D 0E 18</td>
				<td class="fit">STA $180E</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Compute device # from bits 5/6 of port B</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB3A</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="6"><p>Load .A with the data byte from Port B,
PB ($1800). AND the byte with $6
(%01100000). Do one ASL and three ROL ' s
to convert from bits 6/5 to bits 1/0.
NOTE: 0XX00000 becomes 000000XX</p>
</td></tr>
				<tr><td></td><td class="fit">EB3D</td>
				<td>29 60</td>
				<td class="fit">AND #$60</td></tr>
				<tr><td></td><td class="fit">EB3F</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">EB40</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">EB41</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">EB42</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB43</td>
				<td>09 48</td>
				<td class="fit">ORA #$48</td><td rowspan="4"><p>OR .A with $48 (the talk address) and
store the result in TLKADR ($78) .
EOR .A with $60 (the listen address) and
store the result in LSNADR ($77) .</p>
</td></tr>
				<tr><td></td><td class="fit">EB45</td>
				<td>85 78</td>
				<td class="fit">STA $78</td></tr>
				<tr><td></td><td class="fit">EB47</td>
				<td>49 60</td>
				<td class="fit">EOR #$60</td></tr>
				<tr><td></td><td class="fit">EB49</td>
				<td>85 77</td>
				<td class="fit">STA $77</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Initialize buffer pointer table</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INTTAB</td><td class="fit">EB4B</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="2"><p>Zero .X and .Y</p>
</td></tr>
				<tr><td></td><td class="fit">EB4D</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INTT1</td><td class="fit">EB4F</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and store the $00 byte in .A in
the buffer table at BUFTAB,X ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">EB51</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB53</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="3"><p>Increment .X and load .A with the hi
byte of the pointer to the buffer from
BUFIND,Y ($FEE0) and store it into the
buffer table at BUFTAB,X ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">EB54</td>
				<td>B9 E0 FE</td>
				<td class="fit">LDA $FEE0,Y</td></tr>
				<tr><td></td><td class="fit">EB57</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB59</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="4"><p>Increment .X and .Y and compare the new
value of .Y with $05 (the number of
buffers). If there are more buffers to
do, branch to INTT1.</p>
</td></tr>
				<tr><td></td><td class="fit">EB5A</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">EB5B</td>
				<td>C0 05</td>
				<td class="fit">CPY #$05</td></tr>
				<tr><td></td><td class="fit">EB5D</td>
				<td>D0 F0</td>
				<td class="fit">BNE $EB4F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB5F</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Store the lo byte of the pointer to the
command buffer ($00) into the buffer
table at BUFTAB,X ($99, X). Increment .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EB61</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
				<tr><td></td><td class="fit">EB63</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB64</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="3"><p>Store the hi byte of the pointer to the
command buffer ($02) into the buffer
table at BUFTAB,X ($99, X). Increment .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EB66</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
				<tr><td></td><td class="fit">EB68</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB69</td>
				<td>A9 D5</td>
				<td class="fit">LDA #$D5</td><td rowspan="3"><p>Store the lo byte of the pointer to the
error buffer ($D5) into the buffer table
table at BUFTAB,X ($99, X). Increment .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EB6B</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
				<tr><td></td><td class="fit">EB6D</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB6E</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="2"><p>Store the hi byte of the pointer to the
error buffer ($02) into the buffer table
table at BUFTAB,X ($99, X). Increment .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EB70</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB72</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Load .A with $FF (inactive SA) and .X
with $12 (the maximum secondary address)</p>
</td></tr>
				<tr><td></td><td class="fit">EB74</td>
				<td>A2 12</td>
				<td class="fit">LDX #$12</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DSKIN1</td><td class="fit">EB76</td>
				<td>9D 2B 02</td>
				<td class="fit">STA $022B,X</td><td rowspan="3"><p>Loop to set all LINTAB,X ($022B,X)
values to $FF to indicate inactive.</p>
</td></tr>
				<tr><td></td><td class="fit">EB79</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">EB7A</td>
				<td>10 FA</td>
				<td class="fit">BPL $EB76</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB7C</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td><td rowspan="1"><p>Load .X with $05 (the maximum number of
channels - 1) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DSKIN2</td><td class="fit">EB7E</td>
				<td>95 A7</td>
				<td class="fit">STA $A7,X</td><td rowspan="5"><p>Loop to set all BUF0,X ($A7,X), BUF1,X
($AE,X) and SS,X (CD,X) values to $FF to
indicate that these buffers are unused.</p>
</td></tr>
				<tr><td></td><td class="fit">EB80</td>
				<td>95 AE</td>
				<td class="fit">STA $AE,X</td></tr>
				<tr><td></td><td class="fit">EB82</td>
				<td>95 CD</td>
				<td class="fit">STA $CD,X</td></tr>
				<tr><td></td><td class="fit">EB84</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">EB85</td>
				<td>10 F7</td>
				<td class="fit">BPL $EB7E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB87</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td><td rowspan="2"><p>Store $05 (the buffer count) into
BUFO+CMDCHN ($AB)</p>
</td></tr>
				<tr><td></td><td class="fit">EB89</td>
				<td>85 AB</td>
				<td class="fit">STA $AB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB8B</td>
				<td>A9 06</td>
				<td class="fit">LDA #$06</td><td rowspan="2"><p>Store $05 (the buffer count + 1) into
BUF0+ERRCHN ($AC)</p>
</td></tr>
				<tr><td></td><td class="fit">EB8D</td>
				<td>85 AC</td>
				<td class="fit">STA $AC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB8F</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF into BUF0+BLINDX ($AD)</p>
</td></tr>
				<tr><td></td><td class="fit">EB91</td>
				<td>85 AD</td>
				<td class="fit">STA $AD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB93</td>
				<td>85 B4</td>
				<td class="fit">STA $B4</td><td rowspan="1"><p>Store $FF into BUF1+BLINDX ($B4)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB95</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td><td rowspan="2"><p>Store $05 (the error channel #) into
LINTAB+ERRSA ($023B) .</p>
</td></tr>
				<tr><td></td><td class="fit">EB97</td>
				<td>8D 3B 02</td>
				<td class="fit">STA $023B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB9A</td>
				<td>A9 84</td>
				<td class="fit">LDA #$84</td><td rowspan="2"><p>Store $84 ($80 + the command channel #)
into LINTAB+CMDSA ($023A) .</p>
</td></tr>
				<tr><td></td><td class="fit">EB9C</td>
				<td>8D 3A 02</td>
				<td class="fit">STA $023A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EB9F</td>
				<td>A9 0F</td>
				<td class="fit">LDA #$0F</td><td rowspan="2"><p>Store $0F (LINDX to 5 free) into
LINUSE ($0256) .</p>
</td></tr>
				<tr><td></td><td class="fit">EBA1</td>
				<td>8D 56 02</td>
				<td class="fit">STA $0256</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBA4</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Store $01 (ready to listen) into
CHNRDY+CMDCHN ($F6) .</p>
</td></tr>
				<tr><td></td><td class="fit">EBA6</td>
				<td>85 F6</td>
				<td class="fit">STA $F6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBA8</td>
				<td>A9 88</td>
				<td class="fit">LDA #$88</td><td rowspan="2"><p>Store $01 (ready to talk) into
CHNRDY+ERRCHN ($F7) .</p>
</td></tr>
				<tr><td></td><td class="fit">EBAA</td>
				<td>85 F7</td>
				<td class="fit">STA $F7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBAC</td>
				<td>A9 E0</td>
				<td class="fit">LDA #$E0</td><td rowspan="4"><p>Store $E0 into BUFUSE ($024F) and $FF
into BUFUSE+1 ($0250) .</p>
</td></tr>
				<tr><td></td><td class="fit">EBAE</td>
				<td>8D 4F 02</td>
				<td class="fit">STA $024F</td></tr>
				<tr><td></td><td class="fit">EBB1</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td></tr>
				<tr><td></td><td class="fit">EBB3</td>
				<td>8D 50 02</td>
				<td class="fit">STA $0250</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBB6</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Store $01 into WPSW ($1C) and WPSW+1
($1D) to set up the write protect status</p>
</td></tr>
				<tr><td></td><td class="fit">EBB8</td>
				<td>85 1C</td>
				<td class="fit">STA $1C</td></tr>
				<tr><td></td><td class="fit">EBBA</td>
				<td>85 1D</td>
				<td class="fit">STA $1D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBBC</td>
				<td>20 63 CB</td>
				<td class="fit">JSR $CB63</td><td rowspan="1"><p>JSR to USRINT ($CB63) to initialize the
user jump table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBBF</td>
				<td>20 FA CE</td>
				<td class="fit">JSR $CEFA</td><td rowspan="1"><p>JSR to LRUINT ($CEFA) to initialize the
least recently used table.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBC2</td>
				<td>20 59 F2</td>
				<td class="fit">JSR $F259</td><td rowspan="1"><p>JSR to CNTINT ($F259) to initialize the
disk controller.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBC5</td>
				<td>A9 22</td>
				<td class="fit">LDA #$22</td><td rowspan="4"><p>Set up the indirect NMI vector at VNMI
($65/6) to point to the diagnostic
routine, DIAGOK ($EB22).</p>
</td></tr>
				<tr><td></td><td class="fit">EBC7</td>
				<td>85 65</td>
				<td class="fit">STA $65</td></tr>
				<tr><td></td><td class="fit">EBC9</td>
				<td>A9 EB</td>
				<td class="fit">LDA #$EB</td></tr>
				<tr><td></td><td class="fit">EBCB</td>
				<td>85 66</td>
				<td class="fit">STA $66</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBCD</td>
				<td>A9 0A</td>
				<td class="fit">LDA #$0A</td><td rowspan="2"><p>Store $0A into SECINC ($69) as the
normal next sector increment.</p>
</td></tr>
				<tr><td></td><td class="fit">EBCF</td>
				<td>85 69</td>
				<td class="fit">STA $69</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBD1</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td><td rowspan="2"><p>Store $05 into REVCNT ($6A) as the
normal recovery counter.</p>
</td></tr>
				<tr><td></td><td class="fit">EBD3</td>
				<td>85 6A</td>
				<td class="fit">STA $6A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETERR</td><td class="fit">EBD5</td>
				<td>A9 73</td>
				<td class="fit">LDA #$73</td><td rowspan="2"><p>Load .A with $73 and JSR to ERRTSO
($E6C1) to set up power-on error message
73 CBM DOS V2.6 1541</p>
</td></tr>
				<tr><td></td><td class="fit">EBD7</td>
				<td>20 C1 E6</td>
				<td class="fit">JSR $E6C1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBDA</td>
				<td>A9 1A</td>
				<td class="fit">LDA #$1A</td><td rowspan="2"><p>Load .A with $1A (%00011010) and store
it in the data direction register DDRB1
($1802). ATNA,CLKOUT,DATOUT are outputs.</p>
</td></tr>
				<tr><td></td><td class="fit">EBDC</td>
				<td>8D 02 18</td>
				<td class="fit">STA $1802</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBDF</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in data port B, PB ($1800) to
set DATA, CLOCK, &amp; ATNA lines high.</p>
</td></tr>
				<tr><td></td><td class="fit">EBE1</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBE4</td>
				<td>20 80 E7</td>
				<td class="fit">JSR $E780</td><td rowspan="1"><p>JSR to BOOT ($E780) to see if we need
to boot a systems routine.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Idle loop. Wait for something to do.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDLE</td><td class="fit">EBE7</td>
				<td>58</td>
				<td class="fit">CLI</td><td rowspan="1"><p>Clear interrupt mask (CLI) to allow
interrupts.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Release all the bus lines</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBE8</td>
				<td>AD 00 18</td>
				<td class="fit">LDA $1800</td><td rowspan="3"><p>Load .A with the byte from port B, PB
($1800), AND it with $E5 to set CLOCK,
DATA, and ATNA lines high, and store the
result back in PB ($1800) .</p>
</td></tr>
				<tr><td></td><td class="fit">EBEB</td>
				<td>29 E5</td>
				<td class="fit">AND #$E5</td></tr>
				<tr><td></td><td class="fit">EBED</td>
				<td>8D 00 18</td>
				<td class="fit">STA $1800</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBF0</td>
				<td>AD 55 02</td>
				<td class="fit">LDA $0255</td><td rowspan="2"><p>Check the value of CMDWAT ($0255) to see
if there is a command waiting. If it is
$00, there is none waiting so branch to
IDL1.</p>
</td></tr>
				<tr><td></td><td class="fit">EBF3</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $EBFF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBF5</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in CMDWAT ($0255) to clear the
command waiting flag.</p>
</td></tr>
				<tr><td></td><td class="fit">EBF7</td>
				<td>8D 55 02</td>
				<td class="fit">STA $0255</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBFA</td>
				<td>85 67</td>
				<td class="fit">STA $67</td><td rowspan="1"><p>Store $00 in NMIFLG ($67) to clear the
debounce.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EBFC</td>
				<td>20 46 C1</td>
				<td class="fit">JSR $C146</td><td rowspan="1"><p>JSR to PARSXQ ($C146) to parse and then
execute the command.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL1</td><td class="fit">EBFF</td>
				<td>58</td>
				<td class="fit">CLI</td><td rowspan="1"><p>Clear interrupt mask (CLI) to allow
interrupts.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC00</td>
				<td>A5 7C</td>
				<td class="fit">LDA $7C</td><td rowspan="2"><p>Check the value of ATNPND ($0255) to see
if there is an attention pending. If it-
is $00, there is nothing pending (such
as the drive running or an open file)
so branch to IDL01.</p>
</td></tr>
				<tr><td></td><td class="fit">EC02</td>
				<td>F0 03</td>
				<td class="fit">BEQ $EC07</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC04</td>
				<td>4C 5B E8</td>
				<td class="fit">JMP $E85B</td><td rowspan="1"><p>JMP to ATNSRV ($E85B) to service the
attention request.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL01</td><td class="fit">EC07</td>
				<td>58</td>
				<td class="fit">CLI</td><td rowspan="1"><p>Clear interrupt mask (CLI) to allow
interrupts .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC08</td>
				<td>A9 0E</td>
				<td class="fit">LDA #$0E</td><td rowspan="2"><p>Store $0E (#14). the maximum secondary
address for files in TEMP+3 ($72) .</p>
</td></tr>
				<tr><td></td><td class="fit">EC0A</td>
				<td>85 72</td>
				<td class="fit">STA $72</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC0C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Zero TEMP ($6F) and TEMP+1 ($70).</p>
</td></tr>
				<tr><td></td><td class="fit">EC0E</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">EC10</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL02</td><td class="fit">EC12</td>
				<td>A6 72</td>
				<td class="fit">LDX $72</td><td rowspan="1"><p>Load .X with the secondary address
counter from TEMP+3 ($72) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC14</td>
				<td>BD 2B 02</td>
				<td class="fit">LDA $022B,X</td><td rowspan="3"><p>Load .A with the channel number for this
secondary address from LINTAB,X ($022B,X)
If it is $FF, there is no active file
for this SA so branch to IDL3.</p>
</td></tr>
				<tr><td></td><td class="fit">EC17</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">EC19</td>
				<td>F0 10</td>
				<td class="fit">BEQ $EC2B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC1B</td>
				<td>29 3F</td>
				<td class="fit">AND #$3F</td><td rowspan="2"><p>We've found an active file so AND the
channel number with $3F and store the
result as the current channel number in
LINDX ($82) .</p>
</td></tr>
				<tr><td></td><td class="fit">EC1D</td>
				<td>85 82</td>
				<td class="fit">STA $82</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC1F</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC22</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the buffer number from .A to .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC23</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td><td rowspan="3"><p>Determine which drive is to be used by
loading the old job number from LSTJOB,X
($025B,X), AND'ing it with $01, and
transferring the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EC26</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">EC28</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC29</td>
				<td>F6 6F</td>
				<td class="fit">INC $6F,X</td><td rowspan="1"><p>Increment the count of the number of
active files on drive X in TEMP,X ($6F,X)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL3</td><td class="fit">EC2B</td>
				<td>C6 72</td>
				<td class="fit">DEC $72</td><td rowspan="2"><p>Decrement the SA count in TEMP + 3 ($72) .
If there are more secondary addresses
left to check, branch back to IDL2.</p>
</td></tr>
				<tr><td></td><td class="fit">EC2D</td>
				<td>10 E3</td>
				<td class="fit">BPL $EC12</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC2F</td>
				<td>A0 04</td>
				<td class="fit">LDY #$04</td><td rowspan="1"><p>Load .Y with $04 (the number of buffers
less 1) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL4</td><td class="fit">EC31</td>
				<td>B9 00 00</td>
				<td class="fit">LDA $0000,Y</td><td rowspan="2"><p>Load .A with the current job code for
this buffer from the job queue, JOBS,Y
($00, Y). If bit 7 is not set, no job is
in progress so branch to IDL5.</p>
</td></tr>
				<tr><td></td><td class="fit">EC34</td>
				<td>10 05</td>
				<td class="fit">BPL $EC3B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC36</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>There is a job in progress so AND the
job code in .A with $01 to mask off the
non-drive bits and transfer the result-
to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EC38</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC39</td>
				<td>F6 6F</td>
				<td class="fit">INC $6F,X</td><td rowspan="1"><p>Increment the count of the number of
active files on drive X in TEMP,X ($6F ,X)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL5</td><td class="fit">EC3B</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement the buffer counter in .Y. If
there are more buffers to check, branch
to IDL4.</p>
</td></tr>
				<tr><td></td><td class="fit">EC3C</td>
				<td>10 F3</td>
				<td class="fit">BPL $EC31</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC3E</td>
				<td>78</td>
				<td class="fit">SEI</td><td rowspan="1"><p>Set the interrupt mask (SEI) to prevent
interrupts while reading LEDPRT ($1C00) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC3F</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="3"><p>Load .A with the data byte from the
port controlling the LED, AND the byte
with $F7 ($FF - LED mask). and save the
result onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EC42</td>
				<td>29 F7</td>
				<td class="fit">AND #$F7</td></tr>
				<tr><td></td><td class="fit">EC44</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC45</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Load .A with the current drive number
from DRVNUM ($7F) and save it in R0($86)</p>
</td></tr>
				<tr><td></td><td class="fit">EC47</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC49</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">EC4B</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC4D</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="2"><p>Test the active file count for drive
in TEMP ($6F). If $00, branch to IDL7.</p>
</td></tr>
				<tr><td></td><td class="fit">EC4F</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $EC5C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC51</td>
				<td>A5 1C</td>
				<td class="fit">LDA $1C</td><td rowspan="2"><p>Load the write protect switch byte from
WPSW ($1C). If it is $00 branch to IDL6.</p>
</td></tr>
				<tr><td></td><td class="fit">EC53</td>
				<td>F0 03</td>
				<td class="fit">BEQ $EC58</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC55</td>
				<td>20 13 D3</td>
				<td class="fit">JSR $D313</td><td rowspan="1"><p>JSR to CLDCHN ($D313) to close all files</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL6</td><td class="fit">EC58</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the LED data byte off the stack,
OR it with $08 (LED mask) to turn on the
LED since drive is active, and save
the byte back onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EC59</td>
				<td>09 08</td>
				<td class="fit">ORA #$08</td></tr>
				<tr><td></td><td class="fit">EC5B</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL7</td><td class="fit">EC5C</td>
				<td>E6 7F</td>
				<td class="fit">INC $7F</td><td rowspan="1"><p>Increment the DRVNUM ($7F). (to $01)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC5E</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td><td rowspan="2"><p>Test the active file count for drive 1
in TEMP+1 ($70). If $00, branch to IDL9.</p>
</td></tr>
				<tr><td></td><td class="fit">EC60</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $EC6D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC62</td>
				<td>A5 1D</td>
				<td class="fit">LDA $1D</td><td rowspan="2"><p>Load the write protect switch byte from
WPSW ($1C). If it is $00 branch to IDL8.</p>
</td></tr>
				<tr><td></td><td class="fit">EC64</td>
				<td>F0 03</td>
				<td class="fit">BEQ $EC69</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC66</td>
				<td>20 13 D3</td>
				<td class="fit">JSR $D313</td><td rowspan="1"><p>JSR to CLDCHN ($D313) to close all files</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL8</td><td class="fit">EC69</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>Pull the LED data byte off the stack,
OR it. with $00 (LED mask) to turn on the
LED since drive 1 is active. and save
the byte back onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EC6A</td>
				<td>09 00</td>
				<td class="fit">ORA #$00</td></tr>
				<tr><td></td><td class="fit">EC6C</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL9</td><td class="fit">EC6D</td>
				<td>A5 86</td>
				<td class="fit">LDA $86</td><td rowspan="2"><p>Copy the original drive number from
R0 ($86) back into DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">EC6F</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC71</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the LED data byte off the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC72</td>
				<td>AE 6C 02</td>
				<td class="fit">LDX $026C</td><td rowspan="2"><p>Load .X with the error status from
ERWORD ($026C). If it is $00, the LED
is not flashing so branch to IDL12.</p>
</td></tr>
				<tr><td></td><td class="fit">EC75</td>
				<td>F0 21</td>
				<td class="fit">BEQ $EC98</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Error light is flashing</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC77</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="1"><p>Load .A with the LED data byte from
LEDPRT ($1C00)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC7A</td>
				<td>E0 80</td>
				<td class="fit">CPX #$80</td><td rowspan="2"><p>Compare the error status in .X with $80.
If it is not $80, this is not the first
time we have seen this error so branch
to IDL 10.</p>
</td></tr>
				<tr><td></td><td class="fit">EC7C</td>
				<td>D0 03</td>
				<td class="fit">BNE $EC81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC7E</td>
				<td>4C 8B EC</td>
				<td class="fit">JMP $EC8B</td><td rowspan="1"><p>We have just encountered a new error
status so JMP to IDL11.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL10</td><td class="fit">EC81</td>
				<td>AE 05 18</td>
				<td class="fit">LDX $1805</td><td rowspan="2"><p>Load .X with the value of TIMER1 ($1805)
If bit 7 is set, we are still timing so
branch to IDL12.</p>
</td></tr>
				<tr><td></td><td class="fit">EC84</td>
				<td>30 12</td>
				<td class="fit">BMI $EC98</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC86</td>
				<td>A2 A0</td>
				<td class="fit">LDX #$A0</td><td rowspan="2"><p>Store $A0 into TIMER1 ($1805) to set the
timer to a new 8 millisecond cycle.</p>
</td></tr>
				<tr><td></td><td class="fit">EC88</td>
				<td>8E 05 18</td>
				<td class="fit">STX $1805</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL11</td><td class="fit">EC8B</td>
				<td>CE 6C 02</td>
				<td class="fit">DEC $026C</td><td rowspan="2"><p>Decrement the count of 8 millisecond
cycles in ERWORD ($026C). If the count
is not $00 yet, branch to IDL12</p>
</td></tr>
				<tr><td></td><td class="fit">EC8E</td>
				<td>D0 08</td>
				<td class="fit">BNE $EC98</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC90</td>
				<td>4D 6D 02</td>
				<td class="fit">EOR $026D</td><td rowspan="1"><p>Time is up. EOR the LED status in .A
with the LED mask in ERLED ($026D) to
toggle the LED.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC93</td>
				<td>A2 10</td>
				<td class="fit">LDX #$10</td><td rowspan="2"><p>Store $10 in ERWORD ($026C) to start a
new timing cycle.</p>
</td></tr>
				<tr><td></td><td class="fit">EC95</td>
				<td>8E 6C 02</td>
				<td class="fit">STX $026C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IDL12</td><td class="fit">EC98</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td><td rowspan="1"><p>Store the current LED status (in .A)
into the LED port, LEDPRT ($1C00).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EC9B</td>
				<td>4C FF EB</td>
				<td class="fit">JMP $EBFF</td><td rowspan="1"><p>JMP to IDL1 ($EBFF) the top of the loop.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Start loading the directory</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STDIR</td><td class="fit">EC9E</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set current secondary address, SA ($83)
to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">ECA0</td>
				<td>85 83</td>
				<td class="fit">STA $83</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECA2</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Load .A with $01 and JSR to GETRCH
($D1E2) to allocate a channel and one
buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">ECA4</td>
				<td>20 E2 D1</td>
				<td class="fit">JSR $D1E2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECA7</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and JSR to SETPNT ($D4C8) to
set the buffer pointer to the start of
the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">ECA9</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECAC</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .X with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECAE</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 as the last character for this
channel in LSTCHR,X ($0244).</p>
</td></tr>
				<tr><td></td><td class="fit">ECB0</td>
				<td>9D 44 02</td>
				<td class="fit">STA $0244,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECB3</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECB6</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the buffer number into .X</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECB7</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Load .A with the current drive number
from DRVNUM ($7F) and store this number
as the last job number for this buffer
in LSTJOB,X ($025B) .</p>
</td></tr>
				<tr><td></td><td class="fit">ECB9</td>
				<td>9D 5B 02</td>
				<td class="fit">STA $025B,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECBC</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Load .A with $01 and JSR to PUTBYT
($CFF1) to put the lo byte of the load
address ($0401) into the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">ECBE</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECC1</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>Load .A with $04 and JSR to PUTBYT
($CFF1) to put the hi byte of the load
address ($0401) into the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">ECC3</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECC6</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Load .A with $01 and JSR to PUTBYT
($CFF1) twice to put a phony program
line link ($0101) into the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">ECC8</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
				<tr><td></td><td class="fit">ECCB</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECCE</td>
				<td>AD 72 02</td>
				<td class="fit">LDA $0272</td><td rowspan="2"><p>Load .A with the drive number for the
directory from NBTEMP ($0272) and JSR to
PUTBYT ($CFF1) to put this to the buffer
as the lo byte of the first line number.</p>
</td></tr>
				<tr><td></td><td class="fit">ECD1</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECD4</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to PUTBYT
($CFF1) to store this as the hi byte of
the line number.</p>
</td></tr>
				<tr><td></td><td class="fit">ECD6</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECD9</td>
				<td>20 59 ED</td>
				<td class="fit">JSR $ED59</td><td rowspan="1"><p>JSR to MOVBUF ($ED59) to move the disk
name into the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECDC</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECDF</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by 2 (ASL)
and transfer it. into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">ECE0</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECE1</td>
				<td>D6 99</td>
				<td class="fit">DEC $99,X</td><td rowspan="2"><p>Decrement the lo byte of the pointer in
BUFTAB,X ($$99, X) twice.</p>
</td></tr>
				<tr><td></td><td class="fit">ECE3</td>
				<td>D6 99</td>
				<td class="fit">DEC $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECE5</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to PUTBYT
($CFF1) to store this as the end of
program line null byte.</p>
</td></tr>
				<tr><td></td><td class="fit">ECE7</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIR1</td><td class="fit">ECEA</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Load .A with $01 and JSR to PUTBYT
($CFF1) twice to put a phony program
line link ($0101) into the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">ECEC</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
				<tr><td></td><td class="fit">ECEF</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECF2</td>
				<td>20 CE C6</td>
				<td class="fit">JSR $C6CE</td><td rowspan="2"><p>JSR to GETNAM ($C6CE) to get the buffer
number and file name. If the carry flag
is clear on return, this is the last-
entry so branch to DIR3.</p>
</td></tr>
				<tr><td></td><td class="fit">ECF5</td>
				<td>90 2C</td>
				<td class="fit">BCC $ED23</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECF7</td>
				<td>AD 72 02</td>
				<td class="fit">LDA $0272</td><td rowspan="2"><p>Load .A with the lo byte of the block
count from NBTEMP ($0272) and JSR to
PUTBYT ($CFF1) to put this to the buffer
as the lo byte of the line number.</p>
</td></tr>
				<tr><td></td><td class="fit">ECFA</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ECFD</td>
				<td>AD 73 02</td>
				<td class="fit">LDA $0273</td><td rowspan="2"><p>Load .A with the hi byte of the block
count from NBTEMP+1 ($0273) and JSR to
PUTBYT ($CFF1) to put this to the buffer
as the hi byte of the line number.</p>
</td></tr>
				<tr><td></td><td class="fit">ED00</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED03</td>
				<td>20 59 ED</td>
				<td class="fit">JSR $ED59</td><td rowspan="1"><p>JSR to MOVBUF ($ED59) to move the file
name and file type into the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED06</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to PUTBYT
($CFF1) to store this as the end of
program line null byte.</p>
</td></tr>
				<tr><td></td><td class="fit">ED08</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED0B</td>
				<td>D0 DD</td>
				<td class="fit">BNE $ECEA</td><td rowspan="1"><p>If the Z flag is not set on return, the
buffer is not full so branch to DIR1 to
do the next file entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIR10</td><td class="fit">ED0D</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED10</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by 2 (ASL)
and transfer it into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">ED11</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED12</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 as the lo byte of the pointer
in BUFTAB,X ($$99, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">ED14</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED16</td>
				<td>A9 88</td>
				<td class="fit">LDA #$88</td><td rowspan="1"><p>Load .A with $88 (ready-to-talk) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED18</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED1A</td>
				<td>8D 54 02</td>
				<td class="fit">STA $0254</td><td rowspan="1"><p>Store $88 (in .A) into the directory
list flag DIRLST ($0254) to indicate
that the directory list is full.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED1D</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td><td rowspan="1"><p>Store $88 (in .A) as the channel status
in CHNRDY,Y ($00F2,Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED20</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the byte from DATA ($85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED22</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>End directory loading</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DIR3</td><td class="fit">ED23</td>
				<td>AD 72 02</td>
				<td class="fit">LDA $0272</td><td rowspan="2"><p>Load .A with the lo byte of the block
count from NBTEMP ($0272) and JSR to
PUTBYT ($CFF1) to put this to the buffer
as the lo byte of the line number.</p>
</td></tr>
				<tr><td></td><td class="fit">ED26</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED29</td>
				<td>AD 73 02</td>
				<td class="fit">LDA $0273</td><td rowspan="2"><p>Load .A with the hi byte of the block
count from NBTEMP+1 ($0273) and JSR to
PUTBYT ($CFF1) to put this to the buffer
as the hi byte of the line number.</p>
</td></tr>
				<tr><td></td><td class="fit">ED2C</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED2F</td>
				<td>20 59 ED</td>
				<td class="fit">JSR $ED59</td><td rowspan="1"><p>JSR to MOVBUF ($ED59) to move the file
name and file type into the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED32</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED35</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by 2 (ASL)
and transfer it into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">ED36</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED37</td>
				<td>D6 99</td>
				<td class="fit">DEC $99,X</td><td rowspan="2"><p>Decrement the lo byte of the pointer in
BUFTAB,X ($$99, X) twice.</p>
</td></tr>
				<tr><td></td><td class="fit">ED39</td>
				<td>D6 99</td>
				<td class="fit">DEC $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED3B</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Load .A with $00 and JSR to PUTBYT
($CFF1) three times to store the three
null bytes at the end of a program.</p>
</td></tr>
				<tr><td></td><td class="fit">ED3D</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
				<tr><td></td><td class="fit">ED40</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
				<tr><td></td><td class="fit">ED43</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED46</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to get the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED49</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number by 2 (ASL)
and transfer it into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">ED4A</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED4B</td>
				<td>B9 99 00</td>
				<td class="fit">LDA $0099,Y</td><td rowspan="1"><p>Load .A with the lo byte of the pointer
into the buffer from BUFTAB,Y ($0099, Y).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED4E</td>
				<td>A6 82</td>
				<td class="fit">LDX $82</td><td rowspan="1"><p>Load .Y with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED50</td>
				<td>9D 44 02</td>
				<td class="fit">STA $0244,X</td><td rowspan="1"><p>Store the lo byte of the pointer (in .A)
into the lo byte of the pointer to the
last non-zero character in the buffer
LSTCHR,X ($0244, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED53</td>
				<td>DE 44 02</td>
				<td class="fit">DEC $0244,X</td><td rowspan="1"><p>Decrement the pointer in LSTCHR,X
($0244, X) by 1 so it does actually point
to the last character in the buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED56</td>
				<td>4C 0D ED</td>
				<td class="fit">JMP $ED0D</td><td rowspan="1"><p>JMP to DIR10 ($ED0D) to set the channel
status and flags and exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MOVBUF</td><td class="fit">ED59</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Transfer file name to listing buffer
Zero .Y</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MOVB1</td><td class="fit">ED5B</td>
				<td>B9 B1 02</td>
				<td class="fit">LDA $02B1,Y</td><td rowspan="2"><p>Load .A with the character from NAMBUF,Y
($02B1,Y) and JSR to PUTBYT ($CFF1) to
store it in the listing buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">ED5E</td>
				<td>20 F1 CF</td>
				<td class="fit">JSR $CFF1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED61</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y. If .Y is not $1B (#27)
yet, branch to MOVB1.</p>
</td></tr>
				<tr><td></td><td class="fit">ED62</td>
				<td>C0 1B</td>
				<td class="fit">CPY #$1B</td></tr>
				<tr><td></td><td class="fit">ED64</td>
				<td>D0 F5</td>
				<td class="fit">BNE $ED5B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED66</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get character for directory load</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETDIR</td><td class="fit">ED67</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="1"><p>JSR to GETBYT ($D137) to get a byte from
the data buffer (loads next block if
necessary) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED6A</td>
				<td>F0 01</td>
				<td class="fit">BEQ $ED6D</td><td rowspan="1"><p>On return, if the Z flag is set, we are
at the end-of-file so branch to GETD3.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED6C</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETD3</td><td class="fit">ED6D</td>
				<td>85 85</td>
				<td class="fit">STA $85</td><td rowspan="1"><p>Store the byte (in .A) into DATA ($85).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED6F</td>
				<td>A4 82</td>
				<td class="fit">LDY $82</td><td rowspan="1"><p>Load .Y with the channel number from
LINDX ($82) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED71</td>
				<td>B9 44 02</td>
				<td class="fit">LDA $0244,Y</td><td rowspan="1"><p>Load .A with the lo byte of the pointer
into the directory buffer from LSTCHR,Y
($0244, Y)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED74</td>
				<td>F0 08</td>
				<td class="fit">BEQ $ED7E</td><td rowspan="1"><p>If the lo byte of the pointer is $00, we
have exhasted the current buffer so
branch to GD1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED76</td>
				<td>A9 80</td>
				<td class="fit">LDA #$80</td><td rowspan="2"><p>We must be at the end-of-file so load
.A with $8 (EOI) and st ore it as the
channel status in CHNRDY,Y ($00F2,Y).</p>
</td></tr>
				<tr><td></td><td class="fit">ED78</td>
				<td>99 F2 00</td>
				<td class="fit">STA $00F2,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED7B</td>
				<td>A5 85</td>
				<td class="fit">LDA $85</td><td rowspan="1"><p>Load .A with the byte from DATA ($85).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED7D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GD1</td><td class="fit">ED7E</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save the null byte in .A onto the stack,</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED7F</td>
				<td>20 EA EC</td>
				<td class="fit">JSR $ECEA</td><td rowspan="1"><p>JSR to DIR1 ($ECEA) to create pseudo
program listing in the listing buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED82</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="1"><p>Pull the null data byte off the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED83</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Validate (collect) disk command</h1>
<p>Create a new BAM to match the sectors
used by the current directory entries.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VERDIR</td><td class="fit">ED84</td>
				<td>20 D1 C1</td>
				<td class="fit">JSR $C1D1</td><td rowspan="1"><p>JSR to SIMPRS ($C1D1) to parse the
command string and extract the drive #.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED87</td>
				<td>20 42 D0</td>
				<td class="fit">JSR $D042</td><td rowspan="1"><p>JSR to INITDR ($D042) to initialize the
drive specified.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED8A</td>
				<td>A9 40</td>
				<td class="fit">LDA #$40</td><td rowspan="2"><p>Store $40 in WBAM ($02F9) to mark BAM
as dirty (needs to be written out) .</p>
</td></tr>
				<tr><td></td><td class="fit">ED8C</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED8F</td>
				<td>20 B7 EE</td>
				<td class="fit">JSR $EEB7</td><td rowspan="1"><p>JSR to NEWMAP ($EEB7) to build a new
blank BAM in RAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED92</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Store $00 in DELIND ($0292) to force
a search for a valid directory entry
and JSR to SRCHST ($C5AC) to search the
directory for the first valid entry.</p>
</td></tr>
				<tr><td></td><td class="fit">ED94</td>
				<td>8D 92 02</td>
				<td class="fit">STA $0292</td></tr>
				<tr><td></td><td class="fit">ED97</td>
				<td>20 AC C5</td>
				<td class="fit">JSR $C5AC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">ED9A</td>
				<td>D0 3D</td>
				<td class="fit">BNE $EDD9</td><td rowspan="1"><p>If an entry is found (Z flag not set) ,
branch to VD25 to process it.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>No more entries so finish up.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VD10</td><td class="fit">ED9C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set SECTOR ($81) to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">ED9E</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDA0</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="2"><p>Set TRACK ($80) with the value $12 (#18)
from DIRTRK ($FE85) .</p>
</td></tr>
				<tr><td></td><td class="fit">EDA3</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDA5</td>
				<td>20 E5 ED</td>
				<td class="fit">JSR $EDE5</td><td rowspan="1"><p>JSR to VMKBAM ($EDE5) to trace through
the directory sectors and mark those in
use in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDA8</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in WBAM ($02F9) to mark BAM as
clean (BAM in RAM matches BAM on disk) .</p>
</td></tr>
				<tr><td></td><td class="fit">EDAA</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDAD</td>
				<td>20 FF EE</td>
				<td class="fit">JSR $EEFF</td><td rowspan="1"><p>JSR to SCRBAM ($EEFF) to write BAM out
to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDB0</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate command with a JMP to ENDCMD
(SC194) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Process directory entry for BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VD15</td><td class="fit">EDB3</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y (points to entry in buffer)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDB4</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load the track link for the entry from
(DIRBUF) ,Y; ($94), Y and save it onto
the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EDB6</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDB7</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y (points to entry in buffer)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDB8</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load the sector link for the entry from
(DIRBUF) ,Y; ($94) ,Y and save it onto
the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EDBA</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDBB</td>
				<td>A0 13</td>
				<td class="fit">LDY #$13</td><td rowspan="1"><p>Load .Y with $13 so it points to the
side sector track link of the entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDBD</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load the SS track link for the entry
from (DIRBUF) ,Y; ($94) ,Y. If the SS
track link is $00, this isn't a relative
file so branch to VD17.</p>
</td></tr>
				<tr><td></td><td class="fit">EDBF</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $EDCB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDC1</td>
				<td>85 80</td>
				<td class="fit">STA $80</td><td rowspan="1"><p>Store the SS track link in TRACK ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDC3</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y (points to entry in buffer)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDC4</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load the SS sector link for the entry
from (DIRBUF) ,Y; ($94) ,Y. Store the SS
sector link in SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">EDC6</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDC8</td>
				<td>20 E5 ED</td>
				<td class="fit">JSR $EDE5</td><td rowspan="1"><p>JSR to VMKBAM ($EDE5) to trace through
the SS file and mark the sectors used
in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VD17</td><td class="fit">EDCB</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the main file's sector link off the
stack and store it in SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">EDCC</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDCE</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the main file's track link off the
stack and store it in TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">EDCF</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDD1</td>
				<td>20 E5 ED</td>
				<td class="fit">JSR $EDE5</td><td rowspan="1"><p>JSR to VMKBAM ($EDE5) to trace through
the main file and mark the sectors used
in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VD20</td><td class="fit">EDD4</td>
				<td>20 04 C6</td>
				<td class="fit">JSR $C604</td><td rowspan="1"><p>JSR to SRRE ($C604) to search for the
next valid directory entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDD7</td>
				<td>F0 C3</td>
				<td class="fit">BEQ $ED9C</td><td rowspan="1"><p>If another entry is not found (Z flag
is set) branch to VD10 to finish up.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Check if entry found is properly closed</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VD25</td><td class="fit">EDD9</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Zero .Y so it points to the first
character in the entry, the file type.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDDB</td>
				<td>B1 94</td>
				<td class="fit">LDA ($94),Y</td><td rowspan="2"><p>Load .A with the file type byte from
(DIRBUF) ,Y; ($99) ,Y. If bit 7 is set,
the file has been properly closed so
branch to VD15 to process it.</p>
</td></tr>
				<tr><td></td><td class="fit">EDDD</td>
				<td>30 D4</td>
				<td class="fit">BMI $EDB3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDDF</td>
				<td>20 B6 C8</td>
				<td class="fit">JSR $C8B6</td><td rowspan="1"><p>File was not properly closed so JSR to
DELDIR ($C8B6) to delete it from the
directory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDE2</td>
				<td>4C D4 ED</td>
				<td class="fit">JMP $EDD4</td><td rowspan="1"><p>JMP to VD20 ($EDD4) to find next entry.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Trace file by links and mark BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VMKBAM</td><td class="fit">EDE5</td>
				<td>20 5F D5</td>
				<td class="fit">JSR $D55F</td><td rowspan="1"><p>JSR to TSCHK ($D55F) to check that the
TRACK and SECTOR values are legal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDE8</td>
				<td>20 90 EF</td>
				<td class="fit">JSR $EF90</td><td rowspan="1"><p>JSR to WUSED ($EF90) to mark the sector
pointed to by TRACK and SECTOR as IN USE
in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDEB</td>
				<td>20 75 D4</td>
				<td class="fit">JSR $D475</td><td rowspan="1"><p>JSR to OPNIRD ($D475) to open the
internal read channel and read in the
first one or two file blocks.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MRK2</td><td class="fit">EDEE</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Load .A with $00 and JSR to SETPNT
($D4C8) to set the pointers to the first
byte in the buffer (the track link) .</p>
</td></tr>
				<tr><td></td><td class="fit">EDF0</td>
				<td>20 C8 D4</td>
				<td class="fit">JSR $D4C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDF3</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="2"><p>JSR to GETBYT ($D137) to read the track
link (in .A). Store it into TRACK ($80).</p>
</td></tr>
				<tr><td></td><td class="fit">EDF6</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDF8</td>
				<td>20 37 D1</td>
				<td class="fit">JSR $D137</td><td rowspan="2"><p>JSR to GETBYT ($D137) to read the sector
link (in .A). Store it into SECTOR ($81)</p>
</td></tr>
				<tr><td></td><td class="fit">EDFB</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EDFD</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A with the track link from TRACK
($80). If it is not $00, branch to MRK1.</p>
</td></tr>
				<tr><td></td><td class="fit">EDFF</td>
				<td>D0 03</td>
				<td class="fit">BNE $EE04</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE01</td>
				<td>4C 27 D2</td>
				<td class="fit">JMP $D227</td><td rowspan="1"><p>Track link is $00. This must be the last
block in the file so JMP to FRECHN
($D227) to free the channel and return.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MRK1</td><td class="fit">EE04</td>
				<td>20 90 EF</td>
				<td class="fit">JSR $EF90</td><td rowspan="1"><p>JSR to WUSED ($EF90) to mark the sector
pointed to by TRACK and SECTOR as IN USE
in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE07</td>
				<td>20 4D D4</td>
				<td class="fit">JSR $D44D</td><td rowspan="1"><p>JSR to NXTBUF ($D44D) to read in the
next block of the file.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE0A</td>
				<td>4C EE ED</td>
				<td class="fit">JMP $EDEE</td><td rowspan="1"><p>JMP to MRK2 ($EDEE) to do next block.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>New (format) disk command</h1>
<p>A full, or long NEW marks off the tracks
and sectors on a diskette, writes null
data blocks in all sectors, and creates
a new BAM and directory on track 18.</p>
<p>A short NEW merely creates a new BAM and
directory on track 18.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NEW</td><td class="fit">EE0D</td>
				<td>20 12 C3</td>
				<td class="fit">JSR $C312</td><td rowspan="1"><p>JSR to ONEDRV ($C312) to set up drive
and table pointers.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE10</td>
				<td>A5 E2</td>
				<td class="fit">LDA $E2</td><td rowspan="2"><p>Load the number of the drive that was
set up from FILDRV ($E2). If bit 7 is
not set, a legal drive number was
specified so branch to N101 to continue.</p>
</td></tr>
				<tr><td></td><td class="fit">EE12</td>
				<td>10 05</td>
				<td class="fit">BPL $EE19</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE14</td>
				<td>A9 33</td>
				<td class="fit">LDA #$33</td><td rowspan="2"><p>Load .A with $33 to indicate a BAD DRIVE
NUMBER and JMP to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">EE16</td>
				<td>4C C8 C1</td>
				<td class="fit">JMP $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">N101</td><td class="fit">EE19</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND the drive number (in .A) with $01 to
mask off the non drive bits and store
the result as the current drive in
DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">EE1B</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE1D</td>
				<td>20 00 C1</td>
				<td class="fit">JSR $C100</td><td rowspan="1"><p>JSR to SETLDS ($C100) to turn on the
drive active LED.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE20</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>Load .A with the drive number from
DRVNUM ($7F). multiply it by 2 (ASL) ,
and transfer it into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EE22</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">EE23</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE24</td>
				<td>AC 7B 02</td>
				<td class="fit">LDY $027B</td><td rowspan="1"><p>Load .Y with the pointer to the start
of the new disk ID in the command buffer
from FILTBL+1 ($027B) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE27</td>
				<td>CC 74 02</td>
				<td class="fit">CPY $0274</td><td rowspan="2"><p>Compare the ID pointer in .Y with the
length of the command string in CMDSIZ
($0274). If these values are equal,
there is no new disk ID. Therefore this
must be a short new so branch to N108.</p>
</td></tr>
				<tr><td></td><td class="fit">EE2A</td>
				<td>F0 1A</td>
				<td class="fit">BEQ $EE46</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE2C</td>
				<td>B9 00 02</td>
				<td class="fit">LDA $0200,Y</td><td rowspan="4"><p>Transfer new disk ID from the command
buffer CMDBUF,Y ($0200, Y) and CMDBUF+1,Y
($0201, Y) to the master disk ID area
DSKID,X ($12, X) and DSKID+1,X ($13, X).</p>
</td></tr>
				<tr><td></td><td class="fit">EE2F</td>
				<td>95 12</td>
				<td class="fit">STA $12,X</td></tr>
				<tr><td></td><td class="fit">EE31</td>
				<td>B9 01 02</td>
				<td class="fit">LDA $0201,Y</td></tr>
				<tr><td></td><td class="fit">EE34</td>
				<td>95 13</td>
				<td class="fit">STA $13,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE36</td>
				<td>20 07 D3</td>
				<td class="fit">JSR $D307</td><td rowspan="1"><p>JSR to CLRCHN ($D307) to clear all
channels while formatting.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE39</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Store $01 into TRACK ($80) as first
track to do.</p>
</td></tr>
				<tr><td></td><td class="fit">EE3B</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE3D</td>
				<td>20 C6 C8</td>
				<td class="fit">JSR $C8C6</td><td rowspan="1"><p>JSR to FORMAT ($C8C6) to set up JMP
command in buffer that points to the
formatting routine to be used by the
disk controller.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE40</td>
				<td>20 05 F0</td>
				<td class="fit">JSR $F005</td><td rowspan="1"><p>JSR to CLRBAM ($F005) to clear the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE43</td>
				<td>4C 56 EE</td>
				<td class="fit">JMP $EE56</td><td rowspan="1"><p>JMP to N110 ($EE56) to continue.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Clear directory only</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">N108</td><td class="fit">EE46</td>
				<td>20 42 D0</td>
				<td class="fit">JSR $D042</td><td rowspan="1"><p>JSR to INITDR ($D042) to init. the drive</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE49</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="1"><p>Load .X with the drive number from
DRVNUM ($7F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE4B</td>
				<td>BD 01 01</td>
				<td class="fit">LDA $0101,X</td><td rowspan="3"><p>Load .A with the DOS version number
as given in the BAM, DSKVER,X ($0101, X)
and compare it with the 1541 DOS version
number ($41) from VERNUM ($FED5). If the
version numbers match, branch to N110.</p>
</td></tr>
				<tr><td></td><td class="fit">EE4E</td>
				<td>CD D5 FE</td>
				<td class="fit">CMP $FED5</td></tr>
				<tr><td></td><td class="fit">EE51</td>
				<td>F0 03</td>
				<td class="fit">BEQ $EE56</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE53</td>
				<td>4C 72 D5</td>
				<td class="fit">JMP $D572</td><td rowspan="1"><p>DOS versions do not match so JMP to
VNERR ($D572) to abort.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">N110</td><td class="fit">EE56</td>
				<td>20 B7 EE</td>
				<td class="fit">JSR $EEB7</td><td rowspan="1"><p>JSR to NEWMAP ($EEB7) to create a new
BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE59</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="2"><p>Load .A with the current job code from
JOBNUM ($F9) and transfer it to .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EE5B</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE5C</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the job code in .A by 2 (ASL)
and transfer the result to .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EE5D</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE5E</td>
				<td>AD 88 FE</td>
				<td class="fit">LDA $FE88</td><td rowspan="2"><p>Load .A with $90, the offset of the disk
name in the BAM from DSKNAM ($FE88) and
store this pointer in BUFTAB,X ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">EE61</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE63</td>
				<td>AE 7A 02</td>
				<td class="fit">LDX $027A</td><td rowspan="3"><p>Load .X with the buffer number from
FILTBL ($027A). load .Y with $27 (the
name length) and JSR to TRNAME ($C66E)
to transfer the new disk name from the
command buffer into the BAM area.</p>
</td></tr>
				<tr><td></td><td class="fit">EE66</td>
				<td>A9 1B</td>
				<td class="fit">LDA #$1B</td></tr>
				<tr><td></td><td class="fit">EE68</td>
				<td>20 6E C6</td>
				<td class="fit">JSR $C66E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE6B</td>
				<td>A0 12</td>
				<td class="fit">LDY #$12</td><td rowspan="1"><p>Load .Y with $12 (position of disk ID) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE6D</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="3"><p>Load .X with the drive number from
DRVNUM ($7F) and copy the DOS version
number ($41) from VERNUM ($FED5) into
DSKVER,X ($0101, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">EE6F</td>
				<td>AD D5 FE</td>
				<td class="fit">LDA $FED5</td></tr>
				<tr><td></td><td class="fit">EE72</td>
				<td>9D 01 01</td>
				<td class="fit">STA $0101,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE75</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the drive number from .X to .A,
multiply it by 2 (ASL). and transfer the
result back into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EE76</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">EE77</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE78</td>
				<td>B5 12</td>
				<td class="fit">LDA $12,X</td><td rowspan="3"><p>Transfer the first disk ID character
from DSKID,X ($12, X) into (DIRBUF) ,Y
($94) ,Y. Increment .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EE7A</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">EE7C</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE7D</td>
				<td>B5 13</td>
				<td class="fit">LDA $13,X</td><td rowspan="4"><p>Transfer the second disk ID character
from DSKID+1,X ($13, X) into (DIRBUF) ,Y
($94) ,Y. Increment .Y twice.</p>
</td></tr>
				<tr><td></td><td class="fit">EE7F</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
				<tr><td></td><td class="fit">EE81</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">EE82</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE83</td>
				<td>A9 32</td>
				<td class="fit">LDA #$32</td><td rowspan="2"><p>Store the directory DOS version ($32;
ASCII 2) into (DIRBUF) ,Y; ($94), Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EE85</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE87</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="1"><p>Increment .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE88</td>
				<td>AD D5 FE</td>
				<td class="fit">LDA $FED5</td><td rowspan="2"><p>Transfer the format type ($41; ASCII A)
from VERNUM ($FED5) into (DIRBUF) ,Y
($94) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EE8B</td>
				<td>91 94</td>
				<td class="fit">STA ($94),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE8D</td>
				<td>A0 02</td>
				<td class="fit">LDY #$02</td><td rowspan="2"><p>Load .Y with $02 so it points to the
third byte in the BAM and store the
format type ($41; in .A) into the BAM
at (BMPNT) ,Y; ($6D),Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EE8F</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE91</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="2"><p>Transfer the directory track number, $12
from DIRTRK ($FE85) into TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">EE94</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE96</td>
				<td>20 93 EF</td>
				<td class="fit">JSR $EF93</td><td rowspan="1"><p>JSR to USEDTS ($EF93) to mark track 18
sector as used in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE99</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Set SECTOR ($81) to $01.</p>
</td></tr>
				<tr><td></td><td class="fit">EE9B</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EE9D</td>
				<td>20 93 EF</td>
				<td class="fit">JSR $EF93</td><td rowspan="1"><p>JSR to USEDTS ($EF93) to mark track 18
sector 1 as used in the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEA0</td>
				<td>20 FF EE</td>
				<td class="fit">JSR $EEFF</td><td rowspan="1"><p>JSR to SCRBAM ($EEFF) to write out the
new BAM to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEA3</td>
				<td>20 05 F0</td>
				<td class="fit">JSR $F005</td><td rowspan="1"><p>JSR to CLRBAM ($F005) to set all of BAM
area to $00.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEA6</td>
				<td>A0 01</td>
				<td class="fit">LDY #$01</td><td rowspan="3"><p>Load .Y with $01 and store $FF as the
first directory block's sector link in
(BMPNT) ,Y; ($6D) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EEA8</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td></tr>
				<tr><td></td><td class="fit">EEAA</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEAC</td>
				<td>20 64 D4</td>
				<td class="fit">JSR $D464</td><td rowspan="1"><p>JSR to DRTWRT ($D464) to write out the
new directory block to disk.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEAF</td>
				<td>C6 81</td>
				<td class="fit">DEC $81</td><td rowspan="2"><p>Decrement the sector number (from $01 to
$00) in SECTOR ($81) and JSR to DRTRD
($D460) to read the BAM back into RAM.</p>
</td></tr>
				<tr><td></td><td class="fit">EEB1</td>
				<td>20 60 D4</td>
				<td class="fit">JSR $D460</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEB4</td>
				<td>4C 94 C1</td>
				<td class="fit">JMP $C194</td><td rowspan="1"><p>Terminate command with a JMP to ENDCMD
($C194) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Create a new BAM map</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NEWMAP</td><td class="fit">EEB7</td>
				<td>20 D1 F0</td>
				<td class="fit">JSR $F0D1</td><td rowspan="1"><p>JSR to CLNBAM ($F0D1) to set entire BAM
area to $00's.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEBA</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="6"><p>Using .Y as a pointer, store $12 (#18)
and $01 as the track and sector link in
(BMPNT) ,Y; ($6D) ,Y; as the first two
bytes of the new BAM.</p>
</td></tr>
				<tr><td></td><td class="fit">EEBC</td>
				<td>A9 12</td>
				<td class="fit">LDA #$12</td></tr>
				<tr><td></td><td class="fit">EEBE</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
				<tr><td></td><td class="fit">EEC0</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">EEC1</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">EEC2</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEC4</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y until it is $04.</p>
</td></tr>
				<tr><td></td><td class="fit">EEC5</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">EEC6</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NM10</td><td class="fit">EEC7</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Zero the area to be used to manipulate
the BAM map bits, TO ($6F). Tl ($70),
and T2 ($71) .</p>
</td></tr>
				<tr><td></td><td class="fit">EEC9</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
				<tr><td></td><td class="fit">EECB</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">EECD</td>
				<td>85 71</td>
				<td class="fit">STA $71</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EECF</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="3"><p>Transfer the byte from .Y into .A and
divide it by 4 (2 * LSR) to find the
track number.</p>
</td></tr>
				<tr><td></td><td class="fit">EED0</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">EED1</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EED2</td>
				<td>20 4B F2</td>
				<td class="fit">JSR $F24B</td><td rowspan="2"><p>JSR to MAXSEC ($F24B) to calculate the
maximum sector number for this track
and store this value as the number of
sectors free on this track in (BMPNT) ,Y
($6D) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EED5</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EED7</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="2"><p>Increment .Y. Transfer the maximum
sector number from .A into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EED8</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NM20</td><td class="fit">EED9</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="4"><p>Set the carry flag (this 1 bit will
indicate that this sector is free) and
rotate this bit from the carry into
the bit map area (TO/1/2) using ROL TO,
ROL Tl, and ROL T2.</p>
<pre><code>       T2 ($71)  Tl ($70)  TO ($6F)  C
before 00000000  11111111  11111111  1
after  00000001&lt;-11111111&lt;-11111111&lt;-0</code></pre>
</td></tr>
				<tr><td></td><td class="fit">EEDA</td>
				<td>26 6F</td>
				<td class="fit">ROL $6F</td></tr>
				<tr><td></td><td class="fit">EEDC</td>
				<td>26 70</td>
				<td class="fit">ROL $70</td></tr>
				<tr><td></td><td class="fit">EEDE</td>
				<td>26 71</td>
				<td class="fit">ROL $71</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEE0</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement the sector count in .X. If the
resulting .X value is not $00, there are
more to do so branch back to NM20.</p>
</td></tr>
				<tr><td></td><td class="fit">EEE1</td>
				<td>D0 F6</td>
				<td class="fit">BNE $EED9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NM30</td><td class="fit">EEE3</td>
				<td>B5 6F</td>
				<td class="fit">LDA $6F,X</td><td rowspan="6"><p>Transfer the bit map for this track from
T0,X ($6F,X) to the &quot;BAM area (BMPNT) ,Y;
($6D,Y). Increment .Y and .X. If the
new .X value is not $03, we have more
to transfer so branch back to NM30.</p>
</td></tr>
				<tr><td></td><td class="fit">EEE5</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
				<tr><td></td><td class="fit">EEE7</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">EEE8</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">EEE9</td>
				<td>E0 03</td>
				<td class="fit">CPX #$03</td></tr>
				<tr><td></td><td class="fit">EEEB</td>
				<td>90 F6</td>
				<td class="fit">BCC $EEE3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEED</td>
				<td>C0 90</td>
				<td class="fit">CPY #$90</td><td rowspan="2"><p>Compare the .Y value to $90. If it is
less than $90, we have more tracks to
do so branch back to NM10.</p>
</td></tr>
				<tr><td></td><td class="fit">EEEF</td>
				<td>90 D6</td>
				<td class="fit">BCC $EEC7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEF1</td>
				<td>4C 75 D0</td>
				<td class="fit">JMP $D075</td><td rowspan="1"><p>JMP to NFCALC ($D075) to calculate the
number of blocks free.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write out BAM to the drive specified in LSTJOB</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MAPOUT</td><td class="fit">EEF4</td>
				<td>20 93 DF</td>
				<td class="fit">JSR $DF93</td><td rowspan="1"><p>JSR to GETACT ($DF93) to find the active
buffer number (returned in .A) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEF7</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the buffer number to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EEF8</td>
				<td>BD 5B 02</td>
				<td class="fit">LDA $025B,X</td><td rowspan="3"><p>Load .A with the job code for the last-
job from LSTJOB, X ($025B,X). AND it with
$01 to mask off the non-drive bits, and
store the result in DRVNUM ($7F) .</p>
</td></tr>
				<tr><td></td><td class="fit">EEFB</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">EEFD</td>
				<td>85 7F</td>
				<td class="fit">STA $7F</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write out BAM to the drive specified in DRVNUM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SCRBAM</td><td class="fit">EEFF</td>
				<td>A4 7F</td>
				<td class="fit">LDY $7F</td><td rowspan="1"><p>Load .Y with the drive number from
DRVNUM ($7F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF01</td>
				<td>B9 51 02</td>
				<td class="fit">LDA $0251,Y</td><td rowspan="2"><p>Load .A with the BAM-dirty flag from
MDIRTY,Y ($0251, Y). If the flag is not
$00, the BAM is dirty (the copy in RAM
does NOT match the copy on disk) so
branch to SB10 to write it out to disk.</p>
</td></tr>
				<tr><td></td><td class="fit">EF04</td>
				<td>D0 01</td>
				<td class="fit">BNE $EF07</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF06</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>BAM is clean so there is no reason to
write it out. Terminate routine with
an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SB10</td><td class="fit">EF07</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero the BAM-dirty flag in MDIRTY,Y
($0251, Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF09</td>
				<td>99 51 02</td>
				<td class="fit">STA $0251,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF0C</td>
				<td>20 3A EF</td>
				<td class="fit">JSR $EF3A</td><td rowspan="1"><p>JSR to SETBPT ($EF3A) to set up the
pointer to the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF0F</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>Load .A with the drive number from
DRVNUM ($7F). multiply it by 2 (ASL) ,
and save the result onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EF11</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">EF12</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF13</td>
				<td>20 A5 F0</td>
				<td class="fit">JSR $F0A5</td><td rowspan="1"><p>JSR to PUTBAM ($F0A5) to put the memory
images to the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF16</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the (drive number x 2) off the
stack, clear the carry flag, add $01,
and JSR to PUTBAM ($F0A5) to put the
memory images to the BAM.</p>
</td></tr>
				<tr><td></td><td class="fit">EF17</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">EF18</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
				<tr><td></td><td class="fit">EF1A</td>
				<td>20 A5 F0</td>
				<td class="fit">JSR $F0A5</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Verify that the block count for the track matches the bit map for the track.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF1D</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A from TRACK ($80) and push the
track number onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">EF1F</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF20</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Load .A with $01 and store it in TRACK.</p>
</td></tr>
				<tr><td></td><td class="fit">EF22</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SB20</td><td class="fit">EF24</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="3"><p>Multiply the track number in .A by 4
(2 x ASL) and store the result as the
lo byte of the buffer pointer in BMPNT
($6D) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF25</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">EF26</td>
				<td>85 6D</td>
				<td class="fit">STA $6D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF28</td>
				<td>20 20 F2</td>
				<td class="fit">JSR $F220</td><td rowspan="1"><p>JSR to AVCK ($F220) to check that the
blocks free for the track agrees with
the bit map.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF2B</td>
				<td>E6 80</td>
				<td class="fit">INC $80</td><td rowspan="4"><p>Increment the track count in TRACK ($80)
If the new count is less than the
the maximum track number (#36). branch
back to SB20 to check the next track.</p>
</td></tr>
				<tr><td></td><td class="fit">EF2D</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">EF2F</td>
				<td>CD D7 FE</td>
				<td class="fit">CMP $FED7</td></tr>
				<tr><td></td><td class="fit">EF32</td>
				<td>90 F0</td>
				<td class="fit">BCC $EF24</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF34</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original track number off the
stack and restore it into TRACK ($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF35</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF37</td>
				<td>4C 8A D5</td>
				<td class="fit">JMP $D58A</td><td rowspan="1"><p>JMP to DOWRIT ($D58A) to write out the
BAM to disk.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Read in the BAM, if not already in RAM, and set the pointers to the BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETBPT</td><td class="fit">EF3A</td>
				<td>20 0F F1</td>
				<td class="fit">JSR $F10F</td><td rowspan="2"><p>JSR to BAM2A ($F10F) to get the BAM
channel number in .A (drO = 6). Transfer
the channel number into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EF3D</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF3E</td>
				<td>20 DF F0</td>
				<td class="fit">JSR $F0DF</td><td rowspan="1"><p>JSR to REDBAM ($F0DF) to read in the BAM
if not already in memory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF41</td>
				<td>A6 F9</td>
				<td class="fit">LDX $F9</td><td rowspan="1"><p>Load .X with the buffer number used for
the read from JOBNUM ($F9).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF43</td>
				<td>BD E0 FE</td>
				<td class="fit">LDA $FEE0,X</td><td rowspan="2"><p>Set the hi byte of the pointer to the
BAM in BMPNT+1 ($6E) using the hi byte
pointer value for the buffer from
BUFIND,X ($FEE0,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF46</td>
				<td>85 6E</td>
				<td class="fit">STA $6E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF48</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set the lo byte of the pointer to the
BAM in BMPNT ($6D) to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">EF4A</td>
				<td>85 6D</td>
				<td class="fit">STA $6D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF4C</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Get the number of blocks free on the drive specified in DRVNUM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NUMFRE</td><td class="fit">EF4D</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="1"><p>Load .X with the drive number from
DRVNUM ($7F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF4F</td>
				<td>BD FA 02</td>
				<td class="fit">LDA $02FA,X</td><td rowspan="2"><p>Transfer the lo byte of the number of
blocks free from ND3L,X ($02FA,X) into
NBTEMP ($0272) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF52</td>
				<td>8D 72 02</td>
				<td class="fit">STA $0272</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF55</td>
				<td>BD FC 02</td>
				<td class="fit">LDA $02FC,X</td><td rowspan="2"><p>Transfer the hi byte of the number of
blocks free from NDBH,X ($02FC,X) into
NBTEMP+1 ($0273) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF58</td>
				<td>8D 73 02</td>
				<td class="fit">STA $0273</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF5B</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Free the block specified in TRACK and SECTOR as free in the BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WFREE</td><td class="fit">EF5C</td>
				<td>20 F1 EF</td>
				<td class="fit">JSR $EFF1</td><td rowspan="1"><p>JSR to FIXBAM ($EFF1) to write out the
BAM the value in WBAM indicates that it
is needed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRETS</td><td class="fit">EF5F</td>
				<td>20 CF EF</td>
				<td class="fit">JSR $EFCF</td><td rowspan="1"><p>JSR to FREUSE ($EFCF) to calculate the
index to the BAM entry that contains
the desired TRACK and SECTOR. On return
.Y points to the entry and .X points to
the bit within the entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRETS2</td><td class="fit">EF62</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="1"><p>Set the carry flag (the flag for no
action required) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF63</td>
				<td>D0 22</td>
				<td class="fit">BNE $EF87</td><td rowspan="1"><p>If Z flag is NOT set, the desired TRACK
and SECTOR is already free in the BAM
so branch to FRERTS to exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF65</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="3"><p>Load .A with BAM entry from (BMPNT) ,Y
($6D) ,Y, OR it with the bit map mask
from BMASK,X ($EFE9,X) to turn on (free)
the bit that corresponds to the desired
block, and store the result back into
(BMPNT) ,Y; ($6D) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EF67</td>
				<td>1D E9 EF</td>
				<td class="fit">ORA $EFE9,X</td></tr>
				<tr><td></td><td class="fit">EF6A</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF6C</td>
				<td>20 88 EF</td>
				<td class="fit">JSR $EF88</td><td rowspan="1"><p>JSR to DTYBAM ($EF88) to set the dirty
BAM flag (BAM in RAM and BAM on disk
do not match) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF6F</td>
				<td>A4 6F</td>
				<td class="fit">LDY $6F</td><td rowspan="2"><p>Load .Y with the pointer to the number
of blocks free for the track from TEMP
($6F) and clear the carry flag.</p>
</td></tr>
				<tr><td></td><td class="fit">EF71</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF72</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="3"><p>Load .A with the blocks free for the
track from (BMPNT) ,Y; ($6D) ,Y, add 1,
and store the result back into (BMPNT) ,Y</p>
</td></tr>
				<tr><td></td><td class="fit">EF74</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
				<tr><td></td><td class="fit">EF76</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF78</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="3"><p>Load .A with the TRACK ($80) number of
the block we just freed. If it is on the
directory track (#18). branch to USE10
($EFBA) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF7A</td>
				<td>CD 85 FE</td>
				<td class="fit">CMP $FE85</td></tr>
				<tr><td></td><td class="fit">EF7D</td>
				<td>F0 3B</td>
				<td class="fit">BEQ $EFBA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF7F</td>
				<td>FE FA 02</td>
				<td class="fit">INC $02FA,X</td><td rowspan="2"><p>Increment the lo byte of the count of
the total number of blocks free on the
disk, NDBL,X ($02FA,X) by 1. If the
result is NOT $00, branch to FRERTS</p>
</td></tr>
				<tr><td></td><td class="fit">EF82</td>
				<td>D0 03</td>
				<td class="fit">BNE $EF87</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF84</td>
				<td>FE FC 02</td>
				<td class="fit">INC $02FC,X</td><td rowspan="1"><p>Increment the hi byte of the count of
the total number of blocks free on the
disk, NDBH,X ($02FC,X) by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FRERTS</td><td class="fit">EF87</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set dirty-BAM flag</h1>
<p>Indicates that the copy of the BAM in
disk RAM does not match the disk copy.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DTYBAM</td><td class="fit">EF88</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="1"><p>Load .X with the current drive number
from DRVNUM ($7F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF8A</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Store a $01 into the dirty BAM flag in
MDIRTY,X ($0251) .</p>
</td></tr>
				<tr><td></td><td class="fit">EF8C</td>
				<td>9D 51 02</td>
				<td class="fit">STA $0251,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF8F</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Mark the block specified in TRACK and SECTOR as USED in the BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WUSED</td><td class="fit">EF90</td>
				<td>20 F1 EF</td>
				<td class="fit">JSR $EFF1</td><td rowspan="1"><p>JSR to FIXBAM ($EFF1) to write out the
BAM the value in WBAM indicates that it
is needed.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">USEDTS</td><td class="fit">EF93</td>
				<td>20 CF EF</td>
				<td class="fit">JSR $EFCF</td><td rowspan="1"><p>JSR to FREUSE ($EFCF) to calculate the
index to the BAM entry that contains
the desired TRACK and SECTOR. On return
.Y points to the entry and .X points to
the bit within the entry.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF96</td>
				<td>F0 36</td>
				<td class="fit">BEQ $EFCE</td><td rowspan="1"><p>If Z flag is set, the desired TRACK and
SECTOR is already marked as USED in the
BAM so branch to USERTS to exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF98</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="3"><p>Load .A with BAM entry from (BMPNT) ,Y
($6D) ,Y. EOR it with the bit map mask
from BMASK,X ($EFE9,X) to zero (in use)
the bit that corresponds to the desired
block, and store the result back into
(BMPNT) ,Y; ($6D) f Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EF9A</td>
				<td>5D E9 EF</td>
				<td class="fit">EOR $EFE9,X</td></tr>
				<tr><td></td><td class="fit">EF9D</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EF9F</td>
				<td>20 88 EF</td>
				<td class="fit">JSR $EF88</td><td rowspan="1"><p>JSR to DTYBAM ($EF88) to set the dirty
BAM flag (BAM in RAM and BAM on disk
do not match) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFA2</td>
				<td>A4 6F</td>
				<td class="fit">LDY $6F</td><td rowspan="1"><p>Load .Y with the pointer to the number
of blocks free for the track from TEMP
($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFA4</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="4"><p>Load .A with the blocks free for the
track from (BMPNT) ,Y; ($6D) ,Y, set the
carry flag, subtract $01, and store the
result back into (BMPNT) ,Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EFA6</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">EFA7</td>
				<td>E9 01</td>
				<td class="fit">SBC #$01</td></tr>
				<tr><td></td><td class="fit">EFA9</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFAB</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="3"><p>Load .A with the TRACK ($80) number of
the block we just freed. If it is on the
directory track (#18), branch to USE20
($EFBD) .</p>
</td></tr>
				<tr><td></td><td class="fit">EFAD</td>
				<td>CD 85 FE</td>
				<td class="fit">CMP $FE85</td></tr>
				<tr><td></td><td class="fit">EFB0</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $EFBD</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFB2</td>
				<td>BD FA 02</td>
				<td class="fit">LDA $02FA,X</td><td rowspan="2"><p>Load .A with the lo byte of the count of
the total number of blocks free on the
disk, NDBL,X ($02FA,X). If the lo byte
is NOT $00, branch to USE10.</p>
</td></tr>
				<tr><td></td><td class="fit">EFB5</td>
				<td>D0 03</td>
				<td class="fit">BNE $EFBA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFB7</td>
				<td>DE FC 02</td>
				<td class="fit">DEC $02FC,X</td><td rowspan="1"><p>Decrement the hi byte of the count of
the total number of blocks free on the
disk, NDBH,X ($02FC,X) by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">USE10</td><td class="fit">EFBA</td>
				<td>DE FA 02</td>
				<td class="fit">DEC $02FA,X</td><td rowspan="1"><p>Decrement the lo byte of the count of
the total number of blocks free on the
disk, NDBL,X ($02FA,X) by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">USE20</td><td class="fit">EFBD</td>
				<td>BD FC 02</td>
				<td class="fit">LDA $02FC,X</td><td rowspan="2"><p>Load .A with the hi byte of the count of
the total number of blocks free on the
disk, NDBH,X ($02FC,X). If the hi byte
is NOT $00, branch to USERTS.</p>
</td></tr>
				<tr><td></td><td class="fit">EFC0</td>
				<td>D0 0C</td>
				<td class="fit">BNE $EFCE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFC2</td>
				<td>BD FA 02</td>
				<td class="fit">LDA $02FA,X</td><td rowspan="3"><p>Load .A with the lo byte of the count of
the total number of blocks free on the
disk, NDBL,X ($02FA,X). If the lo byte
is greater than 2, branch to USERTS.</p>
</td></tr>
				<tr><td></td><td class="fit">EFC5</td>
				<td>C9 03</td>
				<td class="fit">CMP #$03</td></tr>
				<tr><td></td><td class="fit">EFC7</td>
				<td>B0 05</td>
				<td class="fit">BCS $EFCE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFC9</td>
				<td>A9 72</td>
				<td class="fit">LDA #$72</td><td rowspan="2"><p>Load .A with $72 to indicate a DISK FULL
error and JSR to ERRMSG ($E6C7) .</p>
</td></tr>
				<tr><td></td><td class="fit">EFCB</td>
				<td>20 C7 E6</td>
				<td class="fit">JSR $E6C7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">USERTS</td><td class="fit">EFCE</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Calculate index into the BAM for FRETS and USEDTS.</h1>
<pre><code>On exit: Z flag = 1 if used in BAM
	 Z flag = 0 if free in BAM</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREUSE</td><td class="fit">EFCF</td>
				<td>20 11 F0</td>
				<td class="fit">JSR $F011</td><td rowspan="1"><p>JSR to SETBAM ($F011) to set BAM image
in memory. On return .Y contains a
pointer to the start of the bit map for
the desired track.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFD2</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="1"><p>Transfer the pointer from .Y to .A.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREUS2</td><td class="fit">EFD3</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td><td rowspan="1"><p>Store the pointer from .A into TEMP
($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FREUS3</td><td class="fit">EFD5</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="4"><p>Load .A with the desired sector number
from SECTOR ($81) and do three LSR's to
divide the sector number by 8 to find
out which of the three bytes for this
track the sector is in.</p>
</td></tr>
				<tr><td></td><td class="fit">EFD7</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">EFD8</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">EFD9</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFDA</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>Set the carry flag, add the pointer to
the start of the track from TEMP ($6F)
to the sector index (0/1/2) in .A, and
transfer the result to .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">EFDB</td>
				<td>65 6F</td>
				<td class="fit">ADC $6F</td></tr>
				<tr><td></td><td class="fit">EFDD</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFDE</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="3"><p>Load .A with the desired sector number
from SECTOR ($81), AND the sector number
with $07 to find the bit position that
corresponds to that sector, and transfer
the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">EFE0</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">EFE2</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFE3</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="2"><p>Load .A with the BAM byte that contains
the bit for the desired block from
(BMPNT) ,Y; ($6D) ,Y, and AND it with the
bit map for the appropriate bit from
BMASK, X ($EFE9,X) to set the Z flag.</p>
</td></tr>
				<tr><td></td><td class="fit">EFE5</td>
				<td>3D E9 EF</td>
				<td class="fit">AND $EFE9,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFE8</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Bit mask table $EFE9-EFF0</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BMASK</td><td class="fit">EFE9</td>
				<td>01</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $01 1</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFEA</td>
				<td>02</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $02 2</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFEB</td>
				<td>04</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $04 4</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFEC</td>
				<td>08</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $08 8</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFED</td>
				<td>10</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $10 16</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFEE</td>
				<td>20</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $20 32</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFEF</td>
				<td>40</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $40 64</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFF0</td>
				<td>80</td>
				<td class="fit"></td><td rowspan="1"><p>.BYTE $80 128</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Write out BAM to disk if value in WBAM indicates that it is necessary.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FIXBAM</td><td class="fit">EFF1</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Load .A with $FF and BIT this value with
the value in WBAM ($02F9) .</p>
</td></tr>
				<tr><td></td><td class="fit">EFF3</td>
				<td>2C F9 02</td>
				<td class="fit">BIT $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFF6</td>
				<td>F0 0C</td>
				<td class="fit">BEQ $F004</td><td rowspan="1"><p>If Z flag set (WBAM was $00) branch to
FBAM10 to exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFF8</td>
				<td>10 0A</td>
				<td class="fit">BPL $F004</td><td rowspan="1"><p>If N flag clear (bit 7 of WBAM was 0)
branch to FBAM10 to exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFFA</td>
				<td>70 08</td>
				<td class="fit">BVS $F004</td><td rowspan="1"><p>If V flag set (bit 6 of WBAM was 0)
branch to FBAM10 to exit.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">EFFC</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Set WBAM ($02F9) to $00 and JSR to
DOWRIT ($D58A) to write BAM to disk.</p>
</td></tr>
				<tr><td></td><td class="fit">EFFE</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
				<tr><td></td><td class="fit">F001</td>
				<td>4C 8A D5</td>
				<td class="fit">JMP $D58A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FBAM10</td><td class="fit">F004</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Zero the BAM area</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLRBAM</td><td class="fit">F005</td>
				<td>20 3A EF</td>
				<td class="fit">JSR $EF3A</td><td rowspan="1"><p>JSR to SETBPT ($EF3A) to to set the
pointers to the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F008</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Zero .Y and .A.</p>
</td></tr>
				<tr><td></td><td class="fit">F00A</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLB1</td><td class="fit">F00B</td>
				<td>91 6D</td>
				<td class="fit">STA ($6D),Y</td><td rowspan="3"><p>Loop, using .Y as an index, to store
$00' s in all 256 locations in the BAM
buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F00D</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F00E</td>
				<td>D0 FB</td>
				<td class="fit">BNE $F00B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F010</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set BAM image in memory</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETBAM</td><td class="fit">F011</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="4"><p>Save the values of T0 ($6F) and T1 ($70)
onto the stack so we can use this as a
work area.</p>
</td></tr>
				<tr><td></td><td class="fit">F013</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">F014</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td></tr>
				<tr><td></td><td class="fit">F016</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F017</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="1"><p>Load .X with the current drive number
from DRVNUM ($7F). Load .A with the
drive status for this drive from NODRV,X
($FF,X). If the drive status is $00, we
have a functioning drive so branch to
SBM10 to continue.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F019</td>
				<td>B5 FF</td>
				<td class="fit">LDA $FF,X</td><td rowspan="4"><p>Load .A with $74 to indicate a DRIVE NOT
READY error and JSR to CMDER3 ($E648).</p>
</td></tr>
				<tr><td></td><td class="fit">F01B</td>
				<td>F0 05</td>
				<td class="fit">BEQ $F022</td></tr>
				<tr><td></td><td class="fit">F01D</td>
				<td>A9 74</td>
				<td class="fit">LDA #$74</td></tr>
				<tr><td></td><td class="fit">F01F</td>
				<td>20 48 E6</td>
				<td class="fit">JSR $E648</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SBM10</td><td class="fit">F022</td>
				<td>20 0F F1</td>
				<td class="fit">JSR $F10F</td><td rowspan="1"><p>JSR to BAM2A ($ F10F) to load .A with the
channel number  and .X with the drive #.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F025</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td><td rowspan="1"><p>Transfer the channel number (in .A) into
TO ($6F).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F027</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="5"><p>Transfer the drive number from .X into
.A, multiply itby 2 (ASL). store the
result in Tl ($70) and in .X.</p>
</td></tr>
				<tr><td></td><td class="fit">F028</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F029</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">F02B</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F02C</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F02E</td>
				<td>DD 9D 02</td>
				<td class="fit">CMP $029D,X</td><td rowspan="2"><p>Load .A with the current track number
from TRACK ($80) and compare it with
the track valuegiven in the BAM track
table, TBAM,X ($029D,X). If the values
match, the BAM is in the correct area
of memory so branch to SBM30.</p>
</td></tr>
				<tr><td></td><td class="fit">F031</td>
				<td>F0 0B</td>
				<td class="fit">BEQ $F03E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F033</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment .X by 1 and store the result
in Tl ($70). Note that .X now points to
the alternate BAM channel.</p>
</td></tr>
				<tr><td></td><td class="fit">F034</td>
				<td>86 70</td>
				<td class="fit">STX $70</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F036</td>
				<td>DD 9D 02</td>
				<td class="fit">CMP $029D,X</td><td rowspan="2"><p>Compare the current track value (in .A)
with the contents of the BAM track table
TBAM,X ($029D,X) for the alternate BAM
location. If the value match, the BAM
is in an appropriate location so branch
to SBM3 0.</p>
</td></tr>
				<tr><td></td><td class="fit">F039</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F03E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F03B</td>
				<td>20 5B F0</td>
				<td class="fit">JSR $F05B</td><td rowspan="1"><p>JSR to SWAP ($F05B) to read in the BAM
if necessary and move it to the correct
area of the disk RAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SBM30</td><td class="fit">F03E</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td><td rowspan="1"><p>Load .A with the BAM channel number from
T1 ($70).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F040</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="1"><p>Load .X with the current drive number
from DRVNUM ($7F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F042</td>
				<td>9D 9B 02</td>
				<td class="fit">STA $029B,X</td><td rowspan="1"><p>Store the channel number (in .A) into
UBAM,X ($029B,X) to set the last channel
used pointer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F045</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="5"><p>Multiply the channel number (in .A) by
four (2 x ASL), clear the carry, and
add $A1, the lo byte of the pointer, to
the start of the BAM ($02A1). Store the
result into the lo byte of the BAM
pointer, BMPNT ($6D) .</p>
</td></tr>
				<tr><td></td><td class="fit">F046</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F047</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">F048</td>
				<td>69 A1</td>
				<td class="fit">ADC #$A1</td></tr>
				<tr><td></td><td class="fit">F04A</td>
				<td>85 6D</td>
				<td class="fit">STA $6D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F04C</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="3"><p>Load .A with $02, the hi byte of the
pointer to the start of the BAM, add $00
to add in the carry (if any) from the
previous addition, and store the result-
as the hi byte of the BAM pointer,
BMPNT+1 ($6E) .</p>
</td></tr>
				<tr><td></td><td class="fit">F04E</td>
				<td>69 00</td>
				<td class="fit">ADC #$00</td></tr>
				<tr><td></td><td class="fit">F050</td>
				<td>85 6E</td>
				<td class="fit">STA $6E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F052</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="1"><p>Zero .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F054</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the original values of Tl ($70) and
TO ($6F) off the stack and store them
back in their original locations.</p>
</td></tr>
				<tr><td></td><td class="fit">F055</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">F057</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">F058</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F05A</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Swap images of the BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SWAP</td><td class="fit">F05B</td>
				<td>A6 6F</td>
				<td class="fit">LDX $6F</td><td rowspan="2"><p>Load .X with the index into the buffer
from TO ($6F) and JSR to REDBAM ($F0DF)
to read the BAM if not already in RAM.</p>
</td></tr>
				<tr><td></td><td class="fit">F05D</td>
				<td>20 DF F0</td>
				<td class="fit">JSR $F0DF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F060</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="2"><p>Load .A with the current drive number
from DRVNUM ($7F) and transfer the drive
number into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">F062</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F063</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="6"><p>Multiply the drive number in .A by two
(ASL). OR it with the least used BAM
pointer in UBAM,X ($029B,X). EOR it with
$01, and AND it with $03. Store the
result into Tl ($70) and JSR to PUTBAM
($F0A5) to put the memory image into the
BAM.</p>
</td></tr>
				<tr><td></td><td class="fit">F064</td>
				<td>1D 9B 02</td>
				<td class="fit">ORA $029B,X</td></tr>
				<tr><td></td><td class="fit">F067</td>
				<td>49 01</td>
				<td class="fit">EOR #$01</td></tr>
				<tr><td></td><td class="fit">F069</td>
				<td>29 03</td>
				<td class="fit">AND #$03</td></tr>
				<tr><td></td><td class="fit">F06B</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">F06D</td>
				<td>20 A5 F0</td>
				<td class="fit">JSR $F0A5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F070</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="3"><p>Load .A with the buffer number from
JOBNUM ($F9), multiply it by two (ASL),
and transfer the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">F072</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F073</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F074</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="4"><p>Load .A with the track number from TRACK
($80), multiply it by four (2 x ASL),
and store the result as the lo byte of
the pointer in BUFTAB,X ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">F076</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F077</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F078</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F07A</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td><td rowspan="4"><p>Load .A with the value from Tl ($70) ,
multiply it by four (2 x ASL), and
transfer the result into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">F07C</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F07D</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F07E</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SWAP3</td><td class="fit">F07F</td>
				<td>A1 99</td>
				<td class="fit">LDA ($99,X)</td><td rowspan="2"><p>Transfer one byte of the BAM from its
position in RAM, (BUFTAB,X) ($99, X), to
its proper position BAM,Y ($02A1,Y).</p>
</td></tr>
				<tr><td></td><td class="fit">F081</td>
				<td>99 A1 02</td>
				<td class="fit">STA $02A1,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F084</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero the memory location that held the
BAM byte (BUFTAB,X); ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">F086</td>
				<td>81 99</td>
				<td class="fit">STA ($99,X)</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F088</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td><td rowspan="1"><p>Increment the lo byte of the pointer to
the original BAM image BUFTAB,X ($99, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F08A</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="4"><p>Increment .Y, the pointer to the new BAM
image. Transfer this value into .A, AND
it with $03 to mask off the high order
bits, and if the result is not $00,
branch back to SWAP3 to move the next
byte.</p>
</td></tr>
				<tr><td></td><td class="fit">F08B</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">F08C</td>
				<td>29 03</td>
				<td class="fit">AND #$03</td></tr>
				<tr><td></td><td class="fit">F08E</td>
				<td>D0 EF</td>
				<td class="fit">BNE $F07F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F090</td>
				<td>A6 70</td>
				<td class="fit">LDX $70</td><td rowspan="3"><p>Load .X with the drive number from Tl
($70). Load .A with the current track
number from TRACK ($80) and store the
track number into TBAM,X ($029D,X) to
set the track number for the image.</p>
</td></tr>
				<tr><td></td><td class="fit">F092</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td></tr>
				<tr><td></td><td class="fit">F094</td>
				<td>9D 9D 02</td>
				<td class="fit">STA $029D,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F097</td>
				<td>AD F9 02</td>
				<td class="fit">LDA $02F9</td><td rowspan="2"><p>Load .A with the write-BAM flag from
WBAM ($02F9). If the flag is non-zero,
branch to SWAP4 so we don't write out
the BAM now.</p>
</td></tr>
				<tr><td></td><td class="fit">F09A</td>
				<td>D0 03</td>
				<td class="fit">BNE $F09F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F09C</td>
				<td>4C 8A D5</td>
				<td class="fit">JMP $D58A</td><td rowspan="1"><p>JMP to DOWRIT ($D58A) to write out the
BAM to disk and terminate the routine.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SWAP4</td><td class="fit">F09F</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td><td rowspan="2"><p>OR the write-BAM flag (in .A) with $80
to indicate that a write of the BAM is
pending and store the result back into
WBAM ($02F9) .</p>
</td></tr>
				<tr><td></td><td class="fit">F0A1</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0A4</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Transfer memory image of BAM into the correct position in disk RAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUTBAM</td><td class="fit">F0A5</td>
				<td>A8</td>
				<td class="fit">TAY</td><td rowspan="1"><p>Transfer the pointer in .A into .Y.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0A6</td>
				<td>B9 9D 02</td>
				<td class="fit">LDA $029D,Y</td><td rowspan="2"><p>Load .A with the track number of the BAM
from TBAM,Y ($029D,Y). If the track
number is $00. there is no BAM image
in RAM so branch to SWAP2.</p>
</td></tr>
				<tr><td></td><td class="fit">F0A9</td>
				<td>F0 25</td>
				<td class="fit">BEQ $F0D0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0AB</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="1"><p>Save the track number onto the stack.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0AC</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero the track flag in TBAM,Y ($029D,Y).</p>
</td></tr>
				<tr><td></td><td class="fit">F0AE</td>
				<td>99 9D 02</td>
				<td class="fit">STA $029D,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0B1</td>
				<td>A5 F9</td>
				<td class="fit">LDA $F9</td><td rowspan="3"><p>Load .A with the buffer number from
JOBNUM ($F9). multiply it by two (ASL) ,
and transfer the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">F0B3</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F0B4</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0B5</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="4"><p>Pull the track number off the stack,
multiply it by four (2 x ASL). and store
the result as the lo byte of the pointer
in BUFTAB,X ($99, X) .</p>
</td></tr>
				<tr><td></td><td class="fit">F0B6</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F0B7</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F0B8</td>
				<td>95 99</td>
				<td class="fit">STA $99,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0BA</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="4"><p>Transfer the pointer in .Y into .A,
multiply it by four (2 x ASL). and
transfer the result back into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">F0BB</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F0BC</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F0BD</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SWAP1</td><td class="fit">F0BE</td>
				<td>B9 A1 02</td>
				<td class="fit">LDA $02A1,Y</td><td rowspan="2"><p>Transfer one byte of the BAM image from
BAM,Y ($02A1) to (BUFTAB,X); ($99, X).</p>
</td></tr>
				<tr><td></td><td class="fit">F0C1</td>
				<td>81 99</td>
				<td class="fit">STA ($99,X)</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0C3</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero the memory location that held the
BAM byte BAM,X ($02A1,X).</p>
</td></tr>
				<tr><td></td><td class="fit">F0C5</td>
				<td>99 A1 02</td>
				<td class="fit">STA $02A1,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0C8</td>
				<td>F6 99</td>
				<td class="fit">INC $99,X</td><td rowspan="1"><p>Increment the lo byte of the pointer to
the original BAM image BUFTAB,X ($99, X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0CA</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="4"><p>Increment .Y, the pointer to the new BAM
image. Transfer this value into .A, AND
it with $03 to mask off the high order
bits, and if the result is not $00,
branch back to SWAP1 to move the next-
byte.</p>
</td></tr>
				<tr><td></td><td class="fit">F0CB</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">F0CC</td>
				<td>29 03</td>
				<td class="fit">AND #$03</td></tr>
				<tr><td></td><td class="fit">F0CE</td>
				<td>D0 EE</td>
				<td class="fit">BNE $F0BE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SWAP2</td><td class="fit">F0D0</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Zero the track number for BAM images</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLNBAM</td><td class="fit">F0D1</td>
				<td>A5 7F</td>
				<td class="fit">LDA $7F</td><td rowspan="3"><p>Load .A with the drive number from TRACK
($80). multiply it by two (ASL) , and
transfer the result into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">F0D3</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F0D4</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0D5</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Zero .A and store $00 as the track #
for the BAM image in TBAM,X ($029D,X).</p>
</td></tr>
				<tr><td></td><td class="fit">F0D7</td>
				<td>9D 9D 02</td>
				<td class="fit">STA $029D,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0DA</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="2"><p>Increment .X and store $00 as the track#
for the BAM image in TBAM,X ($029D,X) .</p>
</td></tr>
				<tr><td></td><td class="fit">F0DB</td>
				<td>9D 9D 02</td>
				<td class="fit">STA $029D,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0DE</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate the routine with an RTS,</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Read BAM from disk if not already in RAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REDBAM</td><td class="fit">F0DF</td>
				<td>B5 A7</td>
				<td class="fit">LDA $A7,X</td><td rowspan="3"><p>Load .A with the value from BUF0,X and
compare it with $FF. If it is not $FF,
the BAM is in memory so branch to RBM20.</p>
</td></tr>
				<tr><td></td><td class="fit">F0E1</td>
				<td>C9 FF</td>
				<td class="fit">CMP #$FF</td></tr>
				<tr><td></td><td class="fit">F0E3</td>
				<td>D0 25</td>
				<td class="fit">BNE $F10A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0E5</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="2"><p>Transfer the channel number from .X into
.A and save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">F0E6</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0E7</td>
				<td>20 8E D2</td>
				<td class="fit">JSR $D28E</td><td rowspan="2"><p>JSR to GETBUF ($D28E) to find a free
buffer. On return transfer the buffer
number from .A into .X.</p>
</td></tr>
				<tr><td></td><td class="fit">F0EA</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0EB</td>
				<td>10 05</td>
				<td class="fit">BPL $F0F2</td><td rowspan="1"><p>If a buffer was found (bit 7 of buffer
number not set). branch to RBM10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0ED</td>
				<td>A9 70</td>
				<td class="fit">LDA #$70</td><td rowspan="2"><p>Load .A with $70 to indicate a NO
CHANNEL ERROR and JSR to CMDERR ($C1C8) .</p>
</td></tr>
				<tr><td></td><td class="fit">F0EF</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RBM10</td><td class="fit">F0F2</td>
				<td>86 F9</td>
				<td class="fit">STX $F9</td><td rowspan="1"><p>Store the buffer number assigned (in .X)
into JOBNUM ($F9) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0F4</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the channel number off the stack
and transfer it into .Y.</p>
</td></tr>
				<tr><td></td><td class="fit">F0F5</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0F6</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="3"><p>Transfer the buffer number from .X to
.A, OR it with $80 to set it as inactive
for stealing, and store the result into
BUF0,Y ($00A7,Y) .</p>
</td></tr>
				<tr><td></td><td class="fit">F0F7</td>
				<td>09 80</td>
				<td class="fit">ORA #$80</td></tr>
				<tr><td></td><td class="fit">F0F9</td>
				<td>99 A7 00</td>
				<td class="fit">STA $00A7,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0FC</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="2"><p>Multiply the buffer number (in .A) by
two (ASL) and transfer the result into
.X.</p>
</td></tr>
				<tr><td></td><td class="fit">F0FD</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F0FE</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="2"><p>Load .A with the directory track number
(#18) from DIRTRK ($FE85) and store it
in the header table at HDRS,X ($06, X).</p>
</td></tr>
				<tr><td></td><td class="fit">F101</td>
				<td>95 06</td>
				<td class="fit">STA $06,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F103</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 as the BAM sector number in
the header table at HDRS+1,X ($07, X).</p>
</td></tr>
				<tr><td></td><td class="fit">F105</td>
				<td>95 07</td>
				<td class="fit">STA $07,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F107</td>
				<td>4C 86 D5</td>
				<td class="fit">JMP $D586</td><td rowspan="1"><p>JMP to DOREAD ($D58 6) to read in the
BAM and terminate routine.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">RBM20</td><td class="fit">F10A</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td><td rowspan="2"><p>AND the channel number (in .A) with $0F
and store the result in JOBNUM ($F9) to
set the BAM's job number.</p>
</td></tr>
				<tr><td></td><td class="fit">F10C</td>
				<td>85 F9</td>
				<td class="fit">STA $F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F10E</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Load .A with the channel # for the BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BAM2A</td><td class="fit">F10F</td>
				<td>A9 06</td>
				<td class="fit">LDA #$06</td><td rowspan="1"><p>Load .A with $06, the BAM's channel #</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F111</td>
				<td>A6 7F</td>
				<td class="fit">LDX $7F</td><td rowspan="2"><p>Load .X with the current drive number
from DRVNUM ($7F). If the drive number
is not $00, branch to B2X10.</p>
</td></tr>
				<tr><td></td><td class="fit">F113</td>
				<td>D0 03</td>
				<td class="fit">BNE $F118</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F115</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Clear the carry flag and add $07 to find
the BAM channel number for drive #1.</p>
</td></tr>
				<tr><td></td><td class="fit">F116</td>
				<td>69 07</td>
				<td class="fit">ADC #$07</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">B2X10</td><td class="fit">F118</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BAAM2X</td><td class="fit">F119</td>
				<td>20 0F F1</td>
				<td class="fit">JSR $F10F</td><td rowspan="1"><p>Load .X with the channel # for the BAM
JSR TO BAM2A ($F10F) to load .A with the
BAM's channel number.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F11C</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="1"><p>Transfer the channel # from .A to .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F11D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Next available track and sector</h1>
<p>Given current track and sector, this
routine returns the next available track
and sector.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTTS</td><td class="fit">F11E</td>
				<td>20 3E DE</td>
				<td class="fit">JSR $DE3E</td><td rowspan="1"><p>JSR to GETHDR ($DE3E) to set TRACK and
SECTOR from the most recent header.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F121</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td><td rowspan="2"><p>Store $03 into TEMP ($6F) .</p>
</td></tr>
				<tr><td></td><td class="fit">F123</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F125</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Load .A with $01, OR it with the value
of the write-BAM flag, WBAM ($02F9), and
store the result back into WBAM to
prevent a write of the BAM.</p>
</td></tr>
				<tr><td></td><td class="fit">F127</td>
				<td>0D F9 02</td>
				<td class="fit">ORA $02F9</td></tr>
				<tr><td></td><td class="fit">F12A</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTDS</td><td class="fit">F12D</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="2"><p>Load .A with the value from TEMP ($6F)
and save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">F12F</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXT1</td><td class="fit">F130</td>
				<td>20 11 F0</td>
				<td class="fit">JSR $F011</td><td rowspan="1"><p>JSR to SETBAM ($F011) to set the BAM
image into memory.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F133</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original value of TEMP off the
stack and store it back in TEMP ($6F) .</p>
</td></tr>
				<tr><td></td><td class="fit">F134</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F136</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="2"><p>Load .A with the BAM value from
(BMPNT) ,Y; ($6D,Y). If the value is not
$00 (no sectors free). branch to FNDNXT
($F173) .</p>
</td></tr>
				<tr><td></td><td class="fit">F138</td>
				<td>D0 39</td>
				<td class="fit">BNE $F173</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F13A</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="3"><p>Load .A with the current track number
from TRACK ($80). If the track number
is #18 (directory track). branch to
NXTERR to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">F13C</td>
				<td>CD 85 FE</td>
				<td class="fit">CMP $FE85</td></tr>
				<tr><td></td><td class="fit">F13F</td>
				<td>F0 19</td>
				<td class="fit">BEQ $F15A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F141</td>
				<td>90 1C</td>
				<td class="fit">BCC $F15F</td><td rowspan="1"><p>If the current track is less than #18,
branch to NXT2.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F143</td>
				<td>E6 80</td>
				<td class="fit">INC $80</td><td rowspan="1"><p>Increment the track number in TRACK ($80)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F145</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="3"><p>Compare the value of TRACK to $24 (#36),
the maximum track value. If they are not
equal, branch to NXT1 to check out this
track.</p>
</td></tr>
				<tr><td></td><td class="fit">F147</td>
				<td>CD D7 FE</td>
				<td class="fit">CMP $FED7</td></tr>
				<tr><td></td><td class="fit">F14A</td>
				<td>D0 E1</td>
				<td class="fit">BNE $F12D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F14C</td>
				<td>AE 85 FE</td>
				<td class="fit">LDX $FE85</td><td rowspan="1"><p>Load .X with $12 (#18). the directory
track number from DIRTRK ($FE85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F14F</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="1"><p>Decrement the track number in .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F150</td>
				<td>86 80</td>
				<td class="fit">STX $80</td><td rowspan="1"><p>Store the track number (in .X) into
TRACK ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F152</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 as the sector number into
SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">F154</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F156</td>
				<td>C6 6F</td>
				<td class="fit">DEC $6F</td><td rowspan="1"><p>Decrement the counter in TEMP ($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F158</td>
				<td>D0 D3</td>
				<td class="fit">BNE $F12D</td><td rowspan="1"><p>If the count is not $00 yet, branch to
NXT1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXTERR</td><td class="fit">F15A</td>
				<td>A9 72</td>
				<td class="fit">LDA #$72</td><td rowspan="2"><p>Load .A with $72 to indicate a DISK FULL
error and JSR to CMDERR ($C1C8).</p>
</td></tr>
				<tr><td></td><td class="fit">F15C</td>
				<td>20 C8 C1</td>
				<td class="fit">JSR $C1C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NXT2</td><td class="fit">F15F</td>
				<td>C6 80</td>
				<td class="fit">DEC $80</td><td rowspan="1"><p>Decrement the track number in TRACK ($80)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F161</td>
				<td>D0 CA</td>
				<td class="fit">BNE $F12D</td><td rowspan="1"><p>If the value in TRACK is not $00, branch
to NXT1 to check out this track.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F163</td>
				<td>AE 85 FE</td>
				<td class="fit">LDX $FE85</td><td rowspan="1"><p>Load .X with $12 (#18). the directory
track number from DIRTRK ($FE85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F166</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="1"><p>Increment the track number in .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F167</td>
				<td>86 80</td>
				<td class="fit">STX $80</td><td rowspan="1"><p>Store the track number (in .X) into
TRACK ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F169</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 as the sector number into
SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">F16B</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F16D</td>
				<td>C6 6F</td>
				<td class="fit">DEC $6F</td><td rowspan="1"><p>Decrement the counter in TEMP ($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F16F</td>
				<td>D0 BC</td>
				<td class="fit">BNE $F12D</td><td rowspan="1"><p>If the count is not $00 yet, branch to
NXT1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F171</td>
				<td>F0 E7</td>
				<td class="fit">BEQ $F15A</td><td rowspan="1"><p>If the count is $00, branch to NXTERR.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find the optimum next sector on this track</h1>
<p>Next sector = Current + change (#10)</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDNXT</td><td class="fit">F173</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="1"><p>Load .A with the sector number from
SECTOR ($81) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F175</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Clear the carry flag and add the sector
increment from SECINC ($69). The normal
increment is $0A (#10). It is $03 for
the directory track.</p>
</td></tr>
				<tr><td></td><td class="fit">F176</td>
				<td>65 69</td>
				<td class="fit">ADC $69</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F178</td>
				<td>85 81</td>
				<td class="fit">STA $81</td><td rowspan="1"><p>Store the new sector number into SECTOR.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F17A</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="2"><p>Load .A with the current track number
from TRACK ($80) and JSR to MAXSEC
($F24B) to find the maximum sector
number on this track (returned in .A) .</p>
</td></tr>
				<tr><td></td><td class="fit">F17C</td>
				<td>20 4B F2</td>
				<td class="fit">JSR $F24B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F17F</td>
				<td>8D 4E 02</td>
				<td class="fit">STA $024E</td><td rowspan="2"><p>Store the maximum sector number into
LSTSEC ($024E) and CMD ($024D).</p>
</td></tr>
				<tr><td></td><td class="fit">F182</td>
				<td>8D 4D 02</td>
				<td class="fit">STA $024D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F185</td>
				<td>C5 81</td>
				<td class="fit">CMP $81</td><td rowspan="2"><p>Compare the maximum sector number (in
.A) with the new sector value in SECTOR
($81). If the new sector value is less
than the maximum, branch to FNDNO.</p>
</td></tr>
				<tr><td></td><td class="fit">F187</td>
				<td>B0 0C</td>
				<td class="fit">BCS $F195</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>New sector number too big so subtract
away the maximum sector number on track.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F189</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="1"><p>Set the carry flag.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F18A</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="1"><p>Load .A with the new sector number from
SECTOR ($80) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F18C</td>
				<td>ED 4E 02</td>
				<td class="fit">SBC $024E</td><td rowspan="2"><p>Subtract the maximum sector number on
this track from LSTSEC ($024E) and store
the result into SECTOR ($81).</p>
</td></tr>
				<tr><td></td><td class="fit">F18F</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F191</td>
				<td>F0 02</td>
				<td class="fit">BEQ $F195</td><td rowspan="1"><p>If the revised sector number is $00,
branch to FNDNO.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F193</td>
				<td>C6 81</td>
				<td class="fit">DEC $81</td><td rowspan="1"><p>Decrement the revised sector number in
SECTOR ($81) by 1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDN0</td><td class="fit">F195</td>
				<td>20 FA F1</td>
				<td class="fit">JSR $F1FA</td><td rowspan="1"><p>JSR to GETSEC ($F1FA) to set the BAM
into memory and find the first available
sector following the revised sector #.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F198</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F19D</td><td rowspan="1"><p>If no sector is available on this track
(Z flag = 1), branch to FNDN2 .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDN1</td><td class="fit">F19A</td>
				<td>4C 90 EF</td>
				<td class="fit">JMP $EF90</td><td rowspan="1"><p>Exit with a JMP to WUSED ($EF90) to set
this new sector as in use.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDN2</td><td class="fit">F19D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Set the sector number in SECTOR ($81)
to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">F19F</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1A1</td>
				<td>20 FA F1</td>
				<td class="fit">JSR $F1FA</td><td rowspan="1"><p>JSR to GETSEC ($F1FA) to set the BAM
into memory and find the first available
sector following the revised sector #.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1A4</td>
				<td>D0 F4</td>
				<td class="fit">BNE $F19A</td><td rowspan="1"><p>If a sector is available on this track
(Z flag = 0), branch to FNDN1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1A6</td>
				<td>4C F5 F1</td>
				<td class="fit">JMP $F1F5</td><td rowspan="1"><p>JMP to DERR ($F1F5) to abort.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Find optimum initial track and sector</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INTTS</td><td class="fit">F1A9</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Load .A with $01, OR it with the write-
BAM flag, WBAM ($02F9). and store the
result back in WBAM to indicate a write
of BAM is pending.</p>
</td></tr>
				<tr><td></td><td class="fit">F1AB</td>
				<td>0D F9 02</td>
				<td class="fit">ORA $02F9</td></tr>
				<tr><td></td><td class="fit">F1AE</td>
				<td>8D F9 02</td>
				<td class="fit">STA $02F9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1B1</td>
				<td>A5 86</td>
				<td class="fit">LDA $86</td><td rowspan="2"><p>Load .A with the value from R0 ($86) and
save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">F1B3</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1B4</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Store $01 into R0 ($86) .
NOTE: TRACK = DIRECTORY TRACK - R0</p>
</td></tr>
				<tr><td></td><td class="fit">F1B6</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1B8</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="1"><p>Load .A with the directory track number
($12) from DIRTRK ($FE85) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1BB</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="3"><p>Set the carry flag, subtract the counter
in R0 and store the result into TRACK
($80) .</p>
</td></tr>
				<tr><td></td><td class="fit">F1BC</td>
				<td>E5 86</td>
				<td class="fit">SBC $86</td></tr>
				<tr><td></td><td class="fit">F1BE</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1C0</td>
				<td>90 09</td>
				<td class="fit">BCC $F1CB</td><td rowspan="2"><p>If the value in TRACK is less than or
equal to 0, branch to ITS2.</p>
</td></tr>
				<tr><td></td><td class="fit">F1C2</td>
				<td>F0 07</td>
				<td class="fit">BEQ $F1CB</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Do tracks 17 -&gt; 1</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1C4</td>
				<td>20 11 F0</td>
				<td class="fit">JSR $F011</td><td rowspan="1"><p>JSR to SETBAM ($F011) to set the pointer
to the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1C7</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="1"><p>Load .A with the number of blocks free
on this track from (BMPNT) ,Y; ($6D,Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1C9</td>
				<td>D0 1B</td>
				<td class="fit">BNE $F1E6</td><td rowspan="1"><p>If some sectors are free on this track
(Z flag not set). branch to FNDSEC
($F1E6) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>None free on lower track so try a higher
one:</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ITS2</td><td class="fit">F1CB</td>
				<td>AD 85 FE</td>
				<td class="fit">LDA $FE85</td><td rowspan="1"><p>Load .A with the directory track number
($12) from DIRTRK ($FE85).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1CE</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="3"><p>Clear the carry flag, add the counter in
R0 and store the result into TRACK ($80)</p>
</td></tr>
				<tr><td></td><td class="fit">F1CF</td>
				<td>65 86</td>
				<td class="fit">ADC $86</td></tr>
				<tr><td></td><td class="fit">F1D1</td>
				<td>85 80</td>
				<td class="fit">STA $80</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1D3</td>
				<td>E6 86</td>
				<td class="fit">INC $86</td><td rowspan="1"><p>Increment the track counter in R0 ($86) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1D5</td>
				<td>CD D7 FE</td>
				<td class="fit">CMP $FED7</td><td rowspan="2"><p>If the value in TRACK is greater than or
equal to the maximum track number (#36),
branch to ITS3.</p>
</td></tr>
				<tr><td></td><td class="fit">F1D8</td>
				<td>90 05</td>
				<td class="fit">BCC $F1DF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1DA</td>
				<td>A9 67</td>
				<td class="fit">LDA #$67</td><td rowspan="2"><p>Load .A with $6 7 to indicate a SYSTEM
TRACK &amp; SECTOR error and JSR to CMDER2
($E645) .</p>
</td></tr>
				<tr><td></td><td class="fit">F1DC</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ITS3</td><td class="fit">F1DF</td>
				<td>20 11 F0</td>
				<td class="fit">JSR $F011</td><td rowspan="1"><p>Do tracks 19 -&gt; 35
JSR to SETBAM ($F011) to set the pointer
to the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1E2</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="1"><p>Load .A with the number of blocks free
on this track from (BMPNT) ,Y; ($6D,Y) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1E4</td>
				<td>F0 D2</td>
				<td class="fit">BEQ $F1B8</td><td rowspan="1"><p>If no sectors are free on this track
(Z flag is set). branch to ITS1 to try
a lower numbered track.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FNDSEC</td><td class="fit">F1E6</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original value of RO off the
stack and store it back in RO ($86).</p>
</td></tr>
				<tr><td></td><td class="fit">F1E7</td>
				<td>85 86</td>
				<td class="fit">STA $86</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1E9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 as the sector number in
SECTOR ($81) .</p>
</td></tr>
				<tr><td></td><td class="fit">F1EB</td>
				<td>85 81</td>
				<td class="fit">STA $81</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1ED</td>
				<td>20 FA F1</td>
				<td class="fit">JSR $F1FA</td><td rowspan="1"><p>JSR to GETSEC ($F1FA) to set the BAM and
find first available sector.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1F0</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F1F5</td><td rowspan="1"><p>If no sector available, branch to DERR.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1F2</td>
				<td>4C 90 EF</td>
				<td class="fit">JMP $EF90</td><td rowspan="1"><p>Terminate routine with a JMP to WUSED
($EF90) to mark sector as used in BAM.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Error in BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DERR</td><td class="fit">F1F5</td>
				<td>A9 71</td>
				<td class="fit">LDA #$71</td><td rowspan="2"><p>Load .A with $71 to indicate an error
in the BAM and JSR to CMDER2 ($E645) .</p>
</td></tr>
				<tr><td></td><td class="fit">F1F7</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set the BAM and find the first available sector starting at SECTOR</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GETSEC</td><td class="fit">F1FA</td>
				<td>20 11 F0</td>
				<td class="fit">JSR $F011</td><td rowspan="1"><p>JSR to SETBAM ($F011) to set the pointer
to the BAM.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1FD</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>Transfer the .Y value into .A and save
it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">F1FE</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F1FF</td>
				<td>20 20 F2</td>
				<td class="fit">JSR $F220</td><td rowspan="1"><p>JSR to AVCK ($F220) to check the bit map
validity.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F202</td>
				<td>A5 80</td>
				<td class="fit">LDA $80</td><td rowspan="3"><p>Load .A with the current track number
from TRACK ($80) and JSR to MAXSEC
($F24B) to find the maximum sector
number allowed on this track. On return,
store the maximum sector number (in .A)
into LSTSEC ($024E) .</p>
</td></tr>
				<tr><td></td><td class="fit">F204</td>
				<td>20 4B F2</td>
				<td class="fit">JSR $F24B</td></tr>
				<tr><td></td><td class="fit">F207</td>
				<td>8D 4E 02</td>
				<td class="fit">STA $024E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F20A</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original .Y value off the stack
and store it in TEMP ($6F) .</p>
</td></tr>
				<tr><td></td><td class="fit">F20B</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GS10</td><td class="fit">F20D</td>
				<td>A5 81</td>
				<td class="fit">LDA $81</td><td rowspan="3"><p>Compare the current sector number from
SECTOR ($81) with the maximum sector
count in LSTSEC ($024E). If the current
sector number is too large, branch to
GS20.</p>
</td></tr>
				<tr><td></td><td class="fit">F20F</td>
				<td>CD 4E 02</td>
				<td class="fit">CMP $024E</td></tr>
				<tr><td></td><td class="fit">F212</td>
				<td>B0 09</td>
				<td class="fit">BCS $F21D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F214</td>
				<td>20 D5 EF</td>
				<td class="fit">JSR $EFD5</td><td rowspan="2"><p>JSR to FREUS3 ($EFD5) to calculate index
into the BAM. On return, if the Z flag
is not set, the sector is free so branch
to GS30.</p>
</td></tr>
				<tr><td></td><td class="fit">F217</td>
				<td>D0 06</td>
				<td class="fit">BNE $F21F</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Sector was not free</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F219</td>
				<td>E6 81</td>
				<td class="fit">INC $81</td><td rowspan="2"><p>Increment the sector number in SECTOR
($81) and branch (always) to GS10.</p>
</td></tr>
				<tr><td></td><td class="fit">F21B</td>
				<td>D0 F0</td>
				<td class="fit">BNE $F20D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GS20</td><td class="fit">F21D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="1"><p>Load .A with $00. Note that this sets
the Z flag to indicate that a free
sector was not found.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GS30</td><td class="fit">F21F</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Check the validity of the bit map</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AVCK</td><td class="fit">F220</td>
				<td>A5 6F</td>
				<td class="fit">LDA $6F</td><td rowspan="2"><p>Load .A with the value of TEMP ($6F) and
save it onto the stack.</p>
</td></tr>
				<tr><td></td><td class="fit">F222</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F223</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 into TEMP ($6F) .</p>
</td></tr>
				<tr><td></td><td class="fit">F225</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F227</td>
				<td>AC 86 FE</td>
				<td class="fit">LDY $FE86</td><td rowspan="1"><p>Load .Y with $04, the number of bytes
per track in the BAM from BAMSIZ ($FE86)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F22A</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="1"><p>Decrement .Y by 1 (now $03) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AC10</td><td class="fit">F22B</td>
				<td>A2 07</td>
				<td class="fit">LDX #$07</td><td rowspan="1"><p>Load .X with $07 (bit counter).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AC20</td><td class="fit">F22D</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="3"><p>Load .A with the BAM byte for this track
from (BMPNT) ,Y; ($6D,Y). and AND the BAM
byte with the bit mask from BMASK,X
($EFE9,X) to isolate the bit for this
sector. If the result is $00, the sector
is allocated so branch to AC30.</p>
</td></tr>
				<tr><td></td><td class="fit">F22F</td>
				<td>3D E9 EF</td>
				<td class="fit">AND $EFE9,X</td></tr>
				<tr><td></td><td class="fit">F232</td>
				<td>F0 02</td>
				<td class="fit">BEQ $F236</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F234</td>
				<td>E6 6F</td>
				<td class="fit">INC $6F</td><td rowspan="1"><p>Since the sector is free, increment the
count of free sectors in TEMP ($6F) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AC30</td><td class="fit">F236</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement the bit counter (1 bit/sector)
in .X. If the count is greater than or
equal to $00, branch to AC20.</p>
</td></tr>
				<tr><td></td><td class="fit">F237</td>
				<td>10 F4</td>
				<td class="fit">BPL $F22D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F239</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="2"><p>Decrement the byte counter (8 sectors/
byte) in .Y. If the count is not $00,
branch to AGIO.</p>
</td></tr>
				<tr><td></td><td class="fit">F23A</td>
				<td>D0 EF</td>
				<td class="fit">BNE $F22B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F23C</td>
				<td>B1 6D</td>
				<td class="fit">LDA ($6D),Y</td><td rowspan="3"><p>Compare the number of bytes free on the
track as given in the BAM at (BMPNT) ,Y
($6D,Y) with the count we did in TEMP
($6F). If the counts DO NOT MATCH,
branch to AC40 to abort.</p>
</td></tr>
				<tr><td></td><td class="fit">F23E</td>
				<td>C5 6F</td>
				<td class="fit">CMP $6F</td></tr>
				<tr><td></td><td class="fit">F240</td>
				<td>D0 04</td>
				<td class="fit">BNE $F246</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F242</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="2"><p>Pull the original value of TEMP off the
stack and restore it into TEMP ($6F) .</p>
</td></tr>
				<tr><td></td><td class="fit">F243</td>
				<td>85 6F</td>
				<td class="fit">STA $6F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F245</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Error in BAM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">AC40</td><td class="fit">F246</td>
				<td>A9 71</td>
				<td class="fit">LDA #$71</td><td rowspan="2"><p>Load .A with $71 to indicate an error
in the BAM and JSR to CMDER2 ($E645) .</p>
</td></tr>
				<tr><td></td><td class="fit">F248</td>
				<td>20 45 E6</td>
				<td class="fit">JSR $E645</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MAXSEC</td><td class="fit">F24B</td>
				<td>AE D6 FE</td>
				<td class="fit">LDX $FED6</td><td rowspan="1"><p>Returns the number of sectors allowed
on this track. Track number in .A.
Load .X with the number of zones ($04)
from NZONES ($FED6) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MAX1</td><td class="fit">F24E</td>
				<td>DD D6 FE</td>
				<td class="fit">CMP $FED6,X</td><td rowspan="1"><p>Compare the track number (in .A) with
the zone boundary value from TRKNUM-1,X
($FED6,X) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F251</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="1"><p>Decrement the zone count in .X.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F252</td>
				<td>B0 FA</td>
				<td class="fit">BCS $F24E</td><td rowspan="1"><p>If the track number in .A is less than
the boundary value, branch to MAX1.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F254</td>
				<td>BD D1 FE</td>
				<td class="fit">LDA $FED1,X</td><td rowspan="1"><p>Load .A with the number of sectors/track
for this zone from NUMSEC,X ($FED1,X).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F257</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Kill protection: Does NOTHING on 1541!</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">KILLP</td><td class="fit">F258</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Terminate routine with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Disk contoller routines</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CNTINT</td><td class="fit">F259</td>
				<td>A9 6F</td>
				<td class="fit">LDA #$6F</td><td rowspan="1"><p>Controller initialization</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F25B</td>
				<td>8D 02 1C</td>
				<td class="fit">STA $1C02</td><td rowspan="1"><p>Store %01101111 in DDRB2 ($1C02) to set
the data direction for Port B.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F25E</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td><td rowspan="6"><p>Store %01100000 in DSKCNT ($1C00) to
turn off the motor &amp; LED and set phase A</p>
</td></tr>
				<tr><td></td><td class="fit">F260</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
				<tr><td></td><td class="fit">F263</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td></tr>
				<tr><td></td><td class="fit">F266</td>
				<td>29 FE</td>
				<td class="fit">AND #$FE</td></tr>
				<tr><td></td><td class="fit">F268</td>
				<td>09 0E</td>
				<td class="fit">ORA #$0E</td></tr>
				<tr><td></td><td class="fit">F26A</td>
				<td>09 E0</td>
				<td class="fit">ORA #$E0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F26C</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td><td rowspan="6"><p>Set the peripheral control register
($1C0C) for neg edge latch mode, CA2 hi
to disable the SO line to the 6502, CB1
is input, and CB2 is R/W mode control.</p>
</td></tr>
				<tr><td></td><td class="fit">F26F</td>
				<td>A9 41</td>
				<td class="fit">LDA #$41</td></tr>
				<tr><td></td><td class="fit">F271</td>
				<td>8D 0B 1C</td>
				<td class="fit">STA $1C0B</td></tr>
				<tr><td></td><td class="fit">F274</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">F276</td>
				<td>8D 06 1C</td>
				<td class="fit">STA $1C06</td></tr>
				<tr><td></td><td class="fit">F279</td>
				<td>A9 3A</td>
				<td class="fit">LDA #$3A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F27B</td>
				<td>8D 07 1C</td>
				<td class="fit">STA $1C07</td><td rowspan="2"><p>Set T1HL2 ($1C07) to $3A and T1LL2 ( $1C06 )
to $00 so there is 20ms between IRQ's</p>
</td></tr>
				<tr><td></td><td class="fit">F27E</td>
				<td>8D 05 1C</td>
				<td class="fit">STA $1C05</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F281</td>
				<td>A9 7F</td>
				<td class="fit">LDA #$7F</td><td rowspan="2"><p>Store $7F in IER2 ($1C0E) to clear all
IRQ sources.</p>
</td></tr>
				<tr><td></td><td class="fit">F283</td>
				<td>8D 0E 1C</td>
				<td class="fit">STA $1C0E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F286</td>
				<td>A9 C0</td>
				<td class="fit">LDA #$C0</td><td rowspan="3"><p>Store $C0 in IFR2 ($1C0D) to clear the
bit and then into IER2 ($1C0E) to enable
the timer IRQ.</p>
</td></tr>
				<tr><td></td><td class="fit">F288</td>
				<td>8D 0D 1C</td>
				<td class="fit">STA $1C0D</td></tr>
				<tr><td></td><td class="fit">F28B</td>
				<td>8D 0E 1C</td>
				<td class="fit">STA $1C0E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F28E</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="3"><p>Store $FF as the current drive, CDRIVE
($3E) and as init flag, FTNUM ($51).</p>
</td></tr>
				<tr><td></td><td class="fit">F290</td>
				<td>85 3E</td>
				<td class="fit">STA $3E</td></tr>
				<tr><td></td><td class="fit">F292</td>
				<td>85 51</td>
				<td class="fit">STA $51</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F294</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td><td rowspan="2"><p>Set header block ID, HBID ($39) to $08</p>
</td></tr>
				<tr><td></td><td class="fit">F296</td>
				<td>85 39</td>
				<td class="fit">STA $39</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F298</td>
				<td>A9 07</td>
				<td class="fit">LDA #$07</td><td rowspan="2"><p>Set data block ID, DBID ($47) to $07</p>
</td></tr>
				<tr><td></td><td class="fit">F29A</td>
				<td>85 47</td>
				<td class="fit">STA $47</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F29C</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td><td rowspan="4"><p>Set NXTST ($62/3) to point to INACT
($FA05) .</p>
</td></tr>
				<tr><td></td><td class="fit">F29E</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">F2A0</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">F2A2</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2A4</td>
				<td>A9 C8</td>
				<td class="fit">LDA #$C8</td><td rowspan="2"><p>Set MINSTP ($64) to 200 to indicate the
minimum number of steps required to
invoke the fast stepping mode.</p>
</td></tr>
				<tr><td></td><td class="fit">F2A6</td>
				<td>85 64</td>
				<td class="fit">STA $64</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2A8</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>Store 4 into AS ($5E) to indicate the
number of steps needed to accelerate
and decelerate the head.</p>
</td></tr>
				<tr><td></td><td class="fit">F2AA</td>
				<td>85 5E</td>
				<td class="fit">STA $5E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2AC</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>Store 4 into AF ($5F) as the
acceleration/ deceleration factor.</p>
</td></tr>
				<tr><td></td><td class="fit">F2AE</td>
				<td>85 5F</td>
				<td class="fit">STA $5F</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Main controller loop</h1>
<ul>
<li>Scans the job queue for job requests</li>
<li>Finds job on current track if it exists</li>
</ul>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">LCC</td><td class="fit">F2B0</td>
				<td>BA</td>
				<td class="fit">TSX</td><td rowspan="2"><p>Save stack pointer in SAVSP ($49) .</p>
</td></tr>
				<tr><td></td><td class="fit">F2B1</td>
				<td>86 49</td>
				<td class="fit">STX $49</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2B3</td>
				<td>AD 04 1C</td>
				<td class="fit">LDA $1C04</td><td rowspan="1"><p>Reset IRQ flag</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2B6</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td><td rowspan="3"><p>Set bits 3,2, &amp; 1 of PCR2 ($1C0C) to
enable S.O. to 6502, hi output</p>
</td></tr>
				<tr><td></td><td class="fit">F2B9</td>
				<td>09 0E</td>
				<td class="fit">ORA #$0E</td></tr>
				<tr><td></td><td class="fit">F2BB</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TOP</td><td class="fit">F2BE</td>
				<td>A0 05</td>
				<td class="fit">LDY #$05</td><td rowspan="2"><p>Top of loop to scan job queue. Load .Y
with #$05 as pointer to top of queue.</p>
</td></tr>
				<tr><td></td><td class="fit">F2C0</td>
				<td>B9 00 00</td>
				<td class="fit">LDA $0000,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CONT10</td><td class="fit">F2C3</td>
				<td>10 2E</td>
				<td class="fit">BPL $F2F3</td><td rowspan="1"><p>Load .A with byte from queue, JOBS,Y
($0000, Y). Test if bit 7 is set. If not,
branch to CONT20 since no job here.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2C5</td>
				<td>C9 D0</td>
				<td class="fit">CMP #$D0</td><td rowspan="3"><p>Check if job is a jump code ($D0) .
If not, branch to CONT30.</p>
</td></tr>
				<tr><td></td><td class="fit">F2C7</td>
				<td>D0 04</td>
				<td class="fit">BNE $F2CD</td></tr>
				<tr><td></td><td class="fit">F2C9</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2CA</td>
				<td>4C 70 F3</td>
				<td class="fit">JMP $F370</td><td rowspan="1"><p>Transfer queue position from .Y to .A
and JMP to EX2 ($F370) to do jump job.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CONT30</td><td class="fit">F2CD</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="2"><p>AND job code with $01. If result is 0,
the drive # is valid so branch to CONT35</p>
</td></tr>
				<tr><td></td><td class="fit">F2CF</td>
				<td>F0 07</td>
				<td class="fit">BEQ $F2D8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2D1</td>
				<td>84 3F</td>
				<td class="fit">STY $3F</td><td rowspan="3"><p>Load .A with $0F to indicate a bad drive
number and JMP to ERRR ($F969)</p>
</td></tr>
				<tr><td></td><td class="fit">F2D3</td>
				<td>A9 0F</td>
				<td class="fit">LDA #$0F</td></tr>
				<tr><td></td><td class="fit">F2D5</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CONT35</td><td class="fit">F2D8</td>
				<td>AA</td>
				<td class="fit">TAX</td><td rowspan="2"><p>Store job drive # in DRIVE ($3D) .</p>
</td></tr>
				<tr><td></td><td class="fit">F2D9</td>
				<td>85 3D</td>
				<td class="fit">STA $3D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2DB</td>
				<td>C5 3E</td>
				<td class="fit">CMP $3E</td><td rowspan="2"><p>Compare job drive # with current drive
number in CDRIVE ($3E). (CDRIVE is $FF
if the drive is not turned on.) If they
are equal, branch to CONT40</p>
</td></tr>
				<tr><td></td><td class="fit">F2DD</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $F2E9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2DF</td>
				<td>20 7E F9</td>
				<td class="fit">JSR $F97E</td><td rowspan="1"><p>JSR to TURNON ($F97E) to turn on drive.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2E2</td>
				<td>A5 3D</td>
				<td class="fit">LDA $3D</td><td rowspan="3"><p>Set CDRIVE to job drive # and exit for
now with a JMP to END ($F99C).</p>
</td></tr>
				<tr><td></td><td class="fit">F2E4</td>
				<td>85 3E</td>
				<td class="fit">STA $3E</td></tr>
				<tr><td></td><td class="fit">F2E6</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CONT40</td><td class="fit">F2E9</td>
				<td>A5 20</td>
				<td class="fit">LDA $20</td><td rowspan="2"><p>Check the value in DRVST ($20) to see if
the drive is up to speed. If bit 7 is
set, it isn't so JMP to END ($F99C).</p>
</td></tr>
				<tr><td></td><td class="fit">F2EB</td>
				<td>30 03</td>
				<td class="fit">BMI $F2F0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2ED</td>
				<td>0A</td>
				<td class="fit">ASL</td><td rowspan="3"><p>Check if the head is stepping. If it is,
exit with a JMP to END ($F99C). If it is
not stepping, branch to QUE.</p>
</td></tr>
				<tr><td></td><td class="fit">F2EE</td>
				<td>10 09</td>
				<td class="fit">BPL $F2F9</td></tr>
				<tr><td></td><td class="fit">F2F0</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CONT20</td><td class="fit">F2F3</td>
				<td>88</td>
				<td class="fit">DEY</td><td rowspan="3"><p>Decrement .Y pointer into queue. If more
locations in queue, branch back to
CONT10. If none left JMP to END ($F99C).</p>
</td></tr>
				<tr><td></td><td class="fit">F2F4</td>
				<td>10 CA</td>
				<td class="fit">BPL $F2C0</td></tr>
				<tr><td></td><td class="fit">F2F6</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">QUE</td><td class="fit">F2F9</td>
				<td>A9 20</td>
				<td class="fit">LDA #$20</td><td rowspan="2"><p>Store $20 in DRVST ($20) to set drive
status to running.</p>
</td></tr>
				<tr><td></td><td class="fit">F2FB</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F2FD</td>
				<td>A0 05</td>
				<td class="fit">LDY #$05</td><td rowspan="4"><p>Check if head needs to be stepped for
this job. If not, branch to QUE20.</p>
</td></tr>
				<tr><td></td><td class="fit">F2FF</td>
				<td>84 3F</td>
				<td class="fit">STY $3F</td></tr>
				<tr><td></td><td class="fit">F301</td>
				<td>20 93 F3</td>
				<td class="fit">JSR $F393</td></tr>
				<tr><td></td><td class="fit">F304</td>
				<td>30 1A</td>
				<td class="fit">BMI $F320</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">QUE05</td><td class="fit">F306</td>
				<td>C6 3F</td>
				<td class="fit">DEC $3F</td><td rowspan="7"><p>Check other jobs to see if one for this
track. If not, calculate steps needed.</p>
</td></tr>
				<tr><td></td><td class="fit">F308</td>
				<td>10 F7</td>
				<td class="fit">BPL $F301</td></tr>
				<tr><td></td><td class="fit">F30A</td>
				<td>A4 41</td>
				<td class="fit">LDY $41</td></tr>
				<tr><td></td><td class="fit">F30C</td>
				<td>20 95 F3</td>
				<td class="fit">JSR $F395</td></tr>
				<tr><td></td><td class="fit">F30F</td>
				<td>A5 42</td>
				<td class="fit">LDA $42</td></tr>
				<tr><td></td><td class="fit">F311</td>
				<td>85 4A</td>
				<td class="fit">STA $4A</td></tr>
				<tr><td></td><td class="fit">F313</td>
				<td>06 4A</td>
				<td class="fit">ASL $4A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F315</td>
				<td>A9 60</td>
				<td class="fit">LDA #$60</td><td rowspan="5"><p>Store $60 in DRVST ($20) to set drive
status to stepping, store destination
track in DRVTRK ($22) and exit for now
with a JMP to END ($F99C) .</p>
</td></tr>
				<tr><td></td><td class="fit">F317</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
				<tr><td></td><td class="fit">F319</td>
				<td>B1 32</td>
				<td class="fit">LDA ($32),Y</td></tr>
				<tr><td></td><td class="fit">F31B</td>
				<td>85 22</td>
				<td class="fit">STA $22</td></tr>
				<tr><td></td><td class="fit">F31D</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">QUE20</td><td class="fit">F320</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td><td rowspan="5"><p>Check if job is on current drive. If
not, branch back to QUE05.</p>
</td></tr>
				<tr><td></td><td class="fit">F322</td>
				<td>C5 3D</td>
				<td class="fit">CMP $3D</td></tr>
				<tr><td></td><td class="fit">F324</td>
				<td>D0 E0</td>
				<td class="fit">BNE $F306</td></tr>
				<tr><td></td><td class="fit">F326</td>
				<td>A5 22</td>
				<td class="fit">LDA $22</td></tr>
				<tr><td></td><td class="fit">F328</td>
				<td>F0 12</td>
				<td class="fit">BEQ $F33C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F32A</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="2"><p>Calculate distance to track</p>
</td></tr>
				<tr><td></td><td class="fit">F32B</td>
				<td>F1 32</td>
				<td class="fit">SBC ($32),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F32D</td>
				<td>F0 0D</td>
				<td class="fit">BEQ $F33C</td><td rowspan="1"><p>Are we on track already? if so, branch
to GOTU.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F32F</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td><td rowspan="5"><p>Store number of steps to the desired
track in NXTRK ($42)</p>
</td></tr>
				<tr><td></td><td class="fit">F331</td>
				<td>85 42</td>
				<td class="fit">STA $42</td></tr>
				<tr><td></td><td class="fit">F333</td>
				<td>E6 42</td>
				<td class="fit">INC $42</td></tr>
				<tr><td></td><td class="fit">F335</td>
				<td>A5 3F</td>
				<td class="fit">LDA $3F</td></tr>
				<tr><td></td><td class="fit">F337</td>
				<td>85 41</td>
				<td class="fit">STA $41</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F339</td>
				<td>4C 06 F3</td>
				<td class="fit">JMP $F306</td><td rowspan="1"><p>JMP back to QUE05 to check if another
job is closer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GOTU</td><td class="fit">F33C</td>
				<td>A2 04</td>
				<td class="fit">LDX #$04</td><td rowspan="8"><p>Calculate zone (1-4) of the desired
track and store the number of sectors
on the track in SECTR ($43).</p>
</td></tr>
				<tr><td></td><td class="fit">F33E</td>
				<td>B1 32</td>
				<td class="fit">LDA ($32),Y</td></tr>
				<tr><td></td><td class="fit">F340</td>
				<td>85 40</td>
				<td class="fit">STA $40</td></tr>
				<tr><td></td><td class="fit">F342</td>
				<td>DD D6 FE</td>
				<td class="fit">CMP $FED6,X</td></tr>
				<tr><td></td><td class="fit">F345</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">F346</td>
				<td>B0 FA</td>
				<td class="fit">BCS $F342</td></tr>
				<tr><td></td><td class="fit">F348</td>
				<td>BD D1 FE</td>
				<td class="fit">LDA $FED1,X</td></tr>
				<tr><td></td><td class="fit">F34B</td>
				<td>85 43</td>
				<td class="fit">STA $43</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F34D</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="11"><p>Calculate recording density and set the
divide by N counter by storing a value
in DSKCNT ($1C00) .</p>
</td></tr>
				<tr><td></td><td class="fit">F34E</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F34F</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F350</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F351</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F352</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F353</td>
				<td>85 44</td>
				<td class="fit">STA $44</td></tr>
				<tr><td></td><td class="fit">F355</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td></tr>
				<tr><td></td><td class="fit">F358</td>
				<td>29 9F</td>
				<td class="fit">AND #$9F</td></tr>
				<tr><td></td><td class="fit">F35A</td>
				<td>05 44</td>
				<td class="fit">ORA $44</td></tr>
				<tr><td></td><td class="fit">F35C</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F35F</td>
				<td>A6 3D</td>
				<td class="fit">LDX $3D</td><td rowspan="2"><p>Load .x with drive number and .A with
the job code.</p>
</td></tr>
				<tr><td></td><td class="fit">F361</td>
				<td>A5 45</td>
				<td class="fit">LDA $45</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F363</td>
				<td>C9 40</td>
				<td class="fit">CMP #$40</td><td rowspan="2"><p>Compare job code with $40. If equal,
branch to BMP to do bump job.</p>
</td></tr>
				<tr><td></td><td class="fit">F365</td>
				<td>F0 15</td>
				<td class="fit">BEQ $F37C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">EXE</td><td class="fit">F367</td>
				<td>C9 60</td>
				<td class="fit">CMP #$60</td><td rowspan="2"><p>Compare job code with $60. If equal,
branch to EX to do execute job.</p>
</td></tr>
				<tr><td></td><td class="fit">F369</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F36E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F36B</td>
				<td>4C B1 F3</td>
				<td class="fit">JMP $F3B1</td><td rowspan="6"><p>Not Bump or Execute, JMP to SEAK ($F3B1)</p>
</td></tr>
				<tr><td></td><td class="fit">F36E</td>
				<td>A5 3F</td>
				<td class="fit">LDA $3F</td></tr>
				<tr><td></td><td class="fit">F370</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">F371</td>
				<td>69 03</td>
				<td class="fit">ADC #$03</td></tr>
				<tr><td></td><td class="fit">F373</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F375</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Do an execute job</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">EX</td><td class="fit">F377</td>
				<td>85 30</td>
				<td class="fit">STA $30</td><td rowspan="1"><p>Set pointer to buffer in BUFPNT ($30/1)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F379</td>
				<td>6C 30 00</td>
				<td class="fit">JMP ($0030)</td><td rowspan="1"><p>Do indirect JMP via BUFPNT to the code
that starts at the start of the buffer.
Do a bump to track #1</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BMP</td><td class="fit">F37C</td>
				<td>A9 60</td>
				<td class="fit">LDA #$60</td><td rowspan="2"><p>Store $60 as the drive status, DRVST
(20) to indicate head is stepping.</p>
</td></tr>
				<tr><td></td><td class="fit">F37E</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F380</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="3"><p>Set track phase to phase A</p>
</td></tr>
				<tr><td></td><td class="fit">F383</td>
				<td>29 FC</td>
				<td class="fit">AND #$FC</td></tr>
				<tr><td></td><td class="fit">F385</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F388</td>
				<td>A9 A4</td>
				<td class="fit">LDA #$A4</td><td rowspan="2"><p>Store -45 ($A4) as the number of tracks
to move head in STEPS ($4A) .</p>
</td></tr>
				<tr><td></td><td class="fit">F38A</td>
				<td>85 4A</td>
				<td class="fit">STA $4A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F38C</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="2"><p>Set DRVTRK ($22) to 1 as new track#</p>
</td></tr>
				<tr><td></td><td class="fit">F38E</td>
				<td>85 22</td>
				<td class="fit">STA $22</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F390</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td><td rowspan="1"><p>Job done so JMP to ERRR ($F969).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETJB</td><td class="fit">F393</td>
				<td>A4 3F</td>
				<td class="fit">LDY $3F</td><td rowspan="18"><p>Sub to set pointer to buffer, BUFPNT
($30/31) and into header table, HDRPNT
($32) for this position in job queue.</p>
</td></tr>
				<tr><td></td><td class="fit">F395</td>
				<td>B9 00 00</td>
				<td class="fit">LDA $0000,Y</td></tr>
				<tr><td></td><td class="fit">F398</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">F399</td>
				<td>10 10</td>
				<td class="fit">BPL $F3AB</td></tr>
				<tr><td></td><td class="fit">F39B</td>
				<td>29 78</td>
				<td class="fit">AND #$78</td></tr>
				<tr><td></td><td class="fit">F39D</td>
				<td>85 45</td>
				<td class="fit">STA $45</td></tr>
				<tr><td></td><td class="fit">F39F</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">F3A0</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F3A1</td>
				<td>69 06</td>
				<td class="fit">ADC #$06</td></tr>
				<tr><td></td><td class="fit">F3A3</td>
				<td>85 32</td>
				<td class="fit">STA $32</td></tr>
				<tr><td></td><td class="fit">F3A5</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">F3A6</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">F3A7</td>
				<td>69 03</td>
				<td class="fit">ADC #$03</td></tr>
				<tr><td></td><td class="fit">F3A9</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F3AB</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">F3AD</td>
				<td>84 30</td>
				<td class="fit">STY $30</td></tr>
				<tr><td></td><td class="fit">F3AF</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">F3B0</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Search for a valid header block on this
track. Up to 90 header and data blocks
are scanned while looking for a valid
header block before this routine gives
up. A valid header block must have:</p>
<ol>
<li>
<p>a SYNC mark</p>
</li>
<li>
<p>a header block ID ($08)</p>
</li>
<li>
<p>a valid checksum (EOR of sector,
track, ID1, and ID2)</p>
</li>
<li>
<p>the sector number</p>
</li>
<li>
<p>the track number</p>
</li>
<li>
<p>the second disk ID character given
when the disk was formatted</p>
</li>
<li>
<p>the first disk ID character given
when the disk was formatted</p>
<p>Note: The actual order of these bytes
is as given above. Not as listed
in the 1541 manual!</p>
</li>
</ol>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SEAK</td><td class="fit">F3B1</td>
				<td>A2 5A</td>
				<td class="fit">LDX #$5A</td><td rowspan="3"><p>Store $5A (90) in TMP ($4B) as the sync
mark counter (quit if counts down to 0)</p>
</td></tr>
				<tr><td></td><td class="fit">F3B3</td>
				<td>86 4B</td>
				<td class="fit">STX $4B</td></tr>
				<tr><td></td><td class="fit">F3B5</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3B7</td>
				<td>A9 52</td>
				<td class="fit">LDA #$52</td><td rowspan="2"><p>Store $52 into STAB ($24) as the header
block ID code to wait for (GCR for $08).</p>
</td></tr>
				<tr><td></td><td class="fit">F3B9</td>
				<td>85 24</td>
				<td class="fit">STA $24</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3BB</td>
				<td>20 56 F5</td>
				<td class="fit">JSR $F556</td><td rowspan="1"><p>JSR to SYNC ($F556) to wait for sync</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3BE</td>
				<td>50 FE</td>
				<td class="fit">BVC $F3BE</td><td rowspan="3"><p>Read first character after sync</p>
</td></tr>
				<tr><td></td><td class="fit">F3C0</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F3C1</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3C4</td>
				<td>C5 24</td>
				<td class="fit">CMP $24</td><td rowspan="1"><p>Compare it to character in STAB ($24)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3C6</td>
				<td>D0 3F</td>
				<td class="fit">BNE $F407</td><td rowspan="1"><p>If no match, this is not a header block
so branch to SEEK20.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SEEK15</td><td class="fit">F3C8</td>
				<td>50 FE</td>
				<td class="fit">BVC $F3C8</td><td rowspan="7"><p>Loop to read in the next 7 characters
and store in STAB+1,X ($25, X).</p>
</td></tr>
				<tr><td></td><td class="fit">F3CA</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F3CB</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
				<tr><td></td><td class="fit">F3CE</td>
				<td>95 25</td>
				<td class="fit">STA $25,X</td></tr>
				<tr><td></td><td class="fit">F3D0</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">F3D1</td>
				<td>E0 07</td>
				<td class="fit">CPX #$07</td></tr>
				<tr><td></td><td class="fit">F3D3</td>
				<td>D0 F3</td>
				<td class="fit">BNE $F3C8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3D5</td>
				<td>20 97 F4</td>
				<td class="fit">JSR $F497</td><td rowspan="1"><p>JSR to CNVBIN ($F497) to convert the
header bytes from GCR form to normal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SEEK30</td><td class="fit">F3D8</td>
				<td>A0 04</td>
				<td class="fit">LDY #$04</td><td rowspan="5"><p>Loop to compute checksum of header read
EOR checksum, sector, track, ID1 &amp; ID2.</p>
</td></tr>
				<tr><td></td><td class="fit">F3DA</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">F3DC</td>
				<td>59 16 00</td>
				<td class="fit">EOR $0016,Y</td></tr>
				<tr><td></td><td class="fit">F3DF</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">F3E0</td>
				<td>10 FA</td>
				<td class="fit">BPL $F3DC</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3E2</td>
				<td>C9 00</td>
				<td class="fit">CMP #$00</td><td rowspan="2"><p>If computed checksum is not 0, branch
to CSERR ($F41E) to report error.</p>
</td></tr>
				<tr><td></td><td class="fit">F3E4</td>
				<td>D0 38</td>
				<td class="fit">BNE $F41E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3E6</td>
				<td>A6 3E</td>
				<td class="fit">LDX $3E</td><td rowspan="3"><p>Update current track from header data</p>
</td></tr>
				<tr><td></td><td class="fit">F3E8</td>
				<td>A5 18</td>
				<td class="fit">LDA $18</td></tr>
				<tr><td></td><td class="fit">F3EA</td>
				<td>95 22</td>
				<td class="fit">STA $22,X</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3EC</td>
				<td>A5 45</td>
				<td class="fit">LDA $45</td><td rowspan="3"><p>Compare job code in JOB ($45) with $30
to see if it is a seek job. If it is,
branch to ESEEK ($F410) to do it.</p>
</td></tr>
				<tr><td></td><td class="fit">F3EE</td>
				<td>C9 30</td>
				<td class="fit">CMP #$30</td></tr>
				<tr><td></td><td class="fit">F3F0</td>
				<td>F0 1E</td>
				<td class="fit">BEQ $F410</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F3F2</td>
				<td>A5 3E</td>
				<td class="fit">LDA $3E</td><td rowspan="9"><p>Compare master disk ID in $12/13 to the
disk ID from the header in $16/17. If
they don't match, branch to BADID ($F41B)
to report a disk ID mismatch error.</p>
</td></tr>
				<tr><td></td><td class="fit">F3F4</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F3F5</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">F3F6</td>
				<td>B9 12 00</td>
				<td class="fit">LDA $0012,Y</td></tr>
				<tr><td></td><td class="fit">F3F9</td>
				<td>C5 16</td>
				<td class="fit">CMP $16</td></tr>
				<tr><td></td><td class="fit">F3FB</td>
				<td>D0 1E</td>
				<td class="fit">BNE $F41B</td></tr>
				<tr><td></td><td class="fit">F3FD</td>
				<td>B9 13 00</td>
				<td class="fit">LDA $0013,Y</td></tr>
				<tr><td></td><td class="fit">F400</td>
				<td>C5 17</td>
				<td class="fit">CMP $17</td></tr>
				<tr><td></td><td class="fit">F402</td>
				<td>D0 17</td>
				<td class="fit">BNE $F41B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F404</td>
				<td>4C 23 F4</td>
				<td class="fit">JMP $F423</td><td rowspan="1"><p>JMP to WSWCT ($F423) to find the best-
sector on this track to service (usually
the current sector + 2)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SEEK20</td><td class="fit">F407</td>
				<td>C6 4B</td>
				<td class="fit">DEC $4B</td><td rowspan="4"><p>Decrement SYNC counter in TMP($4B) by 1
to see if we should check more syncs. If
not yet, branch back to SEEK10. If 0,
load .A with a $02 (to indicate header
block not found) and JMP to ERRR ($F969)</p>
</td></tr>
				<tr><td></td><td class="fit">F409</td>
				<td>D0 B0</td>
				<td class="fit">BNE $F3BB</td></tr>
				<tr><td></td><td class="fit">F40B</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td></tr>
				<tr><td></td><td class="fit">F40D</td>
				<td>20 69 F9</td>
				<td class="fit">JSR $F969</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ESEEK</td><td class="fit">F410</td>
				<td>A5 16</td>
				<td class="fit">LDA $16</td><td rowspan="4"><p>Change master disk ID in $12/$13 to
match the ID read in from $16/17</p>
</td></tr>
				<tr><td></td><td class="fit">F412</td>
				<td>85 12</td>
				<td class="fit">STA $12</td></tr>
				<tr><td></td><td class="fit">F414</td>
				<td>A5 17</td>
				<td class="fit">LDA $17</td></tr>
				<tr><td></td><td class="fit">F416</td>
				<td>85 13</td>
				<td class="fit">STA $13</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DONE</td><td class="fit">F418</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="1"><p>Load .A with a $01 (to indicate job
completed OK) and exit to error handler</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F41A</td>
				<td>2C</td>
				<td class="fit"></td><td rowspan="1"><p>BYTE $2C to skip next instruction</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BADID</td><td class="fit">F41B</td>
				<td>A9 0B</td>
				<td class="fit">LDA #$0B</td><td rowspan="1"><p>Load .A with a $0B (to indicate disk ID
mismatch) and exit to error handler</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F41D</td>
				<td>2C</td>
				<td class="fit"></td><td rowspan="1"><p>BYTE $2C to skip next instruction</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CSERR</td><td class="fit">F41E</td>
				<td>A9 09</td>
				<td class="fit">LDA #$09</td><td rowspan="2"><p>Load .A with a $09 (to indicate a bad
checksum) and exit to error handler</p>
</td></tr>
				<tr><td></td><td class="fit">F420</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WSECT</td><td class="fit">F423</td>
				<td>A9 7F</td>
				<td class="fit">LDA #$7F</td><td rowspan="2"><p>Determine best sector on this track to
service (optimum is current sector + 2)
Store $7F as the current sector in $4C</p>
</td></tr>
				<tr><td></td><td class="fit">F425</td>
				<td>85 4C</td>
				<td class="fit">STA $4C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F427</td>
				<td>A5 19</td>
				<td class="fit">LDA $19</td><td rowspan="1"><p>Load .A with the sector number from the
header just read from HEADER+3 ($19).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F429</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Add 2</p>
</td></tr>
				<tr><td></td><td class="fit">F42A</td>
				<td>69 02</td>
				<td class="fit">ADC #$02</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F42C</td>
				<td>C5 43</td>
				<td class="fit">CMP $43</td><td rowspan="3"><p>Compare sum to the number of sectors on
this track in SECTR ($43). If sum is too
big, subtract the number of sectors.</p>
</td></tr>
				<tr><td></td><td class="fit">F42E</td>
				<td>90 02</td>
				<td class="fit">BCC $F432</td></tr>
				<tr><td></td><td class="fit">F430</td>
				<td>E5 43</td>
				<td class="fit">SBC $43</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L460</td><td class="fit">F432</td>
				<td>85 4D</td>
				<td class="fit">STA $4D</td><td rowspan="4"><p>Store sum as next sector to be serviced
in NEXTS ($4D) .</p>
</td></tr>
				<tr><td></td><td class="fit">F434</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td></tr>
				<tr><td></td><td class="fit">F436</td>
				<td>86 3F</td>
				<td class="fit">STX $3F</td></tr>
				<tr><td></td><td class="fit">F438</td>
				<td>A2 FF</td>
				<td class="fit">LDX #$FF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L480</td><td class="fit">F43A</td>
				<td>20 93 F3</td>
				<td class="fit">JSR $F393</td><td rowspan="4"><p>JSR to SETJB ($F393) to set pointers.</p>
</td></tr>
				<tr><td></td><td class="fit">F43D</td>
				<td>10 44</td>
				<td class="fit">BPL $F483</td></tr>
				<tr><td></td><td class="fit">F43F</td>
				<td>85 44</td>
				<td class="fit">STA $44</td></tr>
				<tr><td></td><td class="fit">F441</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F443</td>
				<td>C5 3E</td>
				<td class="fit">CMP $3E</td><td rowspan="2"><p>Check to be sure job is for this drive.
If not, branch to L470 ($F483).</p>
</td></tr>
				<tr><td></td><td class="fit">F445</td>
				<td>D0 3C</td>
				<td class="fit">BNE $F483</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F447</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="4"><p>Check to be sure job is for this track.
If not, branch to L470 ($F483).</p>
</td></tr>
				<tr><td></td><td class="fit">F449</td>
				<td>B1 32</td>
				<td class="fit">LDA ($32),Y</td></tr>
				<tr><td></td><td class="fit">F44B</td>
				<td>C5 40</td>
				<td class="fit">CMP $40</td></tr>
				<tr><td></td><td class="fit">F44D</td>
				<td>D0 34</td>
				<td class="fit">BNE $F483</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F44F</td>
				<td>A5 45</td>
				<td class="fit">LDA $45</td><td rowspan="3"><p>Compare job code in JOB ($45) with $60
to see if it is an execute job. If it-
is, branch to L465.</p>
</td></tr>
				<tr><td></td><td class="fit">F451</td>
				<td>C9 60</td>
				<td class="fit">CMP #$60</td></tr>
				<tr><td></td><td class="fit">F453</td>
				<td>F0 0C</td>
				<td class="fit">BEQ $F461</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F455</td>
				<td>A0 01</td>
				<td class="fit">LDY #$01</td><td rowspan="5"><p>Load .A with job's sector, (HDRPNT) ,Y
and subtract the upcoming sector from
NEXTS ($4D). If result is positive,
branch to L465 since sector coming up.</p>
</td></tr>
				<tr><td></td><td class="fit">F457</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">F458</td>
				<td>B1 32</td>
				<td class="fit">LDA ($32),Y</td></tr>
				<tr><td></td><td class="fit">F45A</td>
				<td>E5 4D</td>
				<td class="fit">SBC $4D</td></tr>
				<tr><td></td><td class="fit">F45C</td>
				<td>10 03</td>
				<td class="fit">BPL $F461</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F45E</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="2"><p>Add value from NEXTS ($4D) back in.</p>
</td></tr>
				<tr><td></td><td class="fit">F45F</td>
				<td>65 43</td>
				<td class="fit">ADC $43</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L465</td><td class="fit">F461</td>
				<td>C5 4C</td>
				<td class="fit">CMP $4C</td><td rowspan="2"><p>Compare to distance to other sector
request. If further away, branch to L470
since other job is closer.</p>
</td></tr>
				<tr><td></td><td class="fit">F463</td>
				<td>B0 1E</td>
				<td class="fit">BCS $F483</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F465</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="3"><p>Save distance to sector on the stack.
Check job code in JOB ($45). If a read
job, branch to TSTRDJ.</p>
</td></tr>
				<tr><td></td><td class="fit">F466</td>
				<td>A5 45</td>
				<td class="fit">LDA $45</td></tr>
				<tr><td></td><td class="fit">F468</td>
				<td>F0 14</td>
				<td class="fit">BEQ $F47E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F46A</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="5"><p>This is a write job. Pull distance to
sector off the stack. Since a write job
requires set up time, if sector is less
than 9 ahead or more than 12 ahead, we
are better off doing another job so
branch to L470.</p>
</td></tr>
				<tr><td></td><td class="fit">F46B</td>
				<td>C9 09</td>
				<td class="fit">CMP #$09</td></tr>
				<tr><td></td><td class="fit">F46D</td>
				<td>90 14</td>
				<td class="fit">BCC $F483</td></tr>
				<tr><td></td><td class="fit">F46F</td>
				<td>C9 0C</td>
				<td class="fit">CMP #$0C</td></tr>
				<tr><td></td><td class="fit">F471</td>
				<td>B0 10</td>
				<td class="fit">BCS $F483</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOITT</td><td class="fit">F473</td>
				<td>85 4C</td>
				<td class="fit">STA $4C</td><td rowspan="6"><p>This job is closer than others so set up
by storing distance in CSECT ($4C) and
setting BUFPNT to point to the buffer.
Branch always to L470</p>
</td></tr>
				<tr><td></td><td class="fit">F475</td>
				<td>A5 3F</td>
				<td class="fit">LDA $3F</td></tr>
				<tr><td></td><td class="fit">F477</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F478</td>
				<td>69 03</td>
				<td class="fit">ADC #$03</td></tr>
				<tr><td></td><td class="fit">F47A</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F47C</td>
				<td>D0 05</td>
				<td class="fit">BNE $F483</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTRDJ</td><td class="fit">F47E</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="3"><p>This is a read job. Pull distance to
sector off the stack. Since a read job
doesn't need much set up time, if sector
is less than 6 ahead, we better do it
so branch to DOITT.</p>
</td></tr>
				<tr><td></td><td class="fit">F47F</td>
				<td>C9 06</td>
				<td class="fit">CMP #$06</td></tr>
				<tr><td></td><td class="fit">F481</td>
				<td>90 F0</td>
				<td class="fit">BCC $F473</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L470</td><td class="fit">F483</td>
				<td>C6 3F</td>
				<td class="fit">DEC $3F</td><td rowspan="2"><p>Decrement queue position in JOBN ($3F)
by 1. If more to check branch to L480.</p>
</td></tr>
				<tr><td></td><td class="fit">F485</td>
				<td>10 B3</td>
				<td class="fit">BPL $F43A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F487</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="7"><p>No more to check. Test if any jobs were
found. If none, JMP to END ($F99C). If
yes, set up job and JMP to REED ($F4CA)</p>
</td></tr>
				<tr><td></td><td class="fit">F488</td>
				<td>10 03</td>
				<td class="fit">BPL $F48D</td></tr>
				<tr><td></td><td class="fit">F48A</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
				<tr><td></td><td class="fit">F48D</td>
				<td>86 3F</td>
				<td class="fit">STX $3F</td></tr>
				<tr><td></td><td class="fit">F48F</td>
				<td>20 93 F3</td>
				<td class="fit">JSR $F393</td></tr>
				<tr><td></td><td class="fit">F492</td>
				<td>A5 45</td>
				<td class="fit">LDA $45</td></tr>
				<tr><td></td><td class="fit">F494</td>
				<td>4C CA F4</td>
				<td class="fit">JMP $F4CA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CNVRTN</td><td class="fit">F497</td>
				<td>A5 30</td>
				<td class="fit">LDA $30</td><td rowspan="27"><p>Convert GCR image of header into the
normal 8 bit binary and move the values
into $16/7/8/9/A.
The characters decoded include:</p>
<p>-Header block ID code (usually $08)
-Hdr block checksum (EOR of T/S/ID1/ID2)
-Sector number
-Track number
-ID2 (2nd ID chr given when formatted)
-ID1 (1st ID chr given when formatted)
-The remaining characters are junk!</p>
</td></tr>
				<tr><td></td><td class="fit">F499</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">F49A</td>
				<td>A5 31</td>
				<td class="fit">LDA $31</td></tr>
				<tr><td></td><td class="fit">F49C</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">F49D</td>
				<td>A9 24</td>
				<td class="fit">LDA #$24</td></tr>
				<tr><td></td><td class="fit">F49F</td>
				<td>85 30</td>
				<td class="fit">STA $30</td></tr>
				<tr><td></td><td class="fit">F4A1</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">F4A3</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F4A5</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">F4A7</td>
				<td>85 34</td>
				<td class="fit">STA $34</td></tr>
				<tr><td></td><td class="fit">F4A9</td>
				<td>20 E6 F7</td>
				<td class="fit">JSR $F7E6</td></tr>
				<tr><td></td><td class="fit">F4AC</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td></tr>
				<tr><td></td><td class="fit">F4AE</td>
				<td>85 18</td>
				<td class="fit">STA $18</td></tr>
				<tr><td></td><td class="fit">F4B0</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td></tr>
				<tr><td></td><td class="fit">F4B2</td>
				<td>85 19</td>
				<td class="fit">STA $19</td></tr>
				<tr><td></td><td class="fit">F4B4</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td></tr>
				<tr><td></td><td class="fit">F4B6</td>
				<td>85 1A</td>
				<td class="fit">STA $1A</td></tr>
				<tr><td></td><td class="fit">F4B8</td>
				<td>20 E6 F7</td>
				<td class="fit">JSR $F7E6</td></tr>
				<tr><td></td><td class="fit">F4BB</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td></tr>
				<tr><td></td><td class="fit">F4BD</td>
				<td>85 17</td>
				<td class="fit">STA $17</td></tr>
				<tr><td></td><td class="fit">F4BF</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td></tr>
				<tr><td></td><td class="fit">F4C1</td>
				<td>85 16</td>
				<td class="fit">STA $16</td></tr>
				<tr><td></td><td class="fit">F4C3</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">F4C4</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F4C6</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">F4C7</td>
				<td>85 30</td>
				<td class="fit">STA $30</td></tr>
				<tr><td></td><td class="fit">F4C9</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">REED</td><td class="fit">F4CA</td>
				<td>C9 00</td>
				<td class="fit">CMP #$00</td><td rowspan="3"><p>Read in the track and sector that is
specified in the header table
Check if this is a read job. If not,
JMP to WRIGHT ($F4CE)</p>
</td></tr>
				<tr><td></td><td class="fit">F4CC</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F4D1</td></tr>
				<tr><td></td><td class="fit">F4CE</td>
				<td>4C 6E F5</td>
				<td class="fit">JMP $F56E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">READ01</td><td class="fit">F4D1</td>
				<td>20 0A F5</td>
				<td class="fit">JSR $F50A</td><td rowspan="1"><p>JSR to DSTRT ($F50A) find header and set
up to the start of the data block</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">READ11</td><td class="fit">F4D4</td>
				<td>50 FE</td>
				<td class="fit">BVC $F4D4</td><td rowspan="6"><p>Loop to read first 256 data bytes and
store them in the data buffer .</p>
</td></tr>
				<tr><td></td><td class="fit">F4D6</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F4D7</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
				<tr><td></td><td class="fit">F4DA</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F4DC</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F4DD</td>
				<td>D0 F5</td>
				<td class="fit">BNE $F4D4</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">READ20</td><td class="fit">F4DF</td>
				<td>A0 BA</td>
				<td class="fit">LDY #$BA</td><td rowspan="7"><p>Loop to read the last 7 data bytes and
store them in the overflow buffer from
$01BA to $01FF.</p>
</td></tr>
				<tr><td></td><td class="fit">F4E1</td>
				<td>50 FE</td>
				<td class="fit">BVC $F4E1</td></tr>
				<tr><td></td><td class="fit">F4E3</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F4E4</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
				<tr><td></td><td class="fit">F4E7</td>
				<td>99 00 01</td>
				<td class="fit">STA $0100,Y</td></tr>
				<tr><td></td><td class="fit">F4EA</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F4EB</td>
				<td>D0 F4</td>
				<td class="fit">BNE $F4E1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F4ED</td>
				<td>20 E0 F8</td>
				<td class="fit">JSR $F8E0</td><td rowspan="1"><p>JSR to GCRBIN ($F8E0) to convert the 326
GCR data bytes into 256 normal bytes</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F4F0</td>
				<td>A5 38</td>
				<td class="fit">LDA $38</td><td rowspan="2"><p>Compare the first byte in the data block
from BID ($38) with the header block ID
character (normally $07) in HDIB ($47)
to check if this is a legal data block.</p>
</td></tr>
				<tr><td></td><td class="fit">F4F2</td>
				<td>C5 47</td>
				<td class="fit">CMP $47</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F4F4</td>
				<td>F0 05</td>
				<td class="fit">BEQ $F4FB</td><td rowspan="1"><p>If they match, branch to READ28.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F4F6</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td><td rowspan="2"><p>No match, so load .A with a 4 to flag a
DATA BLOCK NOT FOUND error and JMP to
ERRR ($F969).</p>
</td></tr>
				<tr><td></td><td class="fit">F4F8</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">READ28</td><td class="fit">F4FB</td>
				<td>20 E9 F5</td>
				<td class="fit">JSR $F5E9</td><td rowspan="1"><p>JSR to CHKBLK ($F5E9) to compute the
checksum for the data block by EORing
all the 256 data bytes.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F4FE</td>
				<td>C5 3A</td>
				<td class="fit">CMP $3A</td><td rowspan="2"><p>Compare the computed checksum in .A with
with the checksum read from the disk in
CHKSUM ($3A). If equal, branch to READ40</p>
</td></tr>
				<tr><td></td><td class="fit">F500</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F505</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F502</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td><td rowspan="1"><p>No match, so load .A with a 5 to flag a
DATA BLOCK CHECKSUM error</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F504</td>
				<td>2C</td>
				<td class="fit"></td><td rowspan="1"><p>Byte $2C to skip over next LDA</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F505</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="1"><p>Load .A with a 1 to indicate a good read</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F507</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td><td rowspan="1"><p>JMP to ERRR ($F969)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DSTRT</td><td class="fit">F50A</td>
				<td>20 10 F5</td>
				<td class="fit">JSR $F510</td><td rowspan="2"><p>JSR to SRCH ($F510)  to find the desired
header block.
JMP to SYNC ($F556) to wait for the
data block sync character .</p>
</td></tr>
				<tr><td></td><td class="fit">F50D</td>
				<td>4C 56 F5</td>
				<td class="fit">JMP $F556</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SRCH</td><td class="fit">F510</td>
				<td>A5 3D</td>
				<td class="fit">LDA $3D</td><td rowspan="14"><p>Find a specific header. The track and
sector desired must be stored in the
header table
Use values from the header table and
the master disk ID ($12/3) to set up an
image of the desired header $16-$19</p>
</td></tr>
				<tr><td></td><td class="fit">F512</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F513</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F514</td>
				<td>B5 12</td>
				<td class="fit">LDA $12,X</td></tr>
				<tr><td></td><td class="fit">F516</td>
				<td>85 16</td>
				<td class="fit">STA $16</td></tr>
				<tr><td></td><td class="fit">F518</td>
				<td>B5 13</td>
				<td class="fit">LDA $13,X</td></tr>
				<tr><td></td><td class="fit">F51A</td>
				<td>85 17</td>
				<td class="fit">STA $17</td></tr>
				<tr><td></td><td class="fit">F51C</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">F51E</td>
				<td>B1 32</td>
				<td class="fit">LDA ($32),Y</td></tr>
				<tr><td></td><td class="fit">F520</td>
				<td>85 18</td>
				<td class="fit">STA $18</td></tr>
				<tr><td></td><td class="fit">F522</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F523</td>
				<td>B1 32</td>
				<td class="fit">LDA ($32),Y</td></tr>
				<tr><td></td><td class="fit">F525</td>
				<td>85 19</td>
				<td class="fit">STA $19</td></tr>
				<tr><td></td><td class="fit">F527</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F529</td>
				<td>45 16</td>
				<td class="fit">EOR $16</td><td rowspan="5"><p>EOR the track, sector, and ID characters
to calculate the header checksum and
store it in $1A.</p>
</td></tr>
				<tr><td></td><td class="fit">F52B</td>
				<td>45 17</td>
				<td class="fit">EOR $17</td></tr>
				<tr><td></td><td class="fit">F52D</td>
				<td>45 18</td>
				<td class="fit">EOR $18</td></tr>
				<tr><td></td><td class="fit">F52F</td>
				<td>45 19</td>
				<td class="fit">EOR $19</td></tr>
				<tr><td></td><td class="fit">F531</td>
				<td>85 1A</td>
				<td class="fit">STA $1A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F533</td>
				<td>20 34 F9</td>
				<td class="fit">JSR $F934</td><td rowspan="1"><p>JSR to CONHDR ($F934) to convert the
header image into its GCR image.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F536</td>
				<td>A2 5A</td>
				<td class="fit">LDX #$5A</td><td rowspan="1"><p>Load .X with $5A as a counter of the
number of sync marks checked.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SRCH20</td><td class="fit">F538</td>
				<td>20 56 F5</td>
				<td class="fit">JSR $F556</td><td rowspan="2"><p>JSR to SYNC ($F556) to wait for the
next sync mark.</p>
</td></tr>
				<tr><td></td><td class="fit">F53B</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SRCH25</td><td class="fit">F53D</td>
				<td>50 FE</td>
				<td class="fit">BVC $F53D</td><td rowspan="8"><p>Loop to scan the 8 bytes following the
sync mark to attempt to find a match to
the GCR image of the desired header. If
any character does not match the image,
branch to SRCH30.</p>
</td></tr>
				<tr><td></td><td class="fit">F53F</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F540</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
				<tr><td></td><td class="fit">F543</td>
				<td>D9 24 00</td>
				<td class="fit">CMP $0024,Y</td></tr>
				<tr><td></td><td class="fit">F546</td>
				<td>D0 06</td>
				<td class="fit">BNE $F54E</td></tr>
				<tr><td></td><td class="fit">F548</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F549</td>
				<td>C0 08</td>
				<td class="fit">CPY #$08</td></tr>
				<tr><td></td><td class="fit">F54B</td>
				<td>D0 F0</td>
				<td class="fit">BNE $F53D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F54D</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>All characters match so exit with an RTS</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SRCH30</td><td class="fit">F54E</td>
				<td>CA</td>
				<td class="fit">DEX</td><td rowspan="2"><p>Decrement, the sync mark counter in .X
If counter is not yet, branch back to
SRCH20 to wait for next sync.</p>
</td></tr>
				<tr><td></td><td class="fit">F54F</td>
				<td>D0 E7</td>
				<td class="fit">BNE $F538</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F551</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td><td rowspan="1"><p>No match, so load .A with a 2 to flag a
BLOCK HEADER NOT FOUND error.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERR</td><td class="fit">F553</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td><td rowspan="1"><p>JMP to ERRR ($F969) .</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Wait for SYNC mark</h1>
<p>A SYNC mark is 10 or more consecutive
l's bits written onto the disk. It is
used to identify the start of a block
of information recorded on disk.</p>
<p>The first character following a SYNC mark
is used to determine whether this is
a header block ($08) or a data block
($07).</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SYNC</td><td class="fit">F556</td>
				<td>A9 D0</td>
				<td class="fit">LDA #$D0</td><td rowspan="2"><p>Store $D0 in TIMER1 ($1805) to allow a
maximum wait of 20 milliseconds for a
sync before timing out.</p>
</td></tr>
				<tr><td></td><td class="fit">F558</td>
				<td>8D 05 18</td>
				<td class="fit">STA $1805</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F55B</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td><td rowspan="1"><p>Load .A with $03 (the error code for a
NO SYNC FOUND error)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SYNC10</td><td class="fit">F55D</td>
				<td>2C 05 18</td>
				<td class="fit">BIT $1805</td><td rowspan="2"><p>Test bit 7 of TIMER1 ($1805) to check
for a time-out. If time is up, branch
to ERR ($F553) to exit.</p>
</td></tr>
				<tr><td></td><td class="fit">F560</td>
				<td>10 F1</td>
				<td class="fit">BPL $F553</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F562</td>
				<td>2C 00 1C</td>
				<td class="fit">BIT $1C00</td><td rowspan="2"><p>Test bit 7 of DSKCNT ($1C00) to check
for a sync. If no sync, branch back to
SYNC 10 to wait some more.</p>
</td></tr>
				<tr><td></td><td class="fit">F565</td>
				<td>30 F6</td>
				<td class="fit">BMI $F55D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F567</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td><td rowspan="4"><p>Load .A from DATA2 to reset the PA latch
clear the 6502' s overflow flag, and RTS</p>
</td></tr>
				<tr><td></td><td class="fit">F56A</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F56B</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">F56D</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRIGHT</td><td class="fit">F56E</td>
				<td>C9 10</td>
				<td class="fit">CMP #$10</td><td rowspan="3"><p>Write contents of data buffer to disk
Compare job code in .A with $10 to check
if this is write job. If not, JMP to
VERIFY ($F691) .</p>
</td></tr>
				<tr><td></td><td class="fit">F570</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F575</td></tr>
				<tr><td></td><td class="fit">F572</td>
				<td>4C 91 F6</td>
				<td class="fit">JMP $F691</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F575</td>
				<td>20 E9 F5</td>
				<td class="fit">JSR $F5E9</td><td rowspan="2"><p>JSR to CHKBLK ($F5E9) to compute the
checksum for the data block. Store the
checksum in CHKSUM ($3A) .</p>
</td></tr>
				<tr><td></td><td class="fit">F578</td>
				<td>85 3A</td>
				<td class="fit">STA $3A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F57A</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="5"><p>Load .A from DSKCNT and AND it with $10
to check for write protect tab. If the
result is not $00, OK to write so branch
to WRT10.
Load .A with $08 to flag a WRITE PROTECT
error and JMP to ERRR ($F969)</p>
</td></tr>
				<tr><td></td><td class="fit">F57D</td>
				<td>29 10</td>
				<td class="fit">AND #$10</td></tr>
				<tr><td></td><td class="fit">F57F</td>
				<td>D0 05</td>
				<td class="fit">BNE $F586</td></tr>
				<tr><td></td><td class="fit">F581</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td></tr>
				<tr><td></td><td class="fit">F583</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRT10</td><td class="fit">F586</td>
				<td>20 8F F7</td>
				<td class="fit">JSR $F78F</td><td rowspan="1"><p>JSR to BINGCR ($F78F) to convert data
in the buffer into GCR form.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F589</td>
				<td>20 10 F5</td>
				<td class="fit">JSR $F510</td><td rowspan="1"><p>JSR to SRCH ($F510) to find the correct-
header block</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F58C</td>
				<td>A2 08</td>
				<td class="fit">LDX #$08</td><td rowspan="5"><p>Wait for 8 more bytes to go by. This is
the header gap.
NOTE: The header gap on the 1541 is 8
bytes long. The gap on the 4040 is 9
bytes long. This is the main reason why
the drives are write incompatible!</p>
</td></tr>
				<tr><td></td><td class="fit">F58E</td>
				<td>50 FE</td>
				<td class="fit">BVC $F58E</td></tr>
				<tr><td></td><td class="fit">F590</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F591</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">F592</td>
				<td>D0 FA</td>
				<td class="fit">BNE $F58E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F594</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF in DDRA2 ($1C03) to make Port
A an output port-</p>
</td></tr>
				<tr><td></td><td class="fit">F596</td>
				<td>8D 03 1C</td>
				<td class="fit">STA $1C03</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F599</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td><td rowspan="4"><p>Load .A from PCR2 ($1C0C). AND the value
with $1F, OR it with $C0, and store the
result in PCR2 to turn on write mode.</p>
</td></tr>
				<tr><td></td><td class="fit">F59C</td>
				<td>29 1F</td>
				<td class="fit">AND #$1F</td></tr>
				<tr><td></td><td class="fit">F59E</td>
				<td>09 C0</td>
				<td class="fit">ORA #$C0</td></tr>
				<tr><td></td><td class="fit">F5A0</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5A3</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="4"><p>Store $FF in DATA2 ($1C01) as the SYNC
mark character</p>
</td></tr>
				<tr><td></td><td class="fit">F5A5</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td></tr>
				<tr><td></td><td class="fit">F5A7</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">F5AA</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTSNC</td><td class="fit">F5AB</td>
				<td>50 FE</td>
				<td class="fit">BVC $F5AB</td><td rowspan="4"><p>Loop to write out 5 consecutive $FF
bytes (5x8 =40 1's) .</p>
</td></tr>
				<tr><td></td><td class="fit">F5AD</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F5AE</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">F5AF</td>
				<td>D0 FA</td>
				<td class="fit">BNE $F5AB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5B1</td>
				<td>A0 BB</td>
				<td class="fit">LDY #$BB</td><td rowspan="1"><p>Load .Y with $BB to point into the
overflow buffer ($01BB-01FF) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRT30</td><td class="fit">F5B3</td>
				<td>B9 00 01</td>
				<td class="fit">LDA $0100,Y</td><td rowspan="6"><p>Load .A with byte from overflow buffer,
wait till last byte is out, store new
byte into DATA2 ($1C01). increment .Y
pointer, and if more characters to do,
branch back to WRT30.</p>
</td></tr>
				<tr><td></td><td class="fit">F5B6</td>
				<td>50 FE</td>
				<td class="fit">BVC $F5B6</td></tr>
				<tr><td></td><td class="fit">F5B8</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F5B9</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">F5BC</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F5BD</td>
				<td>D0 F4</td>
				<td class="fit">BNE $F5B3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRT40</td><td class="fit">F5BF</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="6"><p>Load .A with byte from data buffer,
wait till last byte is out, store new
byte into DATA2 ($1C01), increment .Y
pointer, and if more characters to do,
branch back to WRT40.</p>
</td></tr>
				<tr><td></td><td class="fit">F5C1</td>
				<td>50 FE</td>
				<td class="fit">BVC $F5C1</td></tr>
				<tr><td></td><td class="fit">F5C3</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F5C4</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">F5C7</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F5C8</td>
				<td>D0 F5</td>
				<td class="fit">BNE $F5BF</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5CA</td>
				<td>50 FE</td>
				<td class="fit">BVC $F5CA</td><td rowspan="1"><p>Wait for final byte to clear</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5CC</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td><td rowspan="3"><p>Load .A from PCR2 (S1C0C). OR the value
with $E0, and store the result back in
PCR2 to shift to read mode.</p>
</td></tr>
				<tr><td></td><td class="fit">F5CF</td>
				<td>09 E0</td>
				<td class="fit">ORA #$E0</td></tr>
				<tr><td></td><td class="fit">F5D1</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5D4</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Store $00 in data direction register
DDRA2 to make port A an input port.</p>
</td></tr>
				<tr><td></td><td class="fit">F5D6</td>
				<td>8D 03 1C</td>
				<td class="fit">STA $1C03</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5D9</td>
				<td>20 F2 F5</td>
				<td class="fit">JSR $F5F2</td><td rowspan="1"><p>JSR to WTOBIN ($F5F2) to convert GCR
data in buffer back into its normal 8
bit form to prepare to verify it.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5DC</td>
				<td>A4 3F</td>
				<td class="fit">LDY $3F</td><td rowspan="4"><p>Convert the write job number in the job
queue into a verify job.</p>
</td></tr>
				<tr><td></td><td class="fit">F5DE</td>
				<td>B9 00 00</td>
				<td class="fit">LDA $0000,Y</td></tr>
				<tr><td></td><td class="fit">F5E1</td>
				<td>49 30</td>
				<td class="fit">EOR #$30</td></tr>
				<tr><td></td><td class="fit">F5E3</td>
				<td>99 00 00</td>
				<td class="fit">STA $0000,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5E6</td>
				<td>4C B1 F3</td>
				<td class="fit">JMP $F3B1</td><td rowspan="1"><p>JMP to SEAK ($F3B1) to scan the queue
for the next job.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Calculate data block checksum</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CHKBLK</td><td class="fit">F5E9</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="6"><p>EOR the 256 data bytes. Return with the
checksum in .A</p>
</td></tr>
				<tr><td></td><td class="fit">F5EB</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">F5EC</td>
				<td>51 30</td>
				<td class="fit">EOR ($30),Y</td></tr>
				<tr><td></td><td class="fit">F5EE</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F5EF</td>
				<td>D0 FB</td>
				<td class="fit">BNE $F5EC</td></tr>
				<tr><td></td><td class="fit">F5F1</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert the 10 bit image of the data to normal 8 bit binary.</h1>
<p>Since 5 encoded
bytes (40 bits) are converted into 4
normal bytes (32 bits), the encoded
form of 256 data bytes takes up 320
bytes. At the start of this routine
the first 64 encoded bvtes that were
read are stored in the overflow buffer
($01BA-FF) and the remaining 256 bytes
are in the normal data buffer. At the
end of the routine the decoded bytes
are stored in the normal data buffer.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WTOBIN</td><td class="fit">F5F2</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="6"><p>Set up pointers to the buffers</p>
</td></tr>
				<tr><td></td><td class="fit">F5F4</td>
				<td>85 2E</td>
				<td class="fit">STA $2E</td></tr>
				<tr><td></td><td class="fit">F5F6</td>
				<td>85 30</td>
				<td class="fit">STA $30</td></tr>
				<tr><td></td><td class="fit">F5F8</td>
				<td>85 4F</td>
				<td class="fit">STA $4F</td></tr>
				<tr><td></td><td class="fit">F5FA</td>
				<td>A5 31</td>
				<td class="fit">LDA $31</td></tr>
				<tr><td></td><td class="fit">F5FC</td>
				<td>85 4E</td>
				<td class="fit">STA $4E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F5FE</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="3"><p>Do the overflow buffer ($01BA-FF) first.</p>
</td></tr>
				<tr><td></td><td class="fit">F600</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F602</td>
				<td>85 2F</td>
				<td class="fit">STA $2F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F604</td>
				<td>A9 BB</td>
				<td class="fit">LDA #$BB</td><td rowspan="2"><p>Store $BB in GCRPNT ($34) so it points
to the first byte in the overflow buffer
($01BB) that is to be processed by the
routine GET4GB.</p>
</td></tr>
				<tr><td></td><td class="fit">F606</td>
				<td>85 34</td>
				<td class="fit">STA $34</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F608</td>
				<td>85 36</td>
				<td class="fit">STA $36</td><td rowspan="1"><p>Store $BB in BYTCNT ($52) so it points
to the location where the first decoded
data byte is to be stored.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F60A</td>
				<td>20 E6 F7</td>
				<td class="fit">JSR $F7E6</td><td rowspan="1"><p>JSR to GET4GB ($F7E6) to convert the
first five GCR bytes into 4 normal bytes
(the data block ID + 3 data bytes). The
decoded bytes appear in $52-5</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F60D</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td><td rowspan="2"><p>Store data block ID chr in BID ($38) .</p>
</td></tr>
				<tr><td></td><td class="fit">F60F</td>
				<td>85 38</td>
				<td class="fit">STA $38</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F611</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td><td rowspan="11"><p>Move decoded data b^tes from $53-$55 to
the buffer ($01BB-D). Note that the
decoded bytes are put back into the
overflow buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F613</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td></tr>
				<tr><td></td><td class="fit">F615</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F617</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F618</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td></tr>
				<tr><td></td><td class="fit">F61A</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F61C</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F61D</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td></tr>
				<tr><td></td><td class="fit">F61F</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F621</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F622</td>
				<td>84 36</td>
				<td class="fit">STY $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WTOB14</td><td class="fit">F624</td>
				<td>20 E6 F7</td>
				<td class="fit">JSR $F7E6</td><td rowspan="2"><p>JSR to GET4BG ($F7E6) to convert the
next 5 GCR bytes to 4 normal bytes and
store them in $52-5.</p>
</td></tr>
				<tr><td></td><td class="fit">F627</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F629</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td><td rowspan="14"><p>Move decoded data bytes from $53-$55 to
the buffer ($01BB-D). Note that the
decoded bytes are put back into the
overflow buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F62B</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F62D</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F62E</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td></tr>
				<tr><td></td><td class="fit">F630</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F632</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F633</td>
				<td>F0 0E</td>
				<td class="fit">BEQ $F643</td></tr>
				<tr><td></td><td class="fit">F635</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td></tr>
				<tr><td></td><td class="fit">F637</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F639</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F63A</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td></tr>
				<tr><td></td><td class="fit">F63C</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F63E</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F63F</td>
				<td>84 36</td>
				<td class="fit">STY $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F641</td>
				<td>D0 E1</td>
				<td class="fit">BNE $F624</td><td rowspan="1"><p>If more in overflow, branch to WT0B14</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WTOB50</td><td class="fit">F643</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td><td rowspan="7"><p>Move last two data bytes into buffer</p>
</td></tr>
				<tr><td></td><td class="fit">F645</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F647</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F648</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td></tr>
				<tr><td></td><td class="fit">F64A</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F64C</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F64D</td>
				<td>84 36</td>
				<td class="fit">STY $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WTOB53</td><td class="fit">F64F</td>
				<td>20 E6 F7</td>
				<td class="fit">JSR $F7E6</td><td rowspan="1"><p>Loop to convert the 256 bytes in data
buffer. JSR to GET4BG ($F7E6) to convert
the next 5 GCR bytes to 4 normal bytes
and store them in $52-5.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F652</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td><td rowspan="16"><p>Move decoded data bytes from $53-$55 tc
the data buffer. Note that the decoded
bytes are put back in the data buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F654</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td></tr>
				<tr><td></td><td class="fit">F656</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F658</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F659</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td></tr>
				<tr><td></td><td class="fit">F65B</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F65D</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F65E</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td></tr>
				<tr><td></td><td class="fit">F660</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F662</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F663</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td></tr>
				<tr><td></td><td class="fit">F665</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F667</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F668</td>
				<td>84 36</td>
				<td class="fit">STY $36</td></tr>
				<tr><td></td><td class="fit">F66A</td>
				<td>C0 BB</td>
				<td class="fit">CPY #$BB</td></tr>
				<tr><td></td><td class="fit">F66C</td>
				<td>90 E1</td>
				<td class="fit">BCC $F64F</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>At this point the data bytes have all
been decoded. Some bytes are in the
overflow buffer and some are in the
lower part of the data buffer. The
following routines shift the bytes in
the buffer up and then fill the lower
part of the buffer with the bytes from
the overflow buffer.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WTOB52</td><td class="fit">F66E</td>
				<td>A9 45</td>
				<td class="fit">LDA #$45</td><td rowspan="11"><p>Move decoded bytes in lower part of the
data buffer up into their proper places
in the buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F670</td>
				<td>85 2E</td>
				<td class="fit">STA $2E</td></tr>
				<tr><td></td><td class="fit">F672</td>
				<td>A5 31</td>
				<td class="fit">LDA $31</td></tr>
				<tr><td></td><td class="fit">F674</td>
				<td>85 2F</td>
				<td class="fit">STA $2F</td></tr>
				<tr><td></td><td class="fit">F676</td>
				<td>A0 BA</td>
				<td class="fit">LDY #$BA</td></tr>
				<tr><td></td><td class="fit">F678</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F67A</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F67C</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">F67D</td>
				<td>D0 F9</td>
				<td class="fit">BNE $F678</td></tr>
				<tr><td></td><td class="fit">F67F</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F681</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WTOB57</td><td class="fit">F683</td>
				<td>A2 BB</td>
				<td class="fit">LDX #$BB</td><td rowspan="6"><p>Move decoded bytes from the overflow
buffer to the bottom of the data buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F685</td>
				<td>BD 00 01</td>
				<td class="fit">LDA $0100,X</td></tr>
				<tr><td></td><td class="fit">F688</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F68A</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F68B</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">F68C</td>
				<td>D0 F7</td>
				<td class="fit">BNE $F685</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F68E</td>
				<td>86 50</td>
				<td class="fit">STX $50</td><td rowspan="1"><p>Set GCRFLG ($50) to to indicate that
the data in buffer is in normal form.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F690</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>Exit with an RTS.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Verify a data block</h1>
<p>This routine converts the data in the
data buffer into its 10 bit encoded
form (GCR). It then compares the GCR
image with what is recorded on the
disk. The encoded data is then changed
back into normal 8 bit binary form.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VRFY</td><td class="fit">F691</td>
				<td>C9 20</td>
				<td class="fit">CMP #$20</td><td rowspan="3"><p>Compare job code in .A with $20 to check
that this is a verify job. If not, JMP
to SECTSK (F6CA) to do a sector seek.</p>
</td></tr>
				<tr><td></td><td class="fit">F693</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F698</td></tr>
				<tr><td></td><td class="fit">F695</td>
				<td>4C CA F6</td>
				<td class="fit">JMP $F6CA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F698</td>
				<td>20 E9 F5</td>
				<td class="fit">JSR $F5E9</td><td rowspan="2"><p>JSR to CHKBLK ($F5E9) to compute the
checksum for the data block. Store the
checksum in CHKSUM ($3A).</p>
</td></tr>
				<tr><td></td><td class="fit">F69B</td>
				<td>85 3A</td>
				<td class="fit">STA $3A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F69D</td>
				<td>20 8F F7</td>
				<td class="fit">JSR $F78F</td><td rowspan="1"><p>JSR to BINGCR ($F78F) to convert the
data to its GCR image.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F6A0</td>
				<td>20 0A F5</td>
				<td class="fit">JSR $F50A</td><td rowspan="1"><p>JSR to DSTRT ($F50A) to find the right
sector and wait for data.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VRF15</td><td class="fit">F6A3</td>
				<td>A0 BB</td>
				<td class="fit">LDY #$BB</td><td rowspan="8"><p>Loop to read 64 data bytes from disk and
compare them to those in the overflow
buffer. If any bytes do not match,
branch to VRF20 to report error,</p>
</td></tr>
				<tr><td></td><td class="fit">F6A5</td>
				<td>B9 00 01</td>
				<td class="fit">LDA $0100,Y</td></tr>
				<tr><td></td><td class="fit">F6A8</td>
				<td>50 FE</td>
				<td class="fit">BVC $F6A8</td></tr>
				<tr><td></td><td class="fit">F6AA</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F6AB</td>
				<td>4D 01 1C</td>
				<td class="fit">EOR $1C01</td></tr>
				<tr><td></td><td class="fit">F6AE</td>
				<td>D0 15</td>
				<td class="fit">BNE $F6C5</td></tr>
				<tr><td></td><td class="fit">F6B0</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F6B1</td>
				<td>D0 F2</td>
				<td class="fit">BNE $F6A5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VRF30</td><td class="fit">F6B3</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="8"><p>Loop to read 254 data bytes from disk
and compare them to those in the data
buffer. If any bytes do not match,
branch to VRF20 to report error.</p>
</td></tr>
				<tr><td></td><td class="fit">F6B5</td>
				<td>50 FE</td>
				<td class="fit">BVC $F6B5</td></tr>
				<tr><td></td><td class="fit">F6B7</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">F6B8</td>
				<td>4D 01 1C</td>
				<td class="fit">EOR $1C01</td></tr>
				<tr><td></td><td class="fit">F6BB</td>
				<td>D0 08</td>
				<td class="fit">BNE $F6C5</td></tr>
				<tr><td></td><td class="fit">F6BD</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F6BE</td>
				<td>C0 FD</td>
				<td class="fit">CPY #$FD</td></tr>
				<tr><td></td><td class="fit">F6C0</td>
				<td>D0 F1</td>
				<td class="fit">BNE $F6B3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F6C2</td>
				<td>4C 18 F4</td>
				<td class="fit">JMP $F418</td><td rowspan="1"><p>All bytes match so JMP to DONE ($F418)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">VRF20</td><td class="fit">F6C5</td>
				<td>A9 07</td>
				<td class="fit">LDA #$07</td><td rowspan="2"><p>Bad byte, so load .A with $07 to flag a
WRITE-VERIFY error &amp; JMP to ERRR ($F969)</p>
</td></tr>
				<tr><td></td><td class="fit">F6C7</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SECTSK</td><td class="fit">F6CA</td>
				<td>20 10 F5</td>
				<td class="fit">JSR $F510</td><td rowspan="2"><p>JSR to SRCH to do a sector search
JMP to DONE ($F418)</p>
</td></tr>
				<tr><td></td><td class="fit">F6CD</td>
				<td>4C 18 F4</td>
				<td class="fit">JMP $F418</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert binary to GCR</h1>
<p>This routine is used to convert 4 normal
8 bit bytes into the 10 bit encoded form
used for recording onto disk. Encoding
involves breaking up each 8 bit normal
byte into two 4-bit nybbles. The 5-bit
equivalent for each nybble is found by
looking in a table. The 10 bits that
result are stored in two consecutive
memory locations. When four 8-bit bytes
are encoded, the resulting 40 bits are
stored like this:</p>
<p>Four normal 8 bit bytes stored in $52/3/4/5
AAAABBBB CCCCDDDD EEEEFFFF GGGGHHHH</p>
<p>Four 10 bit encoded bytes stored in buffer
aaaaabbb bbcccccd ddddeeee efffffgg ggghhhhh</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PUT4GB</td><td class="fit">F6D0</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Clear critical areas of the buffer where
the encoded bytes are to be stored.
GTAB to GTAB+4 ($56-5A)</p>
</td></tr>
				<tr><td></td><td class="fit">F6D2</td>
				<td>85 57</td>
				<td class="fit">STA $57</td></tr>
				<tr><td></td><td class="fit">F6D4</td>
				<td>85 5A</td>
				<td class="fit">STA $5A</td></tr>
				<tr><td></td><td class="fit">F6D6</td>
				<td>A4 34</td>
				<td class="fit">LDY $34</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F6D8</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td><td rowspan="12"><p>Load first 8-bit byte ($52). AND it with
$F0 (11110000) to mask off the low
nybble (AAAA0000), do four LSR's to
convert the hi nybble to a low nybble
(0000AAAA). look up the corresponding
five bit GCR value (OOOaaaaa) in BGTAB
BGTAB ($F77F+). do three ASL ' s on it
(aaaaaOOO). and store it in the first
position in the encoded data area ($56)</p>
</td></tr>
				<tr><td></td><td class="fit">F6DA</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">F6DC</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F6DD</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F6DE</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F6DF</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F6E0</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F6E1</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F6E4</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F6E5</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F6E6</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F6E7</td>
				<td>85 56</td>
				<td class="fit">STA $56</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F6E9</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td><td rowspan="12"><p>Load first 8-bit byte ($52), AND it with
$0F (00001111) to mask off the high
nybble (0000BBBB). find the five bit GCR
equivalent (OOObbbbb) in BGTAB ($F77F+) ,
do two ROR's on it alternated with ROR's
on $57 .A= (OOOOCbbb) $57=bb000000. AND
the value in .A with $07 (00000111). OR
the value in .A with the value in $52
(aaaaaOOO). and store the result
(aaaaabbb) in the first position of the
GCR data buffer (BUFPNT) ,Y ($30, Y).</p>
</td></tr>
				<tr><td></td><td class="fit">F6EB</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">F6ED</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F6EE</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F6F1</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">F6F2</td>
				<td>66 57</td>
				<td class="fit">ROR $57</td></tr>
				<tr><td></td><td class="fit">F6F4</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">F6F5</td>
				<td>66 57</td>
				<td class="fit">ROR $57</td></tr>
				<tr><td></td><td class="fit">F6F7</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">F6F9</td>
				<td>05 56</td>
				<td class="fit">ORA $56</td></tr>
				<tr><td></td><td class="fit">F6FB</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F6FD</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F6FE</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td><td rowspan="11"><p>Load second 8-bit byte ($53), AND it
with $F0 (11110000) to mask off the low
nybble (CCCC0000), do four LSR's to
convert the hi nybble to a low nybble
(0000CCCC). lock up the five bit GCR
equivalent (OOOccccc) in BGTAB ($F77F+) ,
do one ASL on it (OOcccccO). OR it with
the contents of $57 (bbOOOOOO). and put
the result (bbcccccO) in $57.</p>
</td></tr>
				<tr><td></td><td class="fit">F700</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">F702</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F703</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F704</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F705</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F706</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F707</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F70A</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F70B</td>
				<td>05 57</td>
				<td class="fit">ORA $57</td></tr>
				<tr><td></td><td class="fit">F70D</td>
				<td>85 57</td>
				<td class="fit">STA $57</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F70F</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td><td rowspan="14"><p>Load second 8-bit byte ($53), AND it
with $0F (00001111) to mask off the high
nybble (0000DDDD). find the five bit GCR
equivalent (OOOddddd) in BGTAB ($F77F+) ,
do four ROL's on it (ddddOOOO C=d) ,
store it in $58 (ddddOOOO). do one more
ROL (dddOOOOd C=d). AND it with $01, OR
it with the value in $57 (bbcccccO) and
store the result (bbcccccd) into the
second byte of the GCR buffer</p>
</td></tr>
				<tr><td></td><td class="fit">F711</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">F713</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F714</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F717</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F718</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F719</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F71A</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F71B</td>
				<td>85 58</td>
				<td class="fit">STA $58</td></tr>
				<tr><td></td><td class="fit">F71D</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F71E</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">F720</td>
				<td>05 57</td>
				<td class="fit">ORA $57</td></tr>
				<tr><td></td><td class="fit">F722</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F724</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F725</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td><td rowspan="16"><p>Load third 8-bit byte ($54). AND it with
$F0 (11110000) to mask off the low
nybble (EEEE0000). do four LSR's to
convert the hi nybble to a low nybble
(0000EEEE). look up the five bit GCR
equivalent (OOOeeeee) in BGTAB ($F77F+) ,
do one FOR on it (OOOOeeee C=e). OR it
with the contents of $58 (ddddOOOO) ,
store the result (ddddeeee) in the third
byte of the GCR buffer, do another ROR
(eC000eee)C=e, AND it with $80(10000000)
and store the result (eOOOOOOO) in $59.</p>
</td></tr>
				<tr><td></td><td class="fit">F727</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">F729</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F72A</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F72B</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F72C</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F72D</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F72E</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F731</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">F732</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">F733</td>
				<td>05 58</td>
				<td class="fit">ORA $58</td></tr>
				<tr><td></td><td class="fit">F735</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F737</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F738</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">F739</td>
				<td>29 80</td>
				<td class="fit">AND #$80</td></tr>
				<tr><td></td><td class="fit">F73B</td>
				<td>85 59</td>
				<td class="fit">STA $59</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F73D</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td><td rowspan="9"><p>Load third 8-bit byte ($54). AND it with
$0F (00001111) to mask off the high
nibble (0000FFFF). find the five bit GCR
equivalent (OOOfffff ) in BGTAB ($F77F+) ,
do two ASL's on it (OfffffOO), AND it
with $7C (01111100). OR it with the
value in $59 (eOOOOOOO). and store the
result (efffffOO) in $59</p>
</td></tr>
				<tr><td></td><td class="fit">F73F</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">F741</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F742</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F745</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F746</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F747</td>
				<td>29 7C</td>
				<td class="fit">AND #$7C</td></tr>
				<tr><td></td><td class="fit">F749</td>
				<td>05 59</td>
				<td class="fit">ORA $59</td></tr>
				<tr><td></td><td class="fit">F74B</td>
				<td>85 59</td>
				<td class="fit">STA $59</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F74D</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td><td rowspan="21"><p>Load the fourth 8-bit byte ($55), AND it
with $F0 (11110000) to mask off the low
nybble (GGGG0000). do four LSR's to
convert the hi nybble to a low nybble
(0000GGGG). look up the five bit GCR
equivalent (OOOggggg) in BGTAB ($F77F+),
do three ROR's on .A  alternated with
ROR's on $5A .A= (0000Ogg) $5A= (gggOOOOO)
AND .A with $03 (0000 0011). OR .A with
the contents of $59 ( efffffOO). &amp; store
result (efffffgg) in  the fourth byte of
the GCR buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F74F</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">F751</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F752</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F753</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F754</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F755</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F756</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F759</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">F75A</td>
				<td>66 5A</td>
				<td class="fit">ROR $5A</td></tr>
				<tr><td></td><td class="fit">F75C</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">F75D</td>
				<td>66 5A</td>
				<td class="fit">ROR $5A</td></tr>
				<tr><td></td><td class="fit">F75F</td>
				<td>6A</td>
				<td class="fit">ROR</td></tr>
				<tr><td></td><td class="fit">F760</td>
				<td>66 5A</td>
				<td class="fit">ROR $5A</td></tr>
				<tr><td></td><td class="fit">F762</td>
				<td>29 03</td>
				<td class="fit">AND #$03</td></tr>
				<tr><td></td><td class="fit">F764</td>
				<td>05 59</td>
				<td class="fit">ORA $59</td></tr>
				<tr><td></td><td class="fit">F766</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F768</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F769</td>
				<td>D0 04</td>
				<td class="fit">BNE $F76F</td></tr>
				<tr><td></td><td class="fit">F76B</td>
				<td>A5 2F</td>
				<td class="fit">LDA $2F</td></tr>
				<tr><td></td><td class="fit">F76D</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F76F</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td><td rowspan="9"><p>Load the fourth 8-bit byte ($55). AND it
with $0F (00001111) to mask off the high
nybble (0000HHHH). find the five bit GCR
equivalent (OOOhhhhh) in BGTAB ($F77F+) ,
OR it with the value  in $59 (gggOOOOO) ,
and store the result (ggghhhhh) in the
fifth position of the GCR buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F771</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">F773</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">F774</td>
				<td>BD 7F F7</td>
				<td class="fit">LDA $F77F,X</td></tr>
				<tr><td></td><td class="fit">F777</td>
				<td>05 5A</td>
				<td class="fit">ORA $5A</td></tr>
				<tr><td></td><td class="fit">F779</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F77B</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F77C</td>
				<td>84 34</td>
				<td class="fit">STY $34</td></tr>
				<tr><td></td><td class="fit">F77E</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BGTAB</td><td class="fit">F77F</td>
				<td>0A 0B 12 13 0E 0F 16 17 09 19 1A 1B 0D 1D 1E 15</td>
				<td class="fit"></td><td rowspan="1"><p>Table of 5 bit GCR equivalents</p>
<pre><code>4 bit nybble   5 bit GCR code
  $00  0000      $0A  01010
  $01  0001      $0B  01011
  $02  0010      $12  10010
  $03  0011      $13  10011
  $04  0100      $0E  01110
  $05  0101      $0F  01111
  $06  0110      $16  10110
  $07  0111      $17  10111
  $08  1000      $09  01001
  $09  1001      $19  11001
  $0A  1010      $1A  11010
  $0B  1011      $1B  11011
  $0C  1100      $0D  01101
  $0D  1101      $1D  11101
  $0E  1110      $1E  11110
  $0F  1111      $15  10101
</code></pre>
<p>Note: 5 bits are used to ensure that
not more than 2 consecutive 0's
are recorded on disk.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Create write image of data</h1>
<p>This routine converts 260 normal 8-bit
bytes into their 10-bit equivalents to
produce an image for writing to disk. A
total of 325 GCR bytes are produced.</p>
<p>The original 8-bit bytes are:</p>
<ul>
<li>1 data block ID character ($07)</li>
<li>256 data bytes (stored in buffer X)</li>
<li>1 data checksum</li>
<li>2 off bytes ($00)</li>
</ul>
<p>Total: 260 8-bit binary bytes</p>
<p>The first 69 GCR bytes are stored in the
overflow buffer ($10BB-FF). The rest of
the GCR bytes are stored in buffer X and
replace the original data bytes</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BINGCR</td><td class="fit">F78F</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Initialize pointers to buffers</p>
</td></tr>
				<tr><td></td><td class="fit">F791</td>
				<td>85 30</td>
				<td class="fit">STA $30</td></tr>
				<tr><td></td><td class="fit">F793</td>
				<td>85 2E</td>
				<td class="fit">STA $2E</td></tr>
				<tr><td></td><td class="fit">F795</td>
				<td>85 36</td>
				<td class="fit">STA $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F797</td>
				<td>A9 BB</td>
				<td class="fit">LDA #$BB</td><td rowspan="7"><p>Set pointer to start of overflow $01bb</p>
</td></tr>
				<tr><td></td><td class="fit">F799</td>
				<td>85 34</td>
				<td class="fit">STA $34</td></tr>
				<tr><td></td><td class="fit">F79B</td>
				<td>85 50</td>
				<td class="fit">STA $50</td></tr>
				<tr><td></td><td class="fit">F79D</td>
				<td>A5 31</td>
				<td class="fit">LDA $31</td></tr>
				<tr><td></td><td class="fit">F79F</td>
				<td>85 2F</td>
				<td class="fit">STA $2F</td></tr>
				<tr><td></td><td class="fit">F7A1</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">F7A3</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7A5</td>
				<td>A5 47</td>
				<td class="fit">LDA $47</td><td rowspan="12"><p>Move data block ID code from DBID ($47)
and first 3 data characters into a work
area ($52/3/4/5) for input by the PUT4GB
routine ($F6D0)</p>
</td></tr>
				<tr><td></td><td class="fit">F7A7</td>
				<td>85 52</td>
				<td class="fit">STA $52</td></tr>
				<tr><td></td><td class="fit">F7A9</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td></tr>
				<tr><td></td><td class="fit">F7AB</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F7AD</td>
				<td>85 53</td>
				<td class="fit">STA $53</td></tr>
				<tr><td></td><td class="fit">F7AF</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F7B0</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F7B2</td>
				<td>85 54</td>
				<td class="fit">STA $54</td></tr>
				<tr><td></td><td class="fit">F7B4</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F7B5</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F7B7</td>
				<td>85 55</td>
				<td class="fit">STA $55</td></tr>
				<tr><td></td><td class="fit">F7B9</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">BING07</td><td class="fit">F7BA</td>
				<td>84 36</td>
				<td class="fit">STY $36</td><td rowspan="1"><p>Store pointer to next byte to convert
(in .Y) into BYTCNT ($36).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7BC</td>
				<td>20 D0 F6</td>
				<td class="fit">JSR $F6D0</td><td rowspan="1"><p>JSR to PUT4GB ($F6D0) to convert the
four bytes in $52/3/4/5 into their five
GCR equivalents and store in buffer. Use
the overflow buffer first and then use
the data buffer.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7BF</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td><td rowspan="14"><p>Move next four bytes into the work area
($52/3/4/5) .</p>
</td></tr>
				<tr><td></td><td class="fit">F7C1</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F7C3</td>
				<td>85 52</td>
				<td class="fit">STA $52</td></tr>
				<tr><td></td><td class="fit">F7C5</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F7C6</td>
				<td>F0 11</td>
				<td class="fit">BEQ $F7D9</td></tr>
				<tr><td></td><td class="fit">F7C8</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F7CA</td>
				<td>85 53</td>
				<td class="fit">STA $53</td></tr>
				<tr><td></td><td class="fit">F7CC</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F7CD</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F7CF</td>
				<td>85 54</td>
				<td class="fit">STA $54</td></tr>
				<tr><td></td><td class="fit">F7D1</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F7D2</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F7D4</td>
				<td>85 55</td>
				<td class="fit">STA $55</td></tr>
				<tr><td></td><td class="fit">F7D6</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7D7</td>
				<td>D0 E1</td>
				<td class="fit">BNE $F7BA</td><td rowspan="1"><p>If more bytes to convert (.Y is count)
branch back to BING07.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7D9</td>
				<td>A5 3A</td>
				<td class="fit">LDA $3A</td><td rowspan="5"><p>Move data block checksum from DBID ($3A)
and two off bytes ($00) into the work
area ($53/4/5) NOTE: THE LAST DATA BYTE
IS IN $52.</p>
</td></tr>
				<tr><td></td><td class="fit">F7DB</td>
				<td>85 53</td>
				<td class="fit">STA $53</td></tr>
				<tr><td></td><td class="fit">F7DD</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">F7DF</td>
				<td>85 54</td>
				<td class="fit">STA $54</td></tr>
				<tr><td></td><td class="fit">F7E1</td>
				<td>85 55</td>
				<td class="fit">STA $55</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7E3</td>
				<td>4C D0 F6</td>
				<td class="fit">JMP $F6D0</td><td rowspan="1"><p>JSR to PUT4GB ($F6D0) to convert the
four bytes in $52/3/4/5 into their five
GCR equivalents and store in buffer.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert GCR to binary</h1>
<p>This routine is used to decode 5 GCR
bytes (used for recording on disk) into
4 normal 8-bit binary bytes. Decoding
involves extracting 5 bits from one or
two GCR bytes. The 4-bit nybble that is
equivalent to it is found by looking in
a table. The pattern of 5-bit segments
in the 5 GCR bytes and the equivalent
4-bit nybbles in the four binary bytes
are indicated below:</p>
<p>Four 10 bit encoded bytes stored in buffer
aaaaabbb bbcccccd ddddeeee efffffgg ggghhhhh</p>
<p>Four normal 8 bit bytes stored in $56/7/8/9
AAAABBBB CCCCDDDD EEEEFFFF GGGGHHHH</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GET4GB</td><td class="fit">F7E6</td>
				<td>A4 34</td>
				<td class="fit">LDY $34</td><td rowspan="7"><p>Load the first GCR byte (aaaaabbb) from
(BUFPNT) ,Y, AND it with $F8 (11111000)
to mask off the low bits (aaaaOOO). do
three LSR's and store the result
(OOOaaaaa) in GTAB ($56)</p>
</td></tr>
				<tr><td></td><td class="fit">F7E8</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td></tr>
				<tr><td></td><td class="fit">F7EA</td>
				<td>29 F8</td>
				<td class="fit">AND #$F8</td></tr>
				<tr><td></td><td class="fit">F7EC</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F7ED</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F7EE</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F7EF</td>
				<td>85 56</td>
				<td class="fit">STA $56</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7F1</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="5"><p>Load the first GCR byte (aaaaabbb) from
(BUFPNT) ,Y, AND it with $07 (00000111)
to mask off the high bits (OOOOObbb). do
two ASL's and store the result (OOObbbOO)
in $57.</p>
</td></tr>
				<tr><td></td><td class="fit">F7F3</td>
				<td>29 07</td>
				<td class="fit">AND #$07</td></tr>
				<tr><td></td><td class="fit">F7F5</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F7F6</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F7F7</td>
				<td>85 57</td>
				<td class="fit">STA $57</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F7F9</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="5"><p>Increment Y and check if Y=0. If so,
change BUFPNT so it points to the data
buffer rather than the overflow buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F7FA</td>
				<td>D0 06</td>
				<td class="fit">BNE $F802</td></tr>
				<tr><td></td><td class="fit">F7FC</td>
				<td>A5 4E</td>
				<td class="fit">LDA $4E</td></tr>
				<tr><td></td><td class="fit">F7FE</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F800</td>
				<td>A4 4F</td>
				<td class="fit">LDY $4F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F802</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="7"><p>Load the second GCR byte (bbcccccd) from
(BUFPNT) ,Y, AND it with $C0 (11000000)
to mask off the low bits (bbOOOOOO). do
three ROL f s (OOOOOObb). OR it with the
value in $57 (OOObbbOO). and store the
result (OOObbbbb) back in $57.</p>
</td></tr>
				<tr><td></td><td class="fit">F804</td>
				<td>29 C0</td>
				<td class="fit">AND #$C0</td></tr>
				<tr><td></td><td class="fit">F806</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F807</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F808</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F809</td>
				<td>05 57</td>
				<td class="fit">ORA $57</td></tr>
				<tr><td></td><td class="fit">F80B</td>
				<td>85 57</td>
				<td class="fit">STA $57</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F80D</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="4"><p>Load the second GCR byte (bbcccccd) from
(BUFPNT) ,Y, AND it with $3E (00111110)
to mask off unwanted bits (OOcccccO). do
one LSR and store the result (OOOccccc)
in $58.</p>
</td></tr>
				<tr><td></td><td class="fit">F80F</td>
				<td>29 3E</td>
				<td class="fit">AND #$3E</td></tr>
				<tr><td></td><td class="fit">F811</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F812</td>
				<td>85 58</td>
				<td class="fit">STA $58</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F814</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="8"><p>Load the second GCR byte (bbcccccd) from
(BUFPNT) ,Y, AND it with $01 (00000001)
to mask off unwanted bits (OOOOOOOd) ,
do four ASL's and store the result
(OOOdOOOO) in $58.</p>
</td></tr>
				<tr><td></td><td class="fit">F816</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">F818</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F819</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F81A</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F81B</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F81C</td>
				<td>85 59</td>
				<td class="fit">STA $59</td></tr>
				<tr><td></td><td class="fit">F81E</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F81F</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="8"><p>Load the third GCR byte (ddddeeee) from
(BUFPNT) ,Y, AND it with $F0 (11110000)
to mask off the low bits (ddddOOOO). do
four LSR's (OOOOdddd). OR it with the
value in $59 (OOOdOOOO). and store the
result (OOOddddd) back in $59.</p>
</td></tr>
				<tr><td></td><td class="fit">F821</td>
				<td>29 F0</td>
				<td class="fit">AND #$F0</td></tr>
				<tr><td></td><td class="fit">F823</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F824</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F825</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F826</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F827</td>
				<td>05 59</td>
				<td class="fit">ORA $59</td></tr>
				<tr><td></td><td class="fit">F829</td>
				<td>85 59</td>
				<td class="fit">STA $59</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F82B</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="5"><p>Load the third GCR byte (ddddeeee) from
(BUFPNT) ,Y, AND it with $0F (00001111) to
mask off hi bits (OOOOeeee). do one ASL
and store the result (OOOeeeeO) in $5A.</p>
</td></tr>
				<tr><td></td><td class="fit">F82D</td>
				<td>29 0F</td>
				<td class="fit">AND #$0F</td></tr>
				<tr><td></td><td class="fit">F82F</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F830</td>
				<td>85 5A</td>
				<td class="fit">STA $5A</td></tr>
				<tr><td></td><td class="fit">F832</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F833</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="8"><p>Load the fourth GCR byte (efffffgg) from
(BUFPNT) ,Y, AND it with $80 (10000000)
to mask off the low bits (eOOOOOOO). do
two ROL's (OOOeOOOO). OR it with the
value in $5A (OOOOeeee). and store the
result (OOOeeeee) back in $5A.</p>
</td></tr>
				<tr><td></td><td class="fit">F835</td>
				<td>29 80</td>
				<td class="fit">AND #$80</td></tr>
				<tr><td></td><td class="fit">F837</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">F838</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F839</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F83A</td>
				<td>29 01</td>
				<td class="fit">AND #$01</td></tr>
				<tr><td></td><td class="fit">F83C</td>
				<td>05 5A</td>
				<td class="fit">ORA $5A</td></tr>
				<tr><td></td><td class="fit">F83E</td>
				<td>85 5A</td>
				<td class="fit">STA $5A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F840</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="5"><p>Load the fourth GCR byte (efffffgg) from
(BUFPNT) ,Y, AND it with $7C (01111100)
to mask off unwanted bits (OfffffOO), do
two LSR's and store the result (OOOfffff )
in $5B.</p>
</td></tr>
				<tr><td></td><td class="fit">F842</td>
				<td>29 7C</td>
				<td class="fit">AND #$7C</td></tr>
				<tr><td></td><td class="fit">F844</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F845</td>
				<td>4A</td>
				<td class="fit">LSR</td></tr>
				<tr><td></td><td class="fit">F846</td>
				<td>85 5B</td>
				<td class="fit">STA $5B</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F848</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="8"><p>Load the fourth GCR byte (efffffgg) from
(BUFPNT),Y. AND it with $03 (00000011)
to mask off unwanted bits (OOOOOOgg) ,
do three LSR's and store the result
(OOOggOO0) in $5C.</p>
</td></tr>
				<tr><td></td><td class="fit">F84A</td>
				<td>29 03</td>
				<td class="fit">AND #$03</td></tr>
				<tr><td></td><td class="fit">F84C</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F84D</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F84E</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">F84F</td>
				<td>85 5C</td>
				<td class="fit">STA $5C</td></tr>
				<tr><td></td><td class="fit">F851</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F852</td>
				<td>D0 06</td>
				<td class="fit">BNE $F85A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F854</td>
				<td>A5 4E</td>
				<td class="fit">LDA $4E</td><td rowspan="3"><p>Increment Y. If Y=0 change BUFPNT to
point to the next buffer </p>
</td></tr>
				<tr><td></td><td class="fit">F856</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F858</td>
				<td>A4 4F</td>
				<td class="fit">LDY $4F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F85A</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="8"><p>Load the fifth GCR byte (ggghhhhh) from
(BUFPNT),Y, AND it with $E0 (11100000)
to mask off the low bit s (gggOOOOO). do
four ROL's (OOOOOggg). OR it with the
value in $5C (OOOggOOO). and store the
result (OOOggggg) back  in $5C.</p>
</td></tr>
				<tr><td></td><td class="fit">F85C</td>
				<td>29 E0</td>
				<td class="fit">AND #$E0</td></tr>
				<tr><td></td><td class="fit">F85E</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F85F</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F860</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F861</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">F862</td>
				<td>05 5C</td>
				<td class="fit">ORA $5C</td></tr>
				<tr><td></td><td class="fit">F864</td>
				<td>85 5C</td>
				<td class="fit">STA $5C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F866</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td><td rowspan="4"><p>Load the fifth GCR byte (ggghhhhh) from
(BUFPNT),Y. AND it with$1F (00011111)
to mask off the high bi ts (OOOhhhhh),
and store in $5D</p>
</td></tr>
				<tr><td></td><td class="fit">F868</td>
				<td>29 1F</td>
				<td class="fit">AND #$1F</td></tr>
				<tr><td></td><td class="fit">F86A</td>
				<td>85 5D</td>
				<td class="fit">STA $5D</td></tr>
				<tr><td></td><td class="fit">F86C</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>At this point the 40 bits that made up
the 5 GCR bytes have been separated into
eight 5-bit values that correspond to
the eight 4-bit nybbles that will make
up the four normal binary bytes. The 8
5-bit values are stored in $56-D. The
following routines look up the 4 -bit
hi nybbles in GCRHI ($F8A0) and the low
nybbles in GCRLO (starts at $F8C0)</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F86D</td>
				<td>84 34</td>
				<td class="fit">STY $34</td><td rowspan="6"><p>Load .X with the first 5-bit value from
$56, load .A with 4-bit high nybble
from GCRHI ,X, load X with a second five
bit value from $57, OR .A with the four
bit low nybble from GCRLO, X, and store
the result in $52.</p>
</td></tr>
				<tr><td></td><td class="fit">F86F</td>
				<td>A6 56</td>
				<td class="fit">LDX $56</td></tr>
				<tr><td></td><td class="fit">F871</td>
				<td>BD A0 F8</td>
				<td class="fit">LDA $F8A0,X</td></tr>
				<tr><td></td><td class="fit">F874</td>
				<td>A6 57</td>
				<td class="fit">LDX $57</td></tr>
				<tr><td></td><td class="fit">F876</td>
				<td>1D C0 F8</td>
				<td class="fit">ORA $F8C0,X</td></tr>
				<tr><td></td><td class="fit">F879</td>
				<td>85 52</td>
				<td class="fit">STA $52</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F87B</td>
				<td>A6 58</td>
				<td class="fit">LDX $58</td><td rowspan="5"><p>Load X with the third 5-bit value from
$58, load .A with 4-bit high nybble from
GCRHI, X, load X with the fourth 5-bit
value from $59, OR .A with the 4-bit low
nybble from GCRLO, X and store the result
in $53.</p>
</td></tr>
				<tr><td></td><td class="fit">F87D</td>
				<td>BD A0 F8</td>
				<td class="fit">LDA $F8A0,X</td></tr>
				<tr><td></td><td class="fit">F880</td>
				<td>A6 59</td>
				<td class="fit">LDX $59</td></tr>
				<tr><td></td><td class="fit">F882</td>
				<td>1D C0 F8</td>
				<td class="fit">ORA $F8C0,X</td></tr>
				<tr><td></td><td class="fit">F885</td>
				<td>85 53</td>
				<td class="fit">STA $53</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F887</td>
				<td>A6 5A</td>
				<td class="fit">LDX $5A</td><td rowspan="5"><p>Load X with the fifth 5-bit value from
$5A, load .A with 4-bit high nybble from
from GCRHI, X, load X with the second
five bit value from $5B, OR .A with the
four bit low nybble from GCRLO, X, and
store the result in $54.</p>
</td></tr>
				<tr><td></td><td class="fit">F889</td>
				<td>BD A0 F8</td>
				<td class="fit">LDA $F8A0,X</td></tr>
				<tr><td></td><td class="fit">F88C</td>
				<td>A6 5B</td>
				<td class="fit">LDX $5B</td></tr>
				<tr><td></td><td class="fit">F88E</td>
				<td>1D C0 F8</td>
				<td class="fit">ORA $F8C0,X</td></tr>
				<tr><td></td><td class="fit">F891</td>
				<td>85 54</td>
				<td class="fit">STA $54</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F893</td>
				<td>A6 5C</td>
				<td class="fit">LDX $5C</td><td rowspan="6"><p>Load .X with the seventh 5 value from
$5C, load .A with 4-bit high nybble from
GCRHI, X, load X with the second 5-bit
value from $5D, OR .A with the four bit
low nybble from GCRLO, X, and store the
result in $55.</p>
</td></tr>
				<tr><td></td><td class="fit">F895</td>
				<td>BD A0 F8</td>
				<td class="fit">LDA $F8A0,X</td></tr>
				<tr><td></td><td class="fit">F898</td>
				<td>A6 5D</td>
				<td class="fit">LDX $5D</td></tr>
				<tr><td></td><td class="fit">F89A</td>
				<td>1D C0 F8</td>
				<td class="fit">ORA $F8C0,X</td></tr>
				<tr><td></td><td class="fit">F89D</td>
				<td>85 55</td>
				<td class="fit">STA $55</td></tr>
				<tr><td></td><td class="fit">F89F</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>NOTE: The five bit to four bit tables below have many $FF
entries. These are the five bit codes that are not used.
If one of these is found, it causes a byte decoding error</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F8A0</td>
				<td>FF FF FF FF FF FF FF FF FF 80 00 10 FF C0 40 50 FF FF 20 30 FF F0 60 70 FF 90 A0 B0 FF D0 E0 FF FF FF FF FF FF FF FF FF FF 08 00 01 FF 0C 04 05 FF FF 02 03 FF 0F 06 07 FF 09 0A 0B FF 0D 0E FF</td>
				<td class="fit"></td><td rowspan="1"><p>GCRHI($F8A0) &amp; GCRLO($F8C0) Tables of 5 bit GCR to binary</p>
<pre><code>5 bit GCR code | High nybble ($F8A0+)  |  Low nybble ($F8C0+)
---------------|-----------------------|---------------------
$00  00000     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$01  00001     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$02  00010     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$03  00011     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$04  00100     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$05  00101     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$06  00110     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$07  00111     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$08  01000     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$09  01001     | $80  1000----         |  $08  ----1000
$0A  01010     | $00  --------         |  $00  ----0000
$0B  01011     | $10  0001----         |  $01  ----0001
$0C  01100     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$0D  01101     | $C0  1100----         |  $0C  ----1100
$0E  01110     | $40  0100----         |  $04  ----0100
$0F  01111     | $50  0101----         |  $05  ----0101
$10  10000     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$11  10001     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$12  10010     | $20  0010----         |  $02  ----0010
$13  10011     | $30  0011----         |  $03  ----0011
$14  10100     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$15  10101     | $F0  1111----         |  $0F  ----1111
$16  10110     | $60  0110----         |  $06  ----0110
$17  10111     | $70  0111----         |  $07  ----0111
$18  11000     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$19  11001     | $90  1001----         |  $09  ----1001
$1A  11010     | $A0  1010----         |  $0A  ----1010
$1B  11011     | $B0  1011----         |  $0B  ----1011
$1C  11100     | $FF  11111111 ERROR   |  $FF  11111111 ERROR
$1D  11101     | $D0  1101----         |  $0D  ----1101
$1E  11110     | $E0  1110----         |  $0E  ----1110
$1F  11111     | $FF  11111111 ERROR   |  $FF  11111111 ERROR</code></pre>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Decode GCR data image</h1>
<p>This routine decoded the 69 GCR bytes
stored in the overflow buffer ($10BB-FF)
into normal 8-bit bytes. The decoded
bytes are stored in a data buffer.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GCRBIN</td><td class="fit">F8E0</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Zero byte counter &amp; lo bit of pointers</p>
</td></tr>
				<tr><td></td><td class="fit">F8E2</td>
				<td>85 34</td>
				<td class="fit">STA $34</td></tr>
				<tr><td></td><td class="fit">F8E4</td>
				<td>85 2E</td>
				<td class="fit">STA $2E</td></tr>
				<tr><td></td><td class="fit">F8E6</td>
				<td>85 36</td>
				<td class="fit">STA $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F8E8</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td><td rowspan="4"><p>Set lo byte of pointer, NXTBF ($4E) to
$BA and set the hi byte NXTPNT ($4F) to
$01 so they point to the first byte of
the GCR image in the overflow buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F8EA</td>
				<td>85 4E</td>
				<td class="fit">STA $4E</td></tr>
				<tr><td></td><td class="fit">F8EC</td>
				<td>A9 BA</td>
				<td class="fit">LDA #$BA</td></tr>
				<tr><td></td><td class="fit">F8EE</td>
				<td>85 4F</td>
				<td class="fit">STA $4F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F8F0</td>
				<td>A5 31</td>
				<td class="fit">LDA $31</td><td rowspan="2"><p>Set SAVPNT+1 ($2F) to point to the data
buffer where the 8-bit bytes are to be
stored.</p>
</td></tr>
				<tr><td></td><td class="fit">F8F2</td>
				<td>85 2F</td>
				<td class="fit">STA $2F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F8F4</td>
				<td>20 E6 F7</td>
				<td class="fit">JSR $F7E6</td><td rowspan="1"><p>JSR to GET4GB ($F7E6) to convert the
first five GCR bytes into binary, the
header block ID, the header checksum,
the sector #, and the track #. The
decoded bytes appear in $52-5.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F8F7</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td><td rowspan="2"><p>Store header block ID code in BID ($38)</p>
</td></tr>
				<tr><td></td><td class="fit">F8F9</td>
				<td>85 38</td>
				<td class="fit">STA $38</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F8FB</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td><td rowspan="10"><p>Move the three decoded bytes from $53-55
into the buffer. Note that these bytes
are NOT stored in the overflow buffer
where the GCR image is stored.</p>
</td></tr>
				<tr><td></td><td class="fit">F8FD</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td></tr>
				<tr><td></td><td class="fit">F8FF</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F901</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F902</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td></tr>
				<tr><td></td><td class="fit">F904</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F906</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F907</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td></tr>
				<tr><td></td><td class="fit">F909</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F90B</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GCRB10</td><td class="fit">F90C</td>
				<td>84 36</td>
				<td class="fit">STY $36</td><td rowspan="1"><p>Transfer byte pointer from .Y into
BYTCNT ($36) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F90E</td>
				<td>20 E6 F7</td>
				<td class="fit">JSR $F7E6</td><td rowspan="2"><p>JSR to GET4GB ($F7E6) to convert the
next five GCR bytes to normal and store
them in $52-5.</p>
</td></tr>
				<tr><td></td><td class="fit">F911</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F913</td>
				<td>A5 52</td>
				<td class="fit">LDA $52</td><td rowspan="3"><p>Move decoded data byte from $52 into the
data buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F915</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F917</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F918</td>
				<td>F0 11</td>
				<td class="fit">BEQ $F92B</td><td rowspan="1"><p>Test .Y to see if entire overflow buffer
has been done. If done, branch to GCRB20</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F91A</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td><td rowspan="9"><p>Move decoded data bytes from $53-5 into
the data buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">F91C</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F91E</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F91F</td>
				<td>A5 54</td>
				<td class="fit">LDA $54</td></tr>
				<tr><td></td><td class="fit">F921</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F923</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">F924</td>
				<td>A5 55</td>
				<td class="fit">LDA $55</td></tr>
				<tr><td></td><td class="fit">F926</td>
				<td>91 2E</td>
				<td class="fit">STA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">F928</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F929</td>
				<td>D0 E1</td>
				<td class="fit">BNE $F90C</td><td rowspan="1"><p>If .Y is not $00, there is more to do
so branch back to GCRB10.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">GCRB20</td><td class="fit">F92B</td>
				<td>A5 53</td>
				<td class="fit">LDA $53</td><td rowspan="2"><p>Move header block checksum from $53
to CHKSUM ($3A)</p>
</td></tr>
				<tr><td></td><td class="fit">F92D</td>
				<td>85 3A</td>
				<td class="fit">STA $3A</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F92F</td>
				<td>A5 2F</td>
				<td class="fit">LDA $2F</td><td rowspan="3"><p>Restore buffer pointer and RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">F931</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F933</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert header to write image</h1>
<p>This routine creates a GCR image of a
header block. It uses the header block
ID code from HBID ($39) and the header
information stored in $1A (checksum) ,
$19 (sector), $18 (track), $17 (ID2),
and $16 (ID1). A final $00 byte is used
as a final off byte. Four of the binary
bytes are moved into a staging area and
the subroutine PUT4GB ($F6D0) is used to
convert these bytes to their GCR image
and store them in the STAB buf f er ($24-D)</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CONHDR</td><td class="fit">F934</td>
				<td>A5 31</td>
				<td class="fit">LDA $31</td><td rowspan="2"><p>Save current value of the buffer pointer
BUFPNT+1 ($31) in SAVPNT+1 ($2F) .</p>
</td></tr>
				<tr><td></td><td class="fit">F936</td>
				<td>85 2F</td>
				<td class="fit">STA $2F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F938</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Make BUFPNT+1 ($31) point to &gt;STAB ($00)</p>
</td></tr>
				<tr><td></td><td class="fit">F93A</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F93C</td>
				<td>A9 24</td>
				<td class="fit">LDA #$24</td><td rowspan="2"><p>Make GCRPNT ($34) point to &lt;STAB ($24)</p>
</td></tr>
				<tr><td></td><td class="fit">F93E</td>
				<td>85 34</td>
				<td class="fit">STA $34</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F940</td>
				<td>A5 39</td>
				<td class="fit">LDA $39</td><td rowspan="2"><p>Move hdr blk ID from HBID ($39) to $52</p>
</td></tr>
				<tr><td></td><td class="fit">F942</td>
				<td>85 52</td>
				<td class="fit">STA $52</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F944</td>
				<td>A5 1A</td>
				<td class="fit">LDA $1A</td><td rowspan="2"><p>Move checksum from $1A to $53</p>
</td></tr>
				<tr><td></td><td class="fit">F946</td>
				<td>85 53</td>
				<td class="fit">STA $53</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F948</td>
				<td>A5 19</td>
				<td class="fit">LDA $19</td><td rowspan="2"><p>Move sector from $19 to $54</p>
</td></tr>
				<tr><td></td><td class="fit">F94A</td>
				<td>85 54</td>
				<td class="fit">STA $54</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F94C</td>
				<td>A5 18</td>
				<td class="fit">LDA $18</td><td rowspan="2"><p>Move track from $18 to $55</p>
</td></tr>
				<tr><td></td><td class="fit">F94E</td>
				<td>85 55</td>
				<td class="fit">STA $55</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F950</td>
				<td>20 D0 F6</td>
				<td class="fit">JSR $F6D0</td><td rowspan="1"><p>JSR to PUT4GB ($F6D0) to convert the
four bytes in $52-5 to 5 GCR bytes and
store them at the start of STAB ($24-8).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F953</td>
				<td>A5 17</td>
				<td class="fit">LDA $17</td><td rowspan="2"><p>Move 2nd ID chr from $17 to $52</p>
</td></tr>
				<tr><td></td><td class="fit">F955</td>
				<td>85 52</td>
				<td class="fit">STA $52</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F957</td>
				<td>A5 16</td>
				<td class="fit">LDA $16</td><td rowspan="2"><p>Move 1st ID chr from $16 to $53</p>
</td></tr>
				<tr><td></td><td class="fit">F959</td>
				<td>85 53</td>
				<td class="fit">STA $53</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F95B</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Store $00 off bytes into $54 &amp; $55</p>
</td></tr>
				<tr><td></td><td class="fit">F95D</td>
				<td>85 54</td>
				<td class="fit">STA $54</td></tr>
				<tr><td></td><td class="fit">F95F</td>
				<td>85 55</td>
				<td class="fit">STA $55</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F961</td>
				<td>20 D0 F6</td>
				<td class="fit">JSR $F6D0</td><td rowspan="1"><p>JSR to PUT4GB ($F6D0) to convert the
four bytes in $52-5 to 5 GCR bytes and
store them in STAB ($29-D).</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F964</td>
				<td>A5 2F</td>
				<td class="fit">LDA $2F</td><td rowspan="3"><p>Restore the buffer pointer BUFPNT+1 ($31)
to its previous value and RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">F966</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">F968</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Utility routines</h1>
<h1>Disk controller error handling</h1>
<p>This routine is used to terminate all
of the major disk controller routines.</p>
<p>The inputs to this routine are: the
error code (see table) in .A, the job
buffer number in JOBN ($3F). and the
GCRFLG ($50) (tells if the data in the
buffer has been left in write image (1)
or binary (0) form).</p>
<p>The routine stuffs
the error code into the job queue,
converts the data back to binary (if
necessary), starts time-out to turn off
the drive motor, resets the stack
pointer, and exits to $F2BE to begin
scanning the job queue again.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERRR</td><td class="fit">F969</td>
				<td>A4 3F</td>
				<td class="fit">LDY $3F</td><td rowspan="2"><p>Store error code in .A into job queue</p>
</td></tr>
				<tr><td></td><td class="fit">F96B</td>
				<td>99 00 00</td>
				<td class="fit">STA $0000,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F96E</td>
				<td>A5 50</td>
				<td class="fit">LDA $50</td><td rowspan="2"><p>Check GCRFLG ($50) to see if data left
in GCR format. If not, branch to ERRR10.</p>
</td></tr>
				<tr><td></td><td class="fit">F970</td>
				<td>F0 03</td>
				<td class="fit">BEQ $F975</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F972</td>
				<td>20 F2 F5</td>
				<td class="fit">JSR $F5F2</td><td rowspan="1"><p>JSR to WTOBIN ($F5F2) to convert data
from GCR to normal.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">ERRR10</td><td class="fit">F975</td>
				<td>20 8F F9</td>
				<td class="fit">JSR $F98F</td><td rowspan="1"><p>JSR to TRNOFF ($F98F) to start the time-
out to turn off the drive motor.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F978</td>
				<td>A6 49</td>
				<td class="fit">LDX $49</td><td rowspan="2"><p>Use value from SAVSP ($49) to reset the
stack pointer.</p>
</td></tr>
				<tr><td></td><td class="fit">F97A</td>
				<td>9A</td>
				<td class="fit">TXS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F97B</td>
				<td>4C BE F2</td>
				<td class="fit">JMP $F2BE</td><td rowspan="1"><p>JMP to TOP ($F2BE) to scan job queue.</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Turn on disk drive motor</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TURNON</td><td class="fit">F97E</td>
				<td>A9 A0</td>
				<td class="fit">LDA #$A0</td><td rowspan="2"><p>Store $A0 into drive status, DRVST ($20)
to indicate that the drive is ON but
not yet up to speed (accelerating) .</p>
</td></tr>
				<tr><td></td><td class="fit">F980</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F982</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="3"><p>Set bit 2 (00000100) of DSKCNT ($1C00)
to turn ON the drive motor.</p>
</td></tr>
				<tr><td></td><td class="fit">F985</td>
				<td>09 04</td>
				<td class="fit">ORA #$04</td></tr>
				<tr><td></td><td class="fit">F987</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F98A</td>
				<td>A9 3C</td>
				<td class="fit">LDA #$3C</td><td rowspan="3"><p>Store $3C into acceleration timer, ACLTIM
($48) to cause drive status to be set
to up-to-speed after 1.5 seconds.
(60 interrupts at .025 seconds each)</p>
</td></tr>
				<tr><td></td><td class="fit">F98C</td>
				<td>85 48</td>
				<td class="fit">STA $48</td></tr>
				<tr><td></td><td class="fit">F98E</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Turn off disk drive motor</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TRNOFF</td><td class="fit">F98F</td>
				<td>A6 3E</td>
				<td class="fit">LDX $3E</td><td rowspan="1"><p>Load .X with current drive # (0)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F991</td>
				<td>A5 20</td>
				<td class="fit">LDA $20</td><td rowspan="3"><p>Set bit 4 (00010000) of the drive status
DRVST ($20) to indicate DRIVE IS OFF!</p>
</td></tr>
				<tr><td></td><td class="fit">F993</td>
				<td>09 10</td>
				<td class="fit">ORA #$10</td></tr>
				<tr><td></td><td class="fit">F995</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F997</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="3"><p>Store $FF into acceleration timer to
cause the drive to be turned OFF after
6.4 seconds. (255 interrupts x .025 sec)</p>
</td></tr>
				<tr><td></td><td class="fit">F999</td>
				<td>85 48</td>
				<td class="fit">STA $48</td></tr>
				<tr><td></td><td class="fit">F99B</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Drive motor and head stepper control
This routine is the last part of the
main IRQ routine. As a result, it is
executed every 10 milliseconds. Control
is transferred to the routine by JMP
instructions at the conclusion of the
main disk controller routines. The RTS
at the end of the routine transfers
control to master IRQ routine at $FE7C.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">END</td><td class="fit">F99C</td>
				<td>AD 07 1C</td>
				<td class="fit">LDA $1C07</td><td rowspan="3"><p>Move value in the 6522 's timer #1 high
latch ($1C07) into timer #l's high bit
counter ($1C05)</p>
</td></tr>
				<tr><td></td><td class="fit">F99F</td>
				<td>8D 05 1C</td>
				<td class="fit">STA $1C05</td></tr>
				<tr><td></td><td class="fit">F9A2</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F9A5</td>
				<td>29 10</td>
				<td class="fit">AND #$10</td><td rowspan="6"><p>Test if write protect status has changed
by loading the value from the 6522 's
data PORT B($1C00), ANDing it with $10
and comparing it to the value in LWPT
($1E). If not equal, set flag for change
in status, WPSW ($1C) to $01.</p>
</td></tr>
				<tr><td></td><td class="fit">F9A7</td>
				<td>C5 1E</td>
				<td class="fit">CMP $1E</td></tr>
				<tr><td></td><td class="fit">F9A9</td>
				<td>85 1E</td>
				<td class="fit">STA $1E</td></tr>
				<tr><td></td><td class="fit">F9AB</td>
				<td>F0 04</td>
				<td class="fit">BEQ $F9B1</td></tr>
				<tr><td></td><td class="fit">F9AD</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">F9AF</td>
				<td>85 1C</td>
				<td class="fit">STA $1C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F9B1</td>
				<td>AD FE 02</td>
				<td class="fit">LDA $02FE</td><td rowspan="11"><p>Test whether the head stepper is in
(0 or 2) or out (1) of phase. The head's
stepper motor moves half a track at a
time. If the head is halfway between two
tracks, the value stored in PHASE ($02FE)
is 1. If the value in PHASE is 0, branch
to END40 ($F9CB). If PHASE is 2, set it
to $00 and branch to END40. If it is $01
set it to $02 &amp; branch to DOSTEP ($FA2E)
to move head half a track.</p>
</td></tr>
				<tr><td></td><td class="fit">F9B4</td>
				<td>F0 15</td>
				<td class="fit">BEQ $F9CB</td></tr>
				<tr><td></td><td class="fit">F9B6</td>
				<td>C9 02</td>
				<td class="fit">CMP #$02</td></tr>
				<tr><td></td><td class="fit">F9B8</td>
				<td>D0 07</td>
				<td class="fit">BNE $F9C1</td></tr>
				<tr><td></td><td class="fit">F9BA</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">F9BC</td>
				<td>8D FE 02</td>
				<td class="fit">STA $02FE</td></tr>
				<tr><td></td><td class="fit">F9BF</td>
				<td>F0 0A</td>
				<td class="fit">BEQ $F9CB</td></tr>
				<tr><td></td><td class="fit">F9C1</td>
				<td>85 4A</td>
				<td class="fit">STA $4A</td></tr>
				<tr><td></td><td class="fit">F9C3</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td></tr>
				<tr><td></td><td class="fit">F9C5</td>
				<td>8D FE 02</td>
				<td class="fit">STA $02FE</td></tr>
				<tr><td></td><td class="fit">F9C8</td>
				<td>4C 2E FA</td>
				<td class="fit">JMP $FA2E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F9CB</td>
				<td>A6 3E</td>
				<td class="fit">LDX $3E</td><td rowspan="2"><p>Check CDRIVE ($3E) to see if the drive
is active. If not active, branch to
END33X to end the IRQ routine.</p>
</td></tr>
				<tr><td></td><td class="fit">F9CD</td>
				<td>30 07</td>
				<td class="fit">BMI $F9D6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F9CF</td>
				<td>A5 20</td>
				<td class="fit">LDA $20</td><td rowspan="4"><p>Load DRVST ($20) to see if the motor is
ON and compare value with $20. If there
is anything to do (result not equal),
then branch to END10.</p>
</td></tr>
				<tr><td></td><td class="fit">F9D1</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">F9D2</td>
				<td>C9 20</td>
				<td class="fit">CMP #$20</td></tr>
				<tr><td></td><td class="fit">F9D4</td>
				<td>D0 03</td>
				<td class="fit">BNE $F9D9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">END33X</td><td class="fit">F9D6</td>
				<td>4C BE FA</td>
				<td class="fit">JMP $FABE</td><td rowspan="1"><p>JMP to END33 ($FABE) to end IRQ.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">END10</td><td class="fit">F9D9</td>
				<td>C6 48</td>
				<td class="fit">DEC $48</td><td rowspan="6"><p>Something doing, so decrement the
acceleration timer, ACLTIM ($48). and if
drive is not yet up to speed, branch to
END30.
Since drive is up to speed, clear the
not-up-to-speed bit (bit 7) of the drive
status, DRVST ($20) .</p>
</td></tr>
				<tr><td></td><td class="fit">F9DB</td>
				<td>D0 1D</td>
				<td class="fit">BNE $F9FA</td></tr>
				<tr><td></td><td class="fit">F9DD</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">F9DE</td>
				<td>10 04</td>
				<td class="fit">BPL $F9E4</td></tr>
				<tr><td></td><td class="fit">F9E0</td>
				<td>29 7F</td>
				<td class="fit">AND #$7F</td></tr>
				<tr><td></td><td class="fit">F9E2</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">END20</td><td class="fit">F9E4</td>
				<td>29 10</td>
				<td class="fit">AND #$10</td><td rowspan="2"><p>AND the value of DRVST ($20) with $10 to
test whether a time-out has occurred and
it is time to turn off the drive motor.
If not, branch to END30 ($F9FA).</p>
</td></tr>
				<tr><td></td><td class="fit">F9E6</td>
				<td>F0 12</td>
				<td class="fit">BEQ $F9FA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F9E8</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="3"><p>Turn off drive motor by loading .A with
the value of DRVCNT ($1C00). ANDing it
with $FB (to clear bit 2) and storing
the result back in DRVCNT.</p>
</td></tr>
				<tr><td></td><td class="fit">F9EB</td>
				<td>29 FB</td>
				<td class="fit">AND #$FB</td></tr>
				<tr><td></td><td class="fit">F9ED</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F9F0</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF in CDRIVE ($3E) to indicate
there is no currently active drive.</p>
</td></tr>
				<tr><td></td><td class="fit">F9F2</td>
				<td>85 3E</td>
				<td class="fit">STA $3E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">F9F4</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="3"><p>Set DRVST ($20) to $0 to indicate that
the drive is switched OFF. Then branch
to END33X ($F9D6) to end IRQ routine.</p>
</td></tr>
				<tr><td></td><td class="fit">F9F6</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
				<tr><td></td><td class="fit">F9F8</td>
				<td>F0 DC</td>
				<td class="fit">BEQ $F9D6</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">END30</td><td class="fit">F9FA</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="5"><p>AND .A (contains drive status) with $40
to test if head must be moved. If the
result is (no stepping needed) JMP to
END33 ($FABE) to end the IRQ routine.
If stepping is required f do an indirect
JMP via NXTST ($0062) to the proper
head stepping routine:</p>
<p>SHORT - $FA3B - short step mode
SETLE - $FA4E - settle head mode
SSACL - $FA7B - accelerate mode
SSRUN - $FA97 - fast stepping mode
SSDEC - $FAA5 - decelerate mode</p>
</td></tr>
				<tr><td></td><td class="fit">F9FB</td>
				<td>29 40</td>
				<td class="fit">AND #$40</td></tr>
				<tr><td></td><td class="fit">F9FD</td>
				<td>D0 03</td>
				<td class="fit">BNE $FA02</td></tr>
				<tr><td></td><td class="fit">F9FF</td>
				<td>4C BE FA</td>
				<td class="fit">JMP $FABE</td></tr>
				<tr><td></td><td class="fit">FA02</td>
				<td>6C 62 00</td>
				<td class="fit">JMP ($0062)</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Set up to step the head</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INACT</td><td class="fit">FA05</td>
				<td>A5 4A</td>
				<td class="fit">LDA $4A</td><td rowspan="5"><p>Load .A with the number of steps to move
the head from STEPS ($4A). If negative
(&gt;127), find the absolute value using
the 2's complement.</p>
</td></tr>
				<tr><td></td><td class="fit">FA07</td>
				<td>10 05</td>
				<td class="fit">BPL $FA0E</td></tr>
				<tr><td></td><td class="fit">FA09</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td></tr>
				<tr><td></td><td class="fit">FA0B</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FA0C</td>
				<td>69 01</td>
				<td class="fit">ADC #$01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INAC10</td><td class="fit">FA0E</td>
				<td>C5 64</td>
				<td class="fit">CMP $64</td><td rowspan="2"><p>Compare the number of steps to the value
(usually $C8)in MINSTP ($64) to see if
the distance is big enough to use the
fast stepping mode. If the distance is
large enough, branch to INA20 ($FA1C) .</p>
</td></tr>
				<tr><td></td><td class="fit">FA10</td>
				<td>B0 0A</td>
				<td class="fit">BCS $FA1C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FA12</td>
				<td>A9 3B</td>
				<td class="fit">LDA #$3B</td><td rowspan="5"><p>Not big enough so set up the pointer in
NXTST ($62/3) to point to the short step
routine, SHORT ($FA3B) and branch to
DOSTEP ($FA2E) .</p>
</td></tr>
				<tr><td></td><td class="fit">FA14</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">FA16</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">FA18</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
				<tr><td></td><td class="fit">FA1A</td>
				<td>D0 12</td>
				<td class="fit">BNE $FA2E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">INAC20</td><td class="fit">FA1C</td>
				<td>E5 5E</td>
				<td class="fit">SBC $5E</td><td rowspan="9"><p>Calculate the number of steps to do in
fast stepping mode by subtracting the
value in AS ($5E) from .A twice (for
acceleration and deceleration). Store
the result in RSTEPS ($61). Then move
the number of steps needed for the head
to accelerate from AS ($5E) to ACLSTP
($60). Finally set pointer in NXTST
($62/3) to point to the acceleration
mode routine SSACL ($FA7B)</p>
</td></tr>
				<tr><td></td><td class="fit">FA1E</td>
				<td>E5 5E</td>
				<td class="fit">SBC $5E</td></tr>
				<tr><td></td><td class="fit">FA20</td>
				<td>85 61</td>
				<td class="fit">STA $61</td></tr>
				<tr><td></td><td class="fit">FA22</td>
				<td>A5 5E</td>
				<td class="fit">LDA $5E</td></tr>
				<tr><td></td><td class="fit">FA24</td>
				<td>85 60</td>
				<td class="fit">STA $60</td></tr>
				<tr><td></td><td class="fit">FA26</td>
				<td>A9 7B</td>
				<td class="fit">LDA #$7B</td></tr>
				<tr><td></td><td class="fit">FA28</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">FA2A</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">FA2C</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DOSTEP</td><td class="fit">FA2E</td>
				<td>A5 4A</td>
				<td class="fit">LDA $4A</td><td rowspan="2"><p>Load value from STEPS ($4A). If positive
(&lt;127). branch to STPIN ($FA63) to step
the head inwards.</p>
</td></tr>
				<tr><td></td><td class="fit">FA30</td>
				<td>10 31</td>
				<td class="fit">BPL $FA63</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STPOUT</td><td class="fit">FA32</td>
				<td>E6 4A</td>
				<td class="fit">INC $4A</td><td rowspan="4"><p>Increment STEPS ($4A) to reduce number
left to do by 1, load .X with the value
from DSKCNT ($1C00) decrement it by 1,
and branch to STP ($FA69) .</p>
</td></tr>
				<tr><td></td><td class="fit">FA34</td>
				<td>AE 00 1C</td>
				<td class="fit">LDX $1C00</td></tr>
				<tr><td></td><td class="fit">FA37</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FA38</td>
				<td>4C 69 FA</td>
				<td class="fit">JMP $FA69</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Short distance head stepping</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SHORT</td><td class="fit">FA3B</td>
				<td>A5 4A</td>
				<td class="fit">LDA $4A</td><td rowspan="9"><p>Load the number of steps left to do from
STEPS ($4A). If any left, branch to
DOSTEP ($FA2E). If not, set NXTST
pointer ($62/3) to point to the settle
head routine SETLE ($FA4E) and store $05
in ACLSTP ($60) to set the settle time.
Branch to END33 ($FABE) to end IRQ.</p>
</td></tr>
				<tr><td></td><td class="fit">FA3D</td>
				<td>D0 EF</td>
				<td class="fit">BNE $FA2E</td></tr>
				<tr><td></td><td class="fit">FA3F</td>
				<td>A9 4E</td>
				<td class="fit">LDA #$4E</td></tr>
				<tr><td></td><td class="fit">FA41</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">FA43</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">FA45</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
				<tr><td></td><td class="fit">FA47</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td></tr>
				<tr><td></td><td class="fit">FA49</td>
				<td>85 60</td>
				<td class="fit">STA $60</td></tr>
				<tr><td></td><td class="fit">FA4B</td>
				<td>4C BE FA</td>
				<td class="fit">JMP $FABE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SETLE</td><td class="fit">FA4E</td>
				<td>C6 60</td>
				<td class="fit">DEC $60</td><td rowspan="10"><p>Settle head routine. Decrement ACLSTP
($60) and if non-zero, brach to END33
($FABE) to end IRQ. If zero, set drive
status, DRVST ($20), to indicate that
the drive is available for use by
clearing bit 6. Set NXTST pointer ($62/3 )
to point to the head inactive routine
($FA05) and branch to END33 ($FABE).</p>
</td></tr>
				<tr><td></td><td class="fit">FA50</td>
				<td>D0 6C</td>
				<td class="fit">BNE $FABE</td></tr>
				<tr><td></td><td class="fit">FA52</td>
				<td>A5 20</td>
				<td class="fit">LDA $20</td></tr>
				<tr><td></td><td class="fit">FA54</td>
				<td>29 BF</td>
				<td class="fit">AND #$BF</td></tr>
				<tr><td></td><td class="fit">FA56</td>
				<td>85 20</td>
				<td class="fit">STA $20</td></tr>
				<tr><td></td><td class="fit">FA58</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td></tr>
				<tr><td></td><td class="fit">FA5A</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">FA5C</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">FA5E</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
				<tr><td></td><td class="fit">FA60</td>
				<td>4C BE FA</td>
				<td class="fit">JMP $FABE</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STPIN</td><td class="fit">FA63</td>
				<td>C6 4A</td>
				<td class="fit">DEC $4A</td><td rowspan="3"><p>Decrement STEPS ($4A) to reduce number
left to do by 1. load .X with the value
from DSKCNT($1C00) and increment it by 1</p>
</td></tr>
				<tr><td></td><td class="fit">FA65</td>
				<td>AE 00 1C</td>
				<td class="fit">LDX $1C00</td></tr>
				<tr><td></td><td class="fit">FA68</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">STP</td><td class="fit">FA69</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="8"><p>Transfer the value in .X to .A (this is
DSKCNT+1 for a step in and DSKCNT-1 for
a step out), AND the value with $03, and
store it in TMP ($4B). Load DSKCNT, AND
it with $FC to mask off bits &amp; 1. OR
it with TMP to set the new values for
these bits, and store the result back in
DSKCNT. JMP to END33 ($FABE) to end IRQ.</p>
</td></tr>
				<tr><td></td><td class="fit">FA6A</td>
				<td>29 03</td>
				<td class="fit">AND #$03</td></tr>
				<tr><td></td><td class="fit">FA6C</td>
				<td>85 4B</td>
				<td class="fit">STA $4B</td></tr>
				<tr><td></td><td class="fit">FA6E</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td></tr>
				<tr><td></td><td class="fit">FA71</td>
				<td>29 FC</td>
				<td class="fit">AND #$FC</td></tr>
				<tr><td></td><td class="fit">FA73</td>
				<td>05 4B</td>
				<td class="fit">ORA $4B</td></tr>
				<tr><td></td><td class="fit">FA75</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
				<tr><td></td><td class="fit">FA78</td>
				<td>4C BE FA</td>
				<td class="fit">JMP $FABE</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: cycling bits &amp; 1 of DSKCNT
      ($1C00) will move the head.
      00/01/10/11/00 will move head in
      00/11/10/01/00 will move head out</code></pre>
</td>
			</tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Accelerate head routine</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSACL</td><td class="fit">FA7B</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="6"><p>Set carry flag, load the 6522 Timer1 hi
latch T1HL2 ($1C07), subtract the value.
in AF ($5F; aceeleration factor), and
store the result in T1HC2 ($1C05; timer1
hi counter). Decrement the number of
acceleration steps left in ACLSTP ($60) -
and if any steps left, branch to SSA10</p>
</td></tr>
				<tr><td></td><td class="fit">FA7C</td>
				<td>AD 07 1C</td>
				<td class="fit">LDA $1C07</td></tr>
				<tr><td></td><td class="fit">FA7F</td>
				<td>E5 5F</td>
				<td class="fit">SBC $5F</td></tr>
				<tr><td></td><td class="fit">FA81</td>
				<td>8D 05 1C</td>
				<td class="fit">STA $1C05</td></tr>
				<tr><td></td><td class="fit">FA84</td>
				<td>C6 60</td>
				<td class="fit">DEC $60</td></tr>
				<tr><td></td><td class="fit">FA86</td>
				<td>D0 0C</td>
				<td class="fit">BNE $FA94</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FA88</td>
				<td>A5 5E</td>
				<td class="fit">LDA $5E</td><td rowspan="6"><p>No steps left, so reset the number of
acceleration steps left ACLSTP ($60)
using the valuein AS ($5E) and set the
NXTST pointer ($62/3) to point to the
fast stepping routine, SSRUN ($FA97).</p>
</td></tr>
				<tr><td></td><td class="fit">FA8A</td>
				<td>85 60</td>
				<td class="fit">STA $60</td></tr>
				<tr><td></td><td class="fit">FA8C</td>
				<td>A9 97</td>
				<td class="fit">LDA #$97</td></tr>
				<tr><td></td><td class="fit">FA8E</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">FA90</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">FA92</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSA10</td><td class="fit">FA94</td>
				<td>4C 2E FA</td>
				<td class="fit">JMP $FA2E</td><td rowspan="1"><p>JMP to DOSTEP ($FA2E)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Fast stepping mode routine</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSRUN</td><td class="fit">FA97</td>
				<td>C6 61</td>
				<td class="fit">DEC $61</td><td rowspan="7"><p>Decrement number of steps left to do in
RSTEPS ($61). If any left, branch to
DOSTEP ($FA2E). Since none left, set the
NXTST pointer ($62/3) to point to the
decelerate routine SSDEC ($FAA5) and
branch to DOSTEP ($FA2E) .</p>
</td></tr>
				<tr><td></td><td class="fit">FA99</td>
				<td>D0 F9</td>
				<td class="fit">BNE $FA94</td></tr>
				<tr><td></td><td class="fit">FA9B</td>
				<td>A9 A5</td>
				<td class="fit">LDA #$A5</td></tr>
				<tr><td></td><td class="fit">FA9D</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">FA9F</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">FAA1</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
				<tr><td></td><td class="fit">FAA3</td>
				<td>D0 EF</td>
				<td class="fit">BNE $FA94</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Decelerate head routine</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SSDEC</td><td class="fit">FAA5</td>
				<td>AD 07 1C</td>
				<td class="fit">LDA $1C07</td><td rowspan="12"><p>Load .A from the 6522 Timerl hi latch
T1HL2 ($1C07). clear the carry flag,
add the acceleration factor AF ($5F) ,
and store the result in T1HC2 ($1C05;
timerl hi counter). Decrement the number
of deceleration steps left ACLSTP ($60)
and if any steps left, branch to SSA10.
Since no steps left, set the NXTST
pointer ($62/3) to point to the settle
routine, SETLE ($FA4E). Set the number
of acceleration steps left to $03 to
allow settling time.</p>
</td></tr>
				<tr><td></td><td class="fit">FAA8</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FAA9</td>
				<td>65 5F</td>
				<td class="fit">ADC $5F</td></tr>
				<tr><td></td><td class="fit">FAAB</td>
				<td>8D 05 1C</td>
				<td class="fit">STA $1C05</td></tr>
				<tr><td></td><td class="fit">FAAE</td>
				<td>C6 60</td>
				<td class="fit">DEC $60</td></tr>
				<tr><td></td><td class="fit">FAB0</td>
				<td>D0 E2</td>
				<td class="fit">BNE $FA94</td></tr>
				<tr><td></td><td class="fit">FAB2</td>
				<td>A9 4E</td>
				<td class="fit">LDA #$4E</td></tr>
				<tr><td></td><td class="fit">FAB4</td>
				<td>85 62</td>
				<td class="fit">STA $62</td></tr>
				<tr><td></td><td class="fit">FAB6</td>
				<td>A9 FA</td>
				<td class="fit">LDA #$FA</td></tr>
				<tr><td></td><td class="fit">FAB8</td>
				<td>85 63</td>
				<td class="fit">STA $63</td></tr>
				<tr><td></td><td class="fit">FABA</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td></tr>
				<tr><td></td><td class="fit">FABC</td>
				<td>85 60</td>
				<td class="fit">STA $60</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">END33</td><td class="fit">FABE</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td><td rowspan="4"><p>Terminate the motor and stepper control
routine by clearing bit 1 of the 6522 's
peripheral control register, PCR2($1C0C)
This force CA2 low which disables the
SO line to the 6502. Finally, do an RTS
to transfer control back to the main
IRQ routine at $FE7C.</p>
</td></tr>
				<tr><td></td><td class="fit">FAC1</td>
				<td>29 FD</td>
				<td class="fit">AND #$FD</td></tr>
				<tr><td></td><td class="fit">FAC3</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td></tr>
				<tr><td></td><td class="fit">FAC6</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>This routine is used to format (NEW) a diskette</h1>
<p>The code is executed in place
(rather than moved into RAM and then
executed as in the 4040). The IP FORMAT
routine ($C8C6) sets up a JMP $FAC7 at
the start of buffer #0, puts an EXECUTE
($E0) job into the job queue at $03, and
then waits for the job to be completed.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FORMT</td><td class="fit">FAC7</td>
				<td>A5 51</td>
				<td class="fit">LDA $51</td><td rowspan="8"><p>Load .A from FTNUM ($51) to check if
formatting has begun. If FTNUM&gt;0, the
formatting has begun so branch to L213
($FAF5). If not, begin formatting by:
Setting DRVST($20) to $60 (head is now
stepping). storing $01 into DRVTRK ($22)
to set the current track and into FTNUM
($51; format begun flag) .</p>
</td></tr>
				<tr><td></td><td class="fit">FAC9</td>
				<td>10 2A</td>
				<td class="fit">BPL $FAF5</td></tr>
				<tr><td></td><td class="fit">FACB</td>
				<td>A6 3D</td>
				<td class="fit">LDX $3D</td></tr>
				<tr><td></td><td class="fit">FACD</td>
				<td>A9 60</td>
				<td class="fit">LDA #$60</td></tr>
				<tr><td></td><td class="fit">FACF</td>
				<td>95 20</td>
				<td class="fit">STA $20,X</td></tr>
				<tr><td></td><td class="fit">FAD1</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">FAD3</td>
				<td>95 22</td>
				<td class="fit">STA $22,X</td></tr>
				<tr><td></td><td class="fit">FAD5</td>
				<td>85 51</td>
				<td class="fit">STA $51</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FAD7</td>
				<td>A9 A4</td>
				<td class="fit">LDA #$A4</td><td rowspan="5"><p>Do BUMP to track 1 by stepping head out
46 tracks. Store -92 (256-2*46) into
STEPS ($4A) and clear bits &amp; 1 of
DSKCNT ($1C00) to set head phase to 00.</p>
</td></tr>
				<tr><td></td><td class="fit">FAD9</td>
				<td>85 4A</td>
				<td class="fit">STA $4A</td></tr>
				<tr><td></td><td class="fit">FADB</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td></tr>
				<tr><td></td><td class="fit">FADE</td>
				<td>29 FC</td>
				<td class="fit">AND #$FC</td></tr>
				<tr><td></td><td class="fit">FAE0</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FAE3</td>
				<td>A9 0A</td>
				<td class="fit">LDA #$0A</td><td rowspan="2"><p>Set CNT ($0620) to $0A to allow up to
10 errors before abort.</p>
</td></tr>
				<tr><td></td><td class="fit">FAE5</td>
				<td>8D 20 06</td>
				<td class="fit">STA $0620</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FAE8</td>
				<td>A9 A0</td>
				<td class="fit">LDA #$A0</td><td rowspan="5"><p>Set NUM($0621/2) to 4000 ($0FA0) as a
first guess at number of bytes that can
be recorded on half a track.
Exit with a JMP to END ($F99C)</p>
</td></tr>
				<tr><td></td><td class="fit">FAEA</td>
				<td>8D 21 06</td>
				<td class="fit">STA $0621</td></tr>
				<tr><td></td><td class="fit">FAED</td>
				<td>A9 0F</td>
				<td class="fit">LDA #$0F</td></tr>
				<tr><td></td><td class="fit">FAEF</td>
				<td>8D 22 06</td>
				<td class="fit">STA $0622</td></tr>
				<tr><td></td><td class="fit">FAF2</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L213</td><td class="fit">FAF5</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="5"><p>On re-entry .A holds the track number
(loaded from FTNUM). Compare it to the
track in HDRPNT($32). If they match, we
are on the correct track so branch to
L214 ($FB00). If different, put the .A
value (track we want) into HDRPNT ($32)
and exit with a JMP to END ($F99C) .</p>
</td></tr>
				<tr><td></td><td class="fit">FAF7</td>
				<td>D1 32</td>
				<td class="fit">CMP ($32),Y</td></tr>
				<tr><td></td><td class="fit">FAF9</td>
				<td>F0 05</td>
				<td class="fit">BEQ $FB00</td></tr>
				<tr><td></td><td class="fit">FAFB</td>
				<td>91 32</td>
				<td class="fit">STA ($32),Y</td></tr>
				<tr><td></td><td class="fit">FAFD</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">L214</td><td class="fit">FB00</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="5"><p>Test bit 4 of DSKCNT ($1C00) to see if
write protect is on. If 1, protect is
not on so branch to TOPP ($FB0C). If 0,
load .A with $08 to indicate a WRITE
PROTECT error &amp; JMP to FMTERR ($FDD3) .</p>
</td></tr>
				<tr><td></td><td class="fit">FB03</td>
				<td>29 10</td>
				<td class="fit">AND #$10</td></tr>
				<tr><td></td><td class="fit">FB05</td>
				<td>D0 05</td>
				<td class="fit">BNE $FB0C</td></tr>
				<tr><td></td><td class="fit">FB07</td>
				<td>A9 08</td>
				<td class="fit">LDA #$08</td></tr>
				<tr><td></td><td class="fit">FB09</td>
				<td>4C D3 FD</td>
				<td class="fit">JMP $FDD3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TOPP</td><td class="fit">FB0C</td>
				<td>20 A3 FD</td>
				<td class="fit">JSR $FDA3</td><td rowspan="1"><p>JSR to SYNCLR ($FDA3) to erase the track
by writing 28*256 SYNC marks.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FB0F</td>
				<td>20 C3 FD</td>
				<td class="fit">JSR $FDC3</td><td rowspan="1"><p>JSR to WRTNUM ($FDC3) to write out NUM
($0621/22; value = 4000) SYNC marks.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FB12</td>
				<td>A9 55</td>
				<td class="fit">LDA #$55</td><td rowspan="3"><p>Store a non-sync character ($55) into
the output port DATA2 ($1C01) and JSR to
WRTNUM ($FDC3) to write NUM ($0621/2;
value = 4000) non-sync bytes.</p>
</td></tr>
				<tr><td></td><td class="fit">FB14</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FB17</td>
				<td>20 C3 FD</td>
				<td class="fit">JSR $FDC3</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>At this point the track will have one
area that contains SYNC and another area
that has non-sync characters like this:</p>
<pre><code>11111111001100110011001100110011001111111
SYNC      4000 non-sync bytes      SYNC
</code></pre>
<p>The following routines time the SYNC and
non-sync segments to determine how many
characters can be written on the track,
This is used to calculate the length of
the gap between sectors(inter-sector) .</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FB1A</td>
				<td>20 00 FE</td>
				<td class="fit">JSR $FE00</td><td rowspan="1"><p>JSR to KILL ($FE00) to kill write mode.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FB1D</td>
				<td>20 56 F5</td>
				<td class="fit">JSR $F556</td><td rowspan="1"><p>JSR to SYNC ($F556) to wait for the
start of the SYNC section.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FB20</td>
				<td>A9 40</td>
				<td class="fit">LDA #$40</td><td rowspan="8"><p>Set bit 6 of the 6522' s ACR1 ($180B) to
set it up as a free running 100 micro-
second timer.</p>
</td></tr>
				<tr><td></td><td class="fit">FB22</td>
				<td>0D 0B 18</td>
				<td class="fit">ORA $180B</td></tr>
				<tr><td></td><td class="fit">FB25</td>
				<td>8D 0B 18</td>
				<td class="fit">STA $180B</td></tr>
				<tr><td></td><td class="fit">FB28</td>
				<td>A9 62</td>
				<td class="fit">LDA #$62</td></tr>
				<tr><td></td><td class="fit">FB2A</td>
				<td>8D 06 18</td>
				<td class="fit">STA $1806</td></tr>
				<tr><td></td><td class="fit">FB2D</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">FB2F</td>
				<td>8D 07 18</td>
				<td class="fit">STA $1807</td></tr>
				<tr><td></td><td class="fit">FB32</td>
				<td>8D 05 18</td>
				<td class="fit">STA $1805</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FB35</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td><td rowspan="2"><p>Set .X and .Y to $00. They will hold the
timer count. .X=least significant byte
.Y=most significant bit</p>
</td></tr>
				<tr><td></td><td class="fit">FB37</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FWAIT</td><td class="fit">FB39</td>
				<td>2C 00 1C</td>
				<td class="fit">BIT $1C00</td><td rowspan="2"><p>Loop to wait for SYNC area</p>
</td></tr>
				<tr><td></td><td class="fit">FB3C</td>
				<td>30 FB</td>
				<td class="fit">BMI $FB39</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FWAIT2</td><td class="fit">FB3E</td>
				<td>2C 00 1C</td>
				<td class="fit">BIT $1C00</td><td rowspan="2"><p>Loop to wait for not-sync area</p>
</td></tr>
				<tr><td></td><td class="fit">FB41</td>
				<td>10 FB</td>
				<td class="fit">BPL $FB3E</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">F000</td><td class="fit">FB43</td>
				<td>AD 04 18</td>
				<td class="fit">LDA $1804</td><td rowspan="1"><p>Reset interrupt flags to start the timer</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Loop to time the non-sync area</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">F001</td><td class="fit">FB46</td>
				<td>2C 00 1C</td>
				<td class="fit">BIT $1C00</td><td rowspan="11"><p>Check if SYNC here yet. If here, branch
to F005 ($FB5C). If no SYNC yet, check
IFR1 ($1804) to see if timer has timed
out. If time not up yet, branch back to
F001 ($FB46). If time is up, increment
.X by 1 (and .Y if .X=0) and branch back
to F000 ($FB43) to reset the timer. If
. Y is 0, we have a count of 65535 which
means we can't find a sync mark so abort
by loading .A with $02 and JMP to FMTERR</p>
</td></tr>
				<tr><td></td><td class="fit">FB49</td>
				<td>10 11</td>
				<td class="fit">BPL $FB5C</td></tr>
				<tr><td></td><td class="fit">FB4B</td>
				<td>AD 0D 18</td>
				<td class="fit">LDA $180D</td></tr>
				<tr><td></td><td class="fit">FB4E</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">FB4F</td>
				<td>10 F5</td>
				<td class="fit">BPL $FB46</td></tr>
				<tr><td></td><td class="fit">FB51</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">FB52</td>
				<td>D0 EF</td>
				<td class="fit">BNE $FB43</td></tr>
				<tr><td></td><td class="fit">FB54</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FB55</td>
				<td>D0 EC</td>
				<td class="fit">BNE $FB43</td></tr>
				<tr><td></td><td class="fit">FB57</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td></tr>
				<tr><td></td><td class="fit">FB59</td>
				<td>4C D3 FD</td>
				<td class="fit">JMP $FDD3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">F005</td><td class="fit">FB5C</td>
				<td>86 71</td>
				<td class="fit">STX $71</td><td rowspan="4"><p>Found a SYNC so store the non-sync times
in T2 ($71/2). Reset .X and .Y to $00
and begin timing the SYNC area.</p>
</td></tr>
				<tr><td></td><td class="fit">FB5E</td>
				<td>84 72</td>
				<td class="fit">STY $72</td></tr>
				<tr><td></td><td class="fit">FB60</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
				<tr><td></td><td class="fit">FB62</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">F006</td><td class="fit">FB64</td>
				<td>AD 04 18</td>
				<td class="fit">LDA $1804</td><td rowspan="1"><p>Reset interrupt flags to start the timer</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Loop to time the SYNC area</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">F007</td><td class="fit">FB67</td>
				<td>2C 00 1C</td>
				<td class="fit">BIT $1C00</td><td rowspan="11"><p>Check if not-sync here yet. If here, go
to F009 ($FB7D). If still have a SYNC,
check IFR1 ($1804) to see if timer has
timed out. If not time yet, branch back
to F007 ($FB67). If time up, increment
.X by 1 (and .Y if .X=0) and loop back
to F006 ($FB64) to reset the timer. If
. Y is 0, we have a count of 65535 which
means we can't find no-SYNC. So abort:
load .A with a $02 and JMP to FMTERR</p>
</td></tr>
				<tr><td></td><td class="fit">FB6A</td>
				<td>30 11</td>
				<td class="fit">BMI $FB7D</td></tr>
				<tr><td></td><td class="fit">FB6C</td>
				<td>AD 0D 18</td>
				<td class="fit">LDA $180D</td></tr>
				<tr><td></td><td class="fit">FB6F</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">FB70</td>
				<td>10 F5</td>
				<td class="fit">BPL $FB67</td></tr>
				<tr><td></td><td class="fit">FB72</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">FB73</td>
				<td>D0 EF</td>
				<td class="fit">BNE $FB64</td></tr>
				<tr><td></td><td class="fit">FB75</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FB76</td>
				<td>D0 EC</td>
				<td class="fit">BNE $FB64</td></tr>
				<tr><td></td><td class="fit">FB78</td>
				<td>A9 02</td>
				<td class="fit">LDA #$02</td></tr>
				<tr><td></td><td class="fit">FB7A</td>
				<td>4C D3 FD</td>
				<td class="fit">JMP $FDD3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">F009</td><td class="fit">FB7D</td>
				<td>38</td>
				<td class="fit">SEC</td><td rowspan="32"><p>Found non-sync. Calculate the difference
between the SYNC and non-sync times. If
the difference is less than 4, branch to
COUNT ($FBB6). If the difference is more
than 4, make NUM ($0261/2) the average
of the two times and branch to TOPP
($FB0C) to try again.</p>
</td></tr>
				<tr><td></td><td class="fit">FB7E</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">FB7F</td>
				<td>E5 71</td>
				<td class="fit">SBC $71</td></tr>
				<tr><td></td><td class="fit">FB81</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">FB82</td>
				<td>85 70</td>
				<td class="fit">STA $70</td></tr>
				<tr><td></td><td class="fit">FB84</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">FB85</td>
				<td>E5 72</td>
				<td class="fit">SBC $72</td></tr>
				<tr><td></td><td class="fit">FB87</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">FB88</td>
				<td>85 71</td>
				<td class="fit">STA $71</td></tr>
				<tr><td></td><td class="fit">FB8A</td>
				<td>10 0B</td>
				<td class="fit">BPL $FB97</td></tr>
				<tr><td></td><td class="fit">FB8C</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td></tr>
				<tr><td></td><td class="fit">FB8E</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">FB8F</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">FB90</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td></tr>
				<tr><td></td><td class="fit">FB92</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">FB93</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">FB94</td>
				<td>D0 01</td>
				<td class="fit">BNE $FB97</td></tr>
				<tr><td></td><td class="fit">FB96</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FB97</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">FB98</td>
				<td>D0 04</td>
				<td class="fit">BNE $FB9E</td></tr>
				<tr><td></td><td class="fit">FB9A</td>
				<td>E0 04</td>
				<td class="fit">CPX #$04</td></tr>
				<tr><td></td><td class="fit">FB9C</td>
				<td>90 18</td>
				<td class="fit">BCC $FBB6</td></tr>
				<tr><td></td><td class="fit">FB9E</td>
				<td>06 70</td>
				<td class="fit">ASL $70</td></tr>
				<tr><td></td><td class="fit">FBA0</td>
				<td>26 71</td>
				<td class="fit">ROL $71</td></tr>
				<tr><td></td><td class="fit">FBA2</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FBA3</td>
				<td>A5 70</td>
				<td class="fit">LDA $70</td></tr>
				<tr><td></td><td class="fit">FBA5</td>
				<td>6D 21 06</td>
				<td class="fit">ADC $0621</td></tr>
				<tr><td></td><td class="fit">FBA8</td>
				<td>8D 21 06</td>
				<td class="fit">STA $0621</td></tr>
				<tr><td></td><td class="fit">FBAB</td>
				<td>A5 71</td>
				<td class="fit">LDA $71</td></tr>
				<tr><td></td><td class="fit">FBAD</td>
				<td>6D 22 06</td>
				<td class="fit">ADC $0622</td></tr>
				<tr><td></td><td class="fit">FBB0</td>
				<td>8D 22 06</td>
				<td class="fit">STA $0622</td></tr>
				<tr><td></td><td class="fit">FBB3</td>
				<td>4C 0C FB</td>
				<td class="fit">JMP $FB0C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">COUNT</td><td class="fit">FBB6</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td><td rowspan="3"><p>Set .X and .Y to $00 to prepare to count
the number of characters in the non-sync
area.</p>
</td></tr>
				<tr><td></td><td class="fit">FBB8</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">FBBA</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CNT10</td><td class="fit">FBBB</td>
				<td>AD 00 1C</td>
				<td class="fit">LDA $1C00</td><td rowspan="10"><p>Test bit 7 of DSKCNT ($1C00) to see if
SYNC is here yet. If SYNC here, branch
to CNT20 ($FBCE). If not, test the timer
If not time, branch back to CNT10. If
time for one character is up, increment
.X (and .Y if needed). clear the timer
flag (.V) and branch back to CNT10. If
.Y=0 we have a count of 65535 so abort:
load .A with $03 &amp; JMP to FMTERR ($FDD3)</p>
</td></tr>
				<tr><td></td><td class="fit">FBBE</td>
				<td>10 0E</td>
				<td class="fit">BPL $FBCE</td></tr>
				<tr><td></td><td class="fit">FBC0</td>
				<td>50 F9</td>
				<td class="fit">BVC $FBBB</td></tr>
				<tr><td></td><td class="fit">FBC2</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FBC3</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">FBC4</td>
				<td>D0 F5</td>
				<td class="fit">BNE $FBBB</td></tr>
				<tr><td></td><td class="fit">FBC6</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FBC7</td>
				<td>D0 F2</td>
				<td class="fit">BNE $FBBB</td></tr>
				<tr><td></td><td class="fit">FBC9</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td></tr>
				<tr><td></td><td class="fit">FBCB</td>
				<td>4C D3 FD</td>
				<td class="fit">JMP $FDD3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CNT20</td><td class="fit">FBCE</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="9"><p>Store the byte count (count*2) in TRAL
($0624/5) and turn off the 6522' s timer</p>
</td></tr>
				<tr><td></td><td class="fit">FBCF</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">FBD0</td>
				<td>8D 25 06</td>
				<td class="fit">STA $0625</td></tr>
				<tr><td></td><td class="fit">FBD3</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">FBD4</td>
				<td>2A</td>
				<td class="fit">ROL</td></tr>
				<tr><td></td><td class="fit">FBD5</td>
				<td>8D 24 06</td>
				<td class="fit">STA $0624</td></tr>
				<tr><td></td><td class="fit">FBD8</td>
				<td>A9 BF</td>
				<td class="fit">LDA #$BF</td></tr>
				<tr><td></td><td class="fit">FBDA</td>
				<td>2D 0B 18</td>
				<td class="fit">AND $180B</td></tr>
				<tr><td></td><td class="fit">FBDD</td>
				<td>8D 0B 18</td>
				<td class="fit">STA $180B</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><p>Calculate the total number of bytes we
need to record on this track:</p>
<pre><code> (282 chr/sect x 5/4 x tsect)</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DS08</td><td class="fit">FBE0</td>
				<td>A9 66</td>
				<td class="fit">LDA #$66</td><td rowspan="47"><p>Subtract this from the total we found
and divide by the number of sectors to
get the size of the gap between sectors.
If the calculated gap is less than 4, it
is too small so load .A with $05 and JMP
to FMTERR ($FDD3). If it is big enough,
store inter-sector gap in DTRCK ($0626) .</p>
</td></tr>
				<tr><td></td><td class="fit">FBE2</td>
				<td>8D 26 06</td>
				<td class="fit">STA $0626</td></tr>
				<tr><td></td><td class="fit">FBE5</td>
				<td>A6 43</td>
				<td class="fit">LDX $43</td></tr>
				<tr><td></td><td class="fit">FBE7</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">FBE9</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">FBEA</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FBEB</td>
				<td>6D 26 06</td>
				<td class="fit">ADC $0626</td></tr>
				<tr><td></td><td class="fit">FBEE</td>
				<td>90 01</td>
				<td class="fit">BCC $FBF1</td></tr>
				<tr><td></td><td class="fit">FBF0</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FBF1</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FBF2</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FBF3</td>
				<td>D0 F5</td>
				<td class="fit">BNE $FBEA</td></tr>
				<tr><td></td><td class="fit">FBF5</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td></tr>
				<tr><td></td><td class="fit">FBF7</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">FBF8</td>
				<td>69 00</td>
				<td class="fit">ADC #$00</td></tr>
				<tr><td></td><td class="fit">FBFA</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FBFB</td>
				<td>6D 25 06</td>
				<td class="fit">ADC $0625</td></tr>
				<tr><td></td><td class="fit">FBFE</td>
				<td>B0 03</td>
				<td class="fit">BCS $FC03</td></tr>
				<tr><td></td><td class="fit">FC00</td>
				<td>CE 24 06</td>
				<td class="fit">DEC $0624</td></tr>
				<tr><td></td><td class="fit">FC03</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">FC04</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">FC05</td>
				<td>49 FF</td>
				<td class="fit">EOR #$FF</td></tr>
				<tr><td></td><td class="fit">FC07</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">FC08</td>
				<td>69 00</td>
				<td class="fit">ADC #$00</td></tr>
				<tr><td></td><td class="fit">FC0A</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FC0B</td>
				<td>6D 24 06</td>
				<td class="fit">ADC $0624</td></tr>
				<tr><td></td><td class="fit">FC0E</td>
				<td>10 05</td>
				<td class="fit">BPL $FC15</td></tr>
				<tr><td></td><td class="fit">FC10</td>
				<td>A9 04</td>
				<td class="fit">LDA #$04</td></tr>
				<tr><td></td><td class="fit">FC12</td>
				<td>4C D3 FD</td>
				<td class="fit">JMP $FDD3</td></tr>
				<tr><td></td><td class="fit">FC15</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">FC16</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">FC17</td>
				<td>A2 00</td>
				<td class="fit">LDX #$00</td></tr>
				<tr><td></td><td class="fit">FC19</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">FC1A</td>
				<td>E5 43</td>
				<td class="fit">SBC $43</td></tr>
				<tr><td></td><td class="fit">FC1C</td>
				<td>B0 03</td>
				<td class="fit">BCS $FC21</td></tr>
				<tr><td></td><td class="fit">FC1E</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">FC1F</td>
				<td>30 03</td>
				<td class="fit">BMI $FC24</td></tr>
				<tr><td></td><td class="fit">FC21</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">FC22</td>
				<td>D0 F5</td>
				<td class="fit">BNE $FC19</td></tr>
				<tr><td></td><td class="fit">FC24</td>
				<td>8E 26 06</td>
				<td class="fit">STX $0626</td></tr>
				<tr><td></td><td class="fit">FC27</td>
				<td>E0 04</td>
				<td class="fit">CPX #$04</td></tr>
				<tr><td></td><td class="fit">FC29</td>
				<td>B0 05</td>
				<td class="fit">BCS $FC30</td></tr>
				<tr><td></td><td class="fit">FC2B</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td></tr>
				<tr><td></td><td class="fit">FC2D</td>
				<td>4C D3 FD</td>
				<td class="fit">JMP $FDD3</td></tr>
				<tr><td></td><td class="fit">FC30</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FC31</td>
				<td>65 43</td>
				<td class="fit">ADC $43</td></tr>
				<tr><td></td><td class="fit">FC33</td>
				<td>8D 27 06</td>
				<td class="fit">STA $0627</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC36</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Set sector counter SECT ($0628) to $00.</p>
</td></tr>
				<tr><td></td><td class="fit">FC38</td>
				<td>8D 28 06</td>
				<td class="fit">STA $0628</td></tr>
				<tr><td></td><td class="fit">FC3B</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
				<tr><td></td><td class="fit">FC3D</td>
				<td>A6 3D</td>
				<td class="fit">LDX $3D</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MAK10</td><td class="fit">FC3F</td>
				<td>A5 39</td>
				<td class="fit">LDA $39</td><td rowspan="2"><p>Loop to create sector header images in
buffer ($0300+) .Y is the pointer
into the buffer (0 for sect #1) .
Move sector ID code from HBID ($39) to
$0300+Y ($0300 for #1) .</p>
</td></tr>
				<tr><td></td><td class="fit">FC41</td>
				<td>99 00 03</td>
				<td class="fit">STA $0300,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC44</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="4"><p>Increment .Y twice to skip the checksum
and move sector number from SECT ($0628)
to $0300+Y ($0302 for sector #1) .</p>
</td></tr>
				<tr><td></td><td class="fit">FC45</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FC46</td>
				<td>AD 28 06</td>
				<td class="fit">LDA $0628</td></tr>
				<tr><td></td><td class="fit">FC49</td>
				<td>99 00 03</td>
				<td class="fit">STA $0300,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC4C</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y and move the track number
from FTNUM ($51) to $0300+Y ($0303 for
sector #1)</p>
</td></tr>
				<tr><td></td><td class="fit">FC4D</td>
				<td>A5 51</td>
				<td class="fit">LDA $51</td></tr>
				<tr><td></td><td class="fit">FC4F</td>
				<td>99 00 03</td>
				<td class="fit">STA $0300,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC52</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y and move ID2 from DSKID+1
($13) to $0300+Y ($0304 for sector #1).</p>
</td></tr>
				<tr><td></td><td class="fit">FC53</td>
				<td>B5 13</td>
				<td class="fit">LDA $13,X</td></tr>
				<tr><td></td><td class="fit">FC55</td>
				<td>99 00 03</td>
				<td class="fit">STA $0300,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC58</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y and move ID1 from DSKID
($12) to $0300+Y ($0305 for sector #1).</p>
</td></tr>
				<tr><td></td><td class="fit">FC59</td>
				<td>B5 12</td>
				<td class="fit">LDA $12,X</td></tr>
				<tr><td></td><td class="fit">FC5B</td>
				<td>99 00 03</td>
				<td class="fit">STA $0300,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC5E</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="3"><p>Increment .Y and store $0F in $0300+Y
($0306 for #1) as off byte.</p>
</td></tr>
				<tr><td></td><td class="fit">FC5F</td>
				<td>A9 0F</td>
				<td class="fit">LDA #$0F</td></tr>
				<tr><td></td><td class="fit">FC61</td>
				<td>99 00 03</td>
				<td class="fit">STA $0300,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC64</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="2"><p>Increment .Y and store $0F in $0300+Y
($0307 for #1) as off byte.</p>
</td></tr>
				<tr><td></td><td class="fit">FC65</td>
				<td>99 00 03</td>
				<td class="fit">STA $0300,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC68</td>
				<td>C8</td>
				<td class="fit">INY</td><td rowspan="7"><p>Increment .Y. calculate the header blk
checksum and store it in $02F9+Y
($0302 for sector #1)</p>
</td></tr>
				<tr><td></td><td class="fit">FC69</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">FC6B</td>
				<td>59 FA 02</td>
				<td class="fit">EOR $02FA,Y</td></tr>
				<tr><td></td><td class="fit">FC6E</td>
				<td>59 FB 02</td>
				<td class="fit">EOR $02FB,Y</td></tr>
				<tr><td></td><td class="fit">FC71</td>
				<td>59 FC 02</td>
				<td class="fit">EOR $02FC,Y</td></tr>
				<tr><td></td><td class="fit">FC74</td>
				<td>59 FD 02</td>
				<td class="fit">EOR $02FD,Y</td></tr>
				<tr><td></td><td class="fit">FC77</td>
				<td>99 F9 02</td>
				<td class="fit">STA $02F9,Y</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC7A</td>
				<td>EE 28 06</td>
				<td class="fit">INC $0628</td><td rowspan="4"><p>Increment SECT ($0628) and compare it to
number of sectors on track SECTR ($43)</p>
</td></tr>
				<tr><td></td><td class="fit">FC7D</td>
				<td>AD 28 06</td>
				<td class="fit">LDA $0628</td></tr>
				<tr><td></td><td class="fit">FC80</td>
				<td>C5 43</td>
				<td class="fit">CMP $43</td></tr>
				<tr><td></td><td class="fit">FC82</td>
				<td>90 BB</td>
				<td class="fit">BCC $FC3F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC84</td>
				<td>98</td>
				<td class="fit">TYA</td><td rowspan="2"><p>If done all images. save the number of
sectors on this track onto the stack.
Increment .X (becomes $01) and transfer
it to .A (dummy data character) .</p>
</td></tr>
				<tr><td></td><td class="fit">FC85</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><pre><code>Note: .X should really be $00. Since it
      is $01, all the data blocks on a
      diskette formatted on a 1541 drive
      have 1 garbage character followed
      by 255 $01's rather than 256 $00's</code></pre>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CRTDAT</td><td class="fit">FC86</td>
				<td>E8</td>
				<td class="fit">INX</td><td rowspan="5"><p>Loop to put 255 dummy data bytes ($01 's)
into data buffer #2 ($0500+)</p>
</td></tr>
				<tr><td></td><td class="fit">FC87</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">FC88</td>
				<td>9D 00 05</td>
				<td class="fit">STA $0500,X</td></tr>
				<tr><td></td><td class="fit">FC8B</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">FC8C</td>
				<td>D0 FA</td>
				<td class="fit">BNE $FC88</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC8E</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td><td rowspan="3"><p>Set the buffer pointer BUFPNT ($30/1) to
point to the header block images ($0300)
and JSR to FBTOG($FE30) to convert the
header images to a GCR write image with
no header block ID code.</p>
</td></tr>
				<tr><td></td><td class="fit">FC90</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">FC92</td>
				<td>20 30 FE</td>
				<td class="fit">JSR $FE30</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC95</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="5"><p>Pull # of sectors from stack. transfer
the value to .Y, and JSR to MOVUP($FDE5)
to move the GCR header image stored in
in buffer #0 69 bytes up in memory. Then
JSR to MOVOVR ($FDF5) to move the 69
header image bytes from the overflow
buffer into the low end of buffer #0.</p>
</td></tr>
				<tr><td></td><td class="fit">FC96</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">FC97</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">FC98</td>
				<td>20 E5 FD</td>
				<td class="fit">JSR $FDE5</td></tr>
				<tr><td></td><td class="fit">FC9B</td>
				<td>20 F5 FD</td>
				<td class="fit">JSR $FDF5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FC9E</td>
				<td>A9 05</td>
				<td class="fit">LDA #$05</td><td rowspan="5"><p>Set the buffer pointer BUFPNT ($30/1) to
point to the dummy data block. JSR to
CHKBLK ($F5E9) to calculate the data blk
checksum, store it in CHKSUM, and JSR to
BINGCR ($F78F) to convert the dummy data
block into its GCR write image.</p>
</td></tr>
				<tr><td></td><td class="fit">FCA0</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">FCA2</td>
				<td>20 E9 F5</td>
				<td class="fit">JSR $F5E9</td></tr>
				<tr><td></td><td class="fit">FCA5</td>
				<td>85 3A</td>
				<td class="fit">STA $3A</td></tr>
				<tr><td></td><td class="fit">FCA7</td>
				<td>20 8F F7</td>
				<td class="fit">JSR $F78F</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FCAA</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="2"><p>Begin formatting the track now!
Set the pointer to the header GCR image
HDRPNT ($32) to $00 so it points to the
start of the first header image.</p>
</td></tr>
				<tr><td></td><td class="fit">FCAC</td>
				<td>85 32</td>
				<td class="fit">STA $32</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FCAE</td>
				<td>20 0E FE</td>
				<td class="fit">JSR $FE0E</td><td rowspan="1"><p>JSR to CLEAR ($FE0E) to wipe the track.</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTSYN</td><td class="fit">FCB1</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="3"><p>Store $FF in PORT2 ($1C01) to be ready
to write a sync character. Load .X with
$05 (5 SYNC'S coming up!)</p>
</td></tr>
				<tr><td></td><td class="fit">FCB3</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FCB6</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTS10</td><td class="fit">FCB8</td>
				<td>50 FE</td>
				<td class="fit">BVC $FCB8</td><td rowspan="4"><p>Write out 5 sync marks</p>
</td></tr>
				<tr><td></td><td class="fit">FCBA</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FCBB</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FCBC</td>
				<td>D0 FA</td>
				<td class="fit">BNE $FCB8</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FCBE</td>
				<td>A2 0A</td>
				<td class="fit">LDX #$0A</td><td rowspan="2"><p>Initialize .X to $0A (output 10 bytes)
and set .Y with the value from HDRPNT
($32) so it points to the start of the
header GCR image.</p>
</td></tr>
				<tr><td></td><td class="fit">FCC0</td>
				<td>A4 32</td>
				<td class="fit">LDY $32</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTS20</td><td class="fit">FCC2</td>
				<td>50 FE</td>
				<td class="fit">BVC $FCC2</td><td rowspan="7"><p>Write out the 10 header characters</p>
</td></tr>
				<tr><td></td><td class="fit">FCC4</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FCC5</td>
				<td>B9 00 03</td>
				<td class="fit">LDA $0300,Y</td></tr>
				<tr><td></td><td class="fit">FCC8</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FCCB</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FCCC</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FCCD</td>
				<td>D0 F3</td>
				<td class="fit">BNE $FCC2</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FCCF</td>
				<td>A2 08</td>
				<td class="fit">LDX #$08</td><td rowspan="1"><p>Load .X with $08 (HARD SET VALUE!)
NOTE: This means you can not easily
change the header gap size!</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTS30</td><td class="fit">FCD1</td>
				<td>50 FE</td>
				<td class="fit">BVC $FCD1</td><td rowspan="6"><p>Loop to output eight $55 bytes to form
the header gap (gapl) .</p>
</td></tr>
				<tr><td></td><td class="fit">FCD3</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FCD4</td>
				<td>A9 55</td>
				<td class="fit">LDA #$55</td></tr>
				<tr><td></td><td class="fit">FCD6</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FCD9</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FCDA</td>
				<td>D0 F5</td>
				<td class="fit">BNE $FCD1</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FCDC</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="2"><p>Store $FF in PORT2 ($1C01) to be ready
to write a sync mark. Load .X with $05
(5 SYNC's coming up!)</p>
</td></tr>
				<tr><td></td><td class="fit">FCDE</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">DBSYNC</td><td class="fit">FCE0</td>
				<td>50 FE</td>
				<td class="fit">BVC $FCE0</td><td rowspan="5"><p>Write out 5 sync marks</p>
</td></tr>
				<tr><td></td><td class="fit">FCE2</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FCE3</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FCE6</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FCE7</td>
				<td>D0 F7</td>
				<td class="fit">BNE $FCE0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FCE9</td>
				<td>A2 BB</td>
				<td class="fit">LDX #$BB</td><td rowspan="1"><p>Initialize .X to $BB to point to the
first byte of the overflow buffer (the
start of the dummy data block)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTS40</td><td class="fit">FCEB</td>
				<td>50 FE</td>
				<td class="fit">BVC $FCEB</td><td rowspan="7"><p>Loop to write out the 69 GCR bytes in
the overflow buffer</p>
</td></tr>
				<tr><td></td><td class="fit">FCED</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FCEE</td>
				<td>BD 00 01</td>
				<td class="fit">LDA $0100,X</td></tr>
				<tr><td></td><td class="fit">FCF1</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FCF4</td>
				<td>E8</td>
				<td class="fit">INX</td></tr>
				<tr><td></td><td class="fit">FCF5</td>
				<td>D0 F4</td>
				<td class="fit">BNE $FCEB</td></tr>
				<tr><td></td><td class="fit">FCF7</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTS50</td><td class="fit">FCF9</td>
				<td>50 FE</td>
				<td class="fit">BVC $FCF9</td><td rowspan="6"><p>Loop to write out the 256 GCR bytes in
data buffer #2 ($0500+)</p>
</td></tr>
				<tr><td></td><td class="fit">FCFB</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FCFC</td>
				<td>B1 30</td>
				<td class="fit">LDA ($30),Y</td></tr>
				<tr><td></td><td class="fit">FCFE</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FD01</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FD02</td>
				<td>D0 F5</td>
				<td class="fit">BNE $FCF9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD04</td>
				<td>A9 55</td>
				<td class="fit">LDA #$55</td><td rowspan="2"><p>Load .A with $55 and .X with the tail
(inter-sector) gap from DTRCK ($0626)</p>
</td></tr>
				<tr><td></td><td class="fit">FD06</td>
				<td>AE 26 06</td>
				<td class="fit">LDX $0626</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WGP2</td><td class="fit">FD09</td>
				<td>50 FE</td>
				<td class="fit">BVC $FD09</td><td rowspan="5"><p>Loop to write .X $55 characters to
form the tail (inter-sector) gap.</p>
</td></tr>
				<tr><td></td><td class="fit">FD0B</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FD0C</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
				<tr><td></td><td class="fit">FD0F</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FD10</td>
				<td>D0 F7</td>
				<td class="fit">BNE $FD09</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD12</td>
				<td>A5 32</td>
				<td class="fit">LDA $32</td><td rowspan="4"><p>Advance the header pointer HDRPNT ($32/3 )
by 10 so it points to the start of the
next header image.</p>
</td></tr>
				<tr><td></td><td class="fit">FD14</td>
				<td>18</td>
				<td class="fit">CLC</td></tr>
				<tr><td></td><td class="fit">FD15</td>
				<td>69 0A</td>
				<td class="fit">ADC #$0A</td></tr>
				<tr><td></td><td class="fit">FD17</td>
				<td>85 32</td>
				<td class="fit">STA $32</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD19</td>
				<td>CE 28 06</td>
				<td class="fit">DEC $0628</td><td rowspan="7"><p>Decrement the sector counter SECT ($0628)
by l and test to see if any more sectors
to do. If more, branch back to WRTSYN
to do the next sector. If no more, wait
for the last byte to be written out and
then JSR to KILL ($FE00) to switch to
read mode.</p>
</td></tr>
				<tr><td></td><td class="fit">FD1C</td>
				<td>D0 93</td>
				<td class="fit">BNE $FCB1</td></tr>
				<tr><td></td><td class="fit">FD1E</td>
				<td>50 FE</td>
				<td class="fit">BVC $FD1E</td></tr>
				<tr><td></td><td class="fit">FD20</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FD21</td>
				<td>50 FE</td>
				<td class="fit">BVC $FD21</td></tr>
				<tr><td></td><td class="fit">FD23</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FD24</td>
				<td>20 00 FE</td>
				<td class="fit">JSR $FE00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD27</td>
				<td>A9 C8</td>
				<td class="fit">LDA #$C8</td><td rowspan="2"><p>Formatting done. Verify it!
Set TRYS ($0623) to $C8 to limit the
number of attempts to verify to 200.</p>
</td></tr>
				<tr><td></td><td class="fit">FD29</td>
				<td>8D 23 06</td>
				<td class="fit">STA $0623</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">COMP</td><td class="fit">FD2C</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="6"><p>Set BUFPNT ($30/1) to point to the start
of the headers in buffer #0 ($0300) and
set SECT ($0628) with the # of sectors
on this track from SECTR ($43) .</p>
</td></tr>
				<tr><td></td><td class="fit">FD2E</td>
				<td>85 30</td>
				<td class="fit">STA $30</td></tr>
				<tr><td></td><td class="fit">FD30</td>
				<td>A9 03</td>
				<td class="fit">LDA #$03</td></tr>
				<tr><td></td><td class="fit">FD32</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
				<tr><td></td><td class="fit">FD34</td>
				<td>A5 43</td>
				<td class="fit">LDA $43</td></tr>
				<tr><td></td><td class="fit">FD36</td>
				<td>8D 28 06</td>
				<td class="fit">STA $0628</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMPR10</td><td class="fit">FD39</td>
				<td>20 56 F5</td>
				<td class="fit">JSR $F556</td><td rowspan="3"><p>JSR to SYNC($F556) to wait for a SYNC
mark. Once found. set .X to $0A (there
are 9 header characters to read) and .Y
$00 (point to character in header image)</p>
</td></tr>
				<tr><td></td><td class="fit">FD3C</td>
				<td>A2 0A</td>
				<td class="fit">LDX #$0A</td></tr>
				<tr><td></td><td class="fit">FD3E</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMPR15</td><td class="fit">FD40</td>
				<td>50 FE</td>
				<td class="fit">BVC $FD40</td><td rowspan="8"><p>Loop to read header bytes and compare
them to the image in the buffer. If any
byte doesn't match, branch to CMPR20.</p>
</td></tr>
				<tr><td></td><td class="fit">FD42</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FD43</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
				<tr><td></td><td class="fit">FD46</td>
				<td>D1 30</td>
				<td class="fit">CMP ($30),Y</td></tr>
				<tr><td></td><td class="fit">FD48</td>
				<td>D0 0E</td>
				<td class="fit">BNE $FD58</td></tr>
				<tr><td></td><td class="fit">FD4A</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FD4B</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FD4C</td>
				<td>D0 F2</td>
				<td class="fit">BNE $FD40</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD4E</td>
				<td>18</td>
				<td class="fit">CLC</td><td rowspan="4"><p>Header reads back OK so add 10 to BUFPNT
($30) so it points to next header image.</p>
</td></tr>
				<tr><td></td><td class="fit">FD4F</td>
				<td>A5 30</td>
				<td class="fit">LDA $30</td></tr>
				<tr><td></td><td class="fit">FD51</td>
				<td>69 0A</td>
				<td class="fit">ADC #$0A</td></tr>
				<tr><td></td><td class="fit">FD53</td>
				<td>85 30</td>
				<td class="fit">STA $30</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD55</td>
				<td>4C 62 FD</td>
				<td class="fit">JMP $FD62</td><td rowspan="1"><p>JMP to TSTDAT ($FD62)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CMPR20</td><td class="fit">FD58</td>
				<td>CE 23 06</td>
				<td class="fit">DEC $0623</td><td rowspan="4"><p>Bad verify. Decrement TRYS ($0623). If
more attempts left, branch back to COMP
($FD2C) to try again. If we have tried
200 times, abort: load .A with $06 and
JMP to FMTERR ($FDD3)</p>
</td></tr>
				<tr><td></td><td class="fit">FD5B</td>
				<td>D0 CF</td>
				<td class="fit">BNE $FD2C</td></tr>
				<tr><td></td><td class="fit">FD5D</td>
				<td>A9 06</td>
				<td class="fit">LDA #$06</td></tr>
				<tr><td></td><td class="fit">FD5F</td>
				<td>4C D3 FD</td>
				<td class="fit">JMP $FDD3</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TSTDAT</td><td class="fit">FD62</td>
				<td>20 56 F5</td>
				<td class="fit">JSR $F556</td><td rowspan="2"><p>Header OK so check the data block.
JSR to SYNC ($F556) to wait for the data
block SYNC mark. Once found, set .Y to
$BB to point to the start of the data
block image in the overflow buffer</p>
</td></tr>
				<tr><td></td><td class="fit">FD65</td>
				<td>A0 BB</td>
				<td class="fit">LDY #$BB</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TST05</td><td class="fit">FD67</td>
				<td>50 FE</td>
				<td class="fit">BVC $FD67</td><td rowspan="7"><p>Loop to read and verify the 69 GCR bytes
in the overflow buffer. If no match,
branch to CMPR20 ($FD58) and try again.</p>
</td></tr>
				<tr><td></td><td class="fit">FD69</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FD6A</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
				<tr><td></td><td class="fit">FD6D</td>
				<td>D9 00 01</td>
				<td class="fit">CMP $0100,Y</td></tr>
				<tr><td></td><td class="fit">FD70</td>
				<td>D0 E6</td>
				<td class="fit">BNE $FD58</td></tr>
				<tr><td></td><td class="fit">FD72</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FD73</td>
				<td>D0 F2</td>
				<td class="fit">BNE $FD67</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD75</td>
				<td>A2 FC</td>
				<td class="fit">LDX #$FC</td><td rowspan="1"><p>Overflow buffer OK so set .X to $FC
(255-3; don't bother checking the OFF
bytes at the end) .</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">TST10</td><td class="fit">FD77</td>
				<td>50 FE</td>
				<td class="fit">BVC $FD77</td><td rowspan="8"><p>Loop to read and verify the 253 GCR
bytes in data buffer #3. If no match,
branch to CMPR20 ($FD58) and try again.</p>
</td></tr>
				<tr><td></td><td class="fit">FD79</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FD7A</td>
				<td>AD 01 1C</td>
				<td class="fit">LDA $1C01</td></tr>
				<tr><td></td><td class="fit">FD7D</td>
				<td>D9 00 05</td>
				<td class="fit">CMP $0500,Y</td></tr>
				<tr><td></td><td class="fit">FD80</td>
				<td>D0 D6</td>
				<td class="fit">BNE $FD58</td></tr>
				<tr><td></td><td class="fit">FD82</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FD83</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FD84</td>
				<td>D0 F1</td>
				<td class="fit">BNE $FD77</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FD86</td>
				<td>CE 28 06</td>
				<td class="fit">DEC $0628</td><td rowspan="7"><p>Decrement the sector counter in SECT
($0628) by 1 and test to see if any more
to do. If more, branch back to CMPR10 to
do next sector. If no more, increment
the track counter FTNUM ($51) and test
if there are any more tracks to do. If
all done, branch to FMTEND ($FD96). If
more to do, JMP to END ($F99C) to step
the head to the next track.</p>
</td></tr>
				<tr><td></td><td class="fit">FD89</td>
				<td>D0 AE</td>
				<td class="fit">BNE $FD39</td></tr>
				<tr><td></td><td class="fit">FD8B</td>
				<td>E6 51</td>
				<td class="fit">INC $51</td></tr>
				<tr><td></td><td class="fit">FD8D</td>
				<td>A5 51</td>
				<td class="fit">LDA $51</td></tr>
				<tr><td></td><td class="fit">FD8F</td>
				<td>C9 24</td>
				<td class="fit">CMP #$24</td></tr>
				<tr><td></td><td class="fit">FD91</td>
				<td>B0 03</td>
				<td class="fit">BCS $FD96</td></tr>
				<tr><td></td><td class="fit">FD93</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FMTEND</td><td class="fit">FD96</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="6"><p>Set the track counter, FTNUM ($51) to
$FF and the GCRFLG ($50) to 0. To flag
a successful completion load .A with $01
and JMP to ERRR ($F969).
Formatting and Verification Completed!</p>
</td></tr>
				<tr><td></td><td class="fit">FD98</td>
				<td>85 51</td>
				<td class="fit">STA $51</td></tr>
				<tr><td></td><td class="fit">FD9A</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">FD9C</td>
				<td>85 50</td>
				<td class="fit">STA $50</td></tr>
				<tr><td></td><td class="fit">FD9E</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">FDA0</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Formatting Subroutines</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SYNCLR</td><td class="fit">FDA3</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td><td rowspan="4"><p>Wipe track by writing 40*256 SYNC marks
Set bits 6 &amp; 7 of the 6522' s peripheral
control register PCR2 ($1C0C). This
latches the signal on the CB2 line.</p>
</td></tr>
				<tr><td></td><td class="fit">FDA6</td>
				<td>29 1F</td>
				<td class="fit">AND #$1F</td></tr>
				<tr><td></td><td class="fit">FDA8</td>
				<td>09 C0</td>
				<td class="fit">ORA #$C0</td></tr>
				<tr><td></td><td class="fit">FDAA</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FDAD</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="3"><p>Store $FF in the data direction register
DDRA2 ($1C03) to make PORT A an output-
port and put $FF in the data port DATA2
($1C01) to produce SYNC characters.</p>
</td></tr>
				<tr><td></td><td class="fit">FDAF</td>
				<td>8D 03 1C</td>
				<td class="fit">STA $1C03</td></tr>
				<tr><td></td><td class="fit">FDB2</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FDB5</td>
				<td>A2 28</td>
				<td class="fit">LDX #$28</td><td rowspan="2"><p>Initialize .X to $28 (hi counter) and
.Y to $00 (lo counter).</p>
</td></tr>
				<tr><td></td><td class="fit">FDB7</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SYC10</td><td class="fit">FDB9</td>
				<td>50 FE</td>
				<td class="fit">BVC $FDB9</td><td rowspan="6"><p>Loop to write out 40*256 SYNC marks
using .X &amp; .Y as counters</p>
</td></tr>
				<tr><td></td><td class="fit">FDBB</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FDBC</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">FDBD</td>
				<td>D0 FA</td>
				<td class="fit">BNE $FDB9</td></tr>
				<tr><td></td><td class="fit">FDBF</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FDC0</td>
				<td>D0 F7</td>
				<td class="fit">BNE $FDB9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FDC2</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>RTS -<em>- WARNING WRITE MODE LEFT ON -</em>-</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTNUM</td><td class="fit">FDC3</td>
				<td>AE 21 06</td>
				<td class="fit">LDX $0621</td><td rowspan="2"><p>Write out NUM ($0621/2) bytes
Load .X with the LSB and .Y with the
MSB of NUM ($0621/2) .</p>
</td></tr>
				<tr><td></td><td class="fit">FDC6</td>
				<td>AC 22 06</td>
				<td class="fit">LDY $0622</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">WRTN10</td><td class="fit">FDC9</td>
				<td>50 FE</td>
				<td class="fit">BVC $FDC9</td><td rowspan="6"><p>Loop to write out what ever is in the
data port DATA2 ($1C03) NUM times using
.X and .Y as counters</p>
</td></tr>
				<tr><td></td><td class="fit">FDCB</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FDCC</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FDCD</td>
				<td>D0 FA</td>
				<td class="fit">BNE $FDC9</td></tr>
				<tr><td></td><td class="fit">FDCF</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">FDD0</td>
				<td>10 F7</td>
				<td class="fit">BPL $FDC9</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FDD2</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>RTS</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Handles format errors</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FMTERR</td><td class="fit">FDD3</td>
				<td>CE 20 06</td>
				<td class="fit">DEC $0620</td><td rowspan="3"><p>Decrement the retry counter CNT ($0620)
and, if no tries left, branch to FMTE10.
If any left, JMP to END($F99C) to do any
stepping required and try again.</p>
</td></tr>
				<tr><td></td><td class="fit">FDD6</td>
				<td>F0 03</td>
				<td class="fit">BEQ $FDDB</td></tr>
				<tr><td></td><td class="fit">FDD8</td>
				<td>4C 9C F9</td>
				<td class="fit">JMP $F99C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FMTE10</td><td class="fit">FDDB</td>
				<td>A0 FF</td>
				<td class="fit">LDY #$FF</td><td rowspan="5"><p>Set the track counter FTNUM^($51) to $FF
and the GCRFLG ($50) to and JMP to
ERRR ($F969) .</p>
</td></tr>
				<tr><td></td><td class="fit">FDDD</td>
				<td>84 51</td>
				<td class="fit">STY $51</td></tr>
				<tr><td></td><td class="fit">FDDF</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FDE0</td>
				<td>84 50</td>
				<td class="fit">STY $50</td></tr>
				<tr><td></td><td class="fit">FDE2</td>
				<td>4C 69 F9</td>
				<td class="fit">JMP $F969</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Move .Y bytes in buffer #0 up 69 bytes</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MOVUP</td><td class="fit">FDE5</td>
				<td>B9 00 03</td>
				<td class="fit">LDA $0300,Y</td><td rowspan="4"><p>Loop to move .Y characters in buffer #0
($0300+) up 69 memory locations in RAM.</p>
</td></tr>
				<tr><td></td><td class="fit">FDE8</td>
				<td>99 45 03</td>
				<td class="fit">STA $0345,Y</td></tr>
				<tr><td></td><td class="fit">FDEB</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">FDEC</td>
				<td>D0 F7</td>
				<td class="fit">BNE $FDE5</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FDEE</td>
				<td>AD 00 03</td>
				<td class="fit">LDA $0300</td><td rowspan="3"><p>Move byte from $0300 to $0345. RTS
Move 69 bytes from overflow buffer into
the bottom of the data buffer pointed
to by BUFPNT ($30/1)</p>
</td></tr>
				<tr><td></td><td class="fit">FDF1</td>
				<td>8D 45 03</td>
				<td class="fit">STA $0345</td></tr>
				<tr><td></td><td class="fit">FDF4</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">MOVOVR</td><td class="fit">FDF5</td>
				<td>A0 44</td>
				<td class="fit">LDY #$44</td><td rowspan="1"><p>Load .Y with $44 (68)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FDF7</td>
				<td>B9 BB 01</td>
				<td class="fit">LDA $01BB,Y</td><td rowspan="5"><p>Loop to move 69 bytes from $01BB+ into
the data buffer. RTS</p>
</td></tr>
				<tr><td></td><td class="fit">FDFA</td>
				<td>91 30</td>
				<td class="fit">STA ($30),Y</td></tr>
				<tr><td></td><td class="fit">FDFC</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">FDFD</td>
				<td>10 F8</td>
				<td class="fit">BPL $FDF7</td></tr>
				<tr><td></td><td class="fit">FDFF</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Disable write mode</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">KILL</td><td class="fit">FE00</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td><td rowspan="6"><p>Set bits 5, 6 and 7 of the 6522' s PCR2
($1C0C) to set CB2 high. Store in the
data direction register DDRA2 ($1C03)
to make PORT A an input port. RTS</p>
</td></tr>
				<tr><td></td><td class="fit">FE03</td>
				<td>09 E0</td>
				<td class="fit">ORA #$E0</td></tr>
				<tr><td></td><td class="fit">FE05</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td></tr>
				<tr><td></td><td class="fit">FE08</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td></tr>
				<tr><td></td><td class="fit">FE0A</td>
				<td>8D 03 1C</td>
				<td class="fit">STA $1C03</td></tr>
				<tr><td></td><td class="fit">FE0D</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Wipe track with non-sync characters</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLEAR</td><td class="fit">FE0E</td>
				<td>AD 0C 1C</td>
				<td class="fit">LDA $1C0C</td><td rowspan="4"><p>Clear (zero) bit 5 of the 6522' s PCR2
($1C0C). This forces CB2 low.</p>
</td></tr>
				<tr><td></td><td class="fit">FE11</td>
				<td>29 1F</td>
				<td class="fit">AND #$1F</td></tr>
				<tr><td></td><td class="fit">FE13</td>
				<td>09 C0</td>
				<td class="fit">ORA #$C0</td></tr>
				<tr><td></td><td class="fit">FE15</td>
				<td>8D 0C 1C</td>
				<td class="fit">STA $1C0C</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE18</td>
				<td>A9 FF</td>
				<td class="fit">LDA #$FF</td><td rowspan="4"><p>Store $FF in the data direction register
DDRA2 ($1C03) to set output mode and put
$55 in the data port DATA2 ($1C01) to
write non-sync characters.</p>
</td></tr>
				<tr><td></td><td class="fit">FE1A</td>
				<td>8D 03 1C</td>
				<td class="fit">STA $1C03</td></tr>
				<tr><td></td><td class="fit">FE1D</td>
				<td>A9 55</td>
				<td class="fit">LDA #$55</td></tr>
				<tr><td></td><td class="fit">FE1F</td>
				<td>8D 01 1C</td>
				<td class="fit">STA $1C01</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE22</td>
				<td>A2 28</td>
				<td class="fit">LDX #$28</td><td rowspan="2"><p>Initialize .X to $28 (hi counter) and
.Y to $00 (lo counter).</p>
</td></tr>
				<tr><td></td><td class="fit">FE24</td>
				<td>A0 00</td>
				<td class="fit">LDY #$00</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">CLER10</td><td class="fit">FE26</td>
				<td>50 FE</td>
				<td class="fit">BVC $FE26</td><td rowspan="6"><p>Loop to write out 40*256 non-sync
characters using .X &amp; .Y as counters.</p>
</td></tr>
				<tr><td></td><td class="fit">FE28</td>
				<td>B8</td>
				<td class="fit">CLV</td></tr>
				<tr><td></td><td class="fit">FE29</td>
				<td>88</td>
				<td class="fit">DEY</td></tr>
				<tr><td></td><td class="fit">FE2A</td>
				<td>D0 FA</td>
				<td class="fit">BNE $FE26</td></tr>
				<tr><td></td><td class="fit">FE2C</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FE2D</td>
				<td>D0 F7</td>
				<td class="fit">BNE $FE26</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE2F</td>
				<td>60</td>
				<td class="fit">RTS</td><td rowspan="1"><p>RTS -<em>- WARNING WRITE MODE LEFT ON -</em>-</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Convert header images in buffer #0 into GCR form without the header ID code.</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FBTOG</td><td class="fit">FE30</td>
				<td>A9 00</td>
				<td class="fit">LDA #$00</td><td rowspan="4"><p>Zero the low byte of the buffer pointers
pointers BUFPNT($31) and SAVPNT ($2E)
and the byte counter BYTCNT ($36) .</p>
</td></tr>
				<tr><td></td><td class="fit">FE32</td>
				<td>85 30</td>
				<td class="fit">STA $30</td></tr>
				<tr><td></td><td class="fit">FE34</td>
				<td>85 2E</td>
				<td class="fit">STA $2E</td></tr>
				<tr><td></td><td class="fit">FE36</td>
				<td>85 36</td>
				<td class="fit">STA $36</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE38</td>
				<td>A9 BB</td>
				<td class="fit">LDA #$BB</td><td rowspan="2"><p>Set the GCR pointer GCRPNT ($34) to $BB
so it points to the first character in
the overflow buffer ($01BB+) .</p>
</td></tr>
				<tr><td></td><td class="fit">FE3A</td>
				<td>85 34</td>
				<td class="fit">STA $34</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE3C</td>
				<td>A5 31</td>
				<td class="fit">LDA $31</td><td rowspan="4"><p>Save the hi byte of the buffer pointer
BUFPNT ($31) into SAVPNT ($2F) and then
set BUFPNT to $01 to point to the over-
flow buffer.</p>
</td></tr>
				<tr><td></td><td class="fit">FE3E</td>
				<td>85 2F</td>
				<td class="fit">STA $2F</td></tr>
				<tr><td></td><td class="fit">FE40</td>
				<td>A9 01</td>
				<td class="fit">LDA #$01</td></tr>
				<tr><td></td><td class="fit">FE42</td>
				<td>85 31</td>
				<td class="fit">STA $31</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">FBG10</td><td class="fit">FE44</td>
				<td>A4 36</td>
				<td class="fit">LDY $36</td><td rowspan="18"><p>Loop to move 4 bytes at a time into the
staging area $52-55 and then do a JSR
to PUT4BG ($F6D0) to convert them into
five GCR bytes and store them in the
overflow or data buffer. Terminate the
routine with a JMP to PUT4BG to convert
and store the last four.</p>
</td></tr>
				<tr><td></td><td class="fit">FE46</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">FE48</td>
				<td>85 52</td>
				<td class="fit">STA $52</td></tr>
				<tr><td></td><td class="fit">FE4A</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FE4B</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">FE4D</td>
				<td>85 53</td>
				<td class="fit">STA $53</td></tr>
				<tr><td></td><td class="fit">FE4F</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FE50</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">FE52</td>
				<td>85 54</td>
				<td class="fit">STA $54</td></tr>
				<tr><td></td><td class="fit">FE54</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FE55</td>
				<td>B1 2E</td>
				<td class="fit">LDA ($2E),Y</td></tr>
				<tr><td></td><td class="fit">FE57</td>
				<td>85 55</td>
				<td class="fit">STA $55</td></tr>
				<tr><td></td><td class="fit">FE59</td>
				<td>C8</td>
				<td class="fit">INY</td></tr>
				<tr><td></td><td class="fit">FE5A</td>
				<td>F0 08</td>
				<td class="fit">BEQ $FE64</td></tr>
				<tr><td></td><td class="fit">FE5C</td>
				<td>84 36</td>
				<td class="fit">STY $36</td></tr>
				<tr><td></td><td class="fit">FE5E</td>
				<td>20 D0 F6</td>
				<td class="fit">JSR $F6D0</td></tr>
				<tr><td></td><td class="fit">FE61</td>
				<td>4C 44 FE</td>
				<td class="fit">JMP $FE44</td></tr>
				<tr><td></td><td class="fit">FE64</td>
				<td>4C D0 F6</td>
				<td class="fit">JMP $F6D0</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Main system IRQ routine (IRQ vector points here)</h1>
<p>IRQ's are generated in two ways:</p>
<ol>
<li>by an ATN signal from the VIC-20
or the C-64 on the serial bus, or</li>
<li>by a time out of the 6522 's timer
This happens every 10 milliseconds</li>
</ol>
<p>This routine tests for the source of the
IRQ signal and branches to the correct
ROM routine.</p>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SYSIRQ</td><td class="fit">FE67</td>
				<td>48</td>
				<td class="fit">PHA</td><td rowspan="5"><p>Save .A,. X, and .Y on the stack</p>
</td></tr>
				<tr><td></td><td class="fit">FE68</td>
				<td>8A</td>
				<td class="fit">TXA</td></tr>
				<tr><td></td><td class="fit">FE69</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
				<tr><td></td><td class="fit">FE6A</td>
				<td>98</td>
				<td class="fit">TYA</td></tr>
				<tr><td></td><td class="fit">FE6B</td>
				<td>48</td>
				<td class="fit">PHA</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE6C</td>
				<td>AD 0D 18</td>
				<td class="fit">LDA $180D</td><td rowspan="4"><p>Test if IRQ caused by an ATN signal
the serial bus by checking bit 1 of
interrupt flag register of the 6522
handles the bus IFR1 ($180D). If thi
bit is not set (1). there was no ATN
signal so branch to IRQ10 ($FE76). I
is set, JMP to the bus handling rout
ATNIRQ ($E85F) .</p>
</td></tr>
				<tr><td></td><td class="fit">FE6F</td>
				<td>29 02</td>
				<td class="fit">AND #$02</td></tr>
				<tr><td></td><td class="fit">FE71</td>
				<td>F0 03</td>
				<td class="fit">BEQ $FE76</td></tr>
				<tr><td></td><td class="fit">FE73</td>
				<td>20 53 E8</td>
				<td class="fit">JSR $E853</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IRQ10</td><td class="fit">FE76</td>
				<td>AD 0D 1C</td>
				<td class="fit">LDA $1C0D</td><td rowspan="4"><p>Test if the 6522 timer has timed out-
testing bit 7 of the interrupt flag
register of the 6522 that serves as
disk controller IFR2 ($1C0D). If the
is not set, branch to IRQ20 ($FE7F) .
it is set, do a JSR to the floppy di
controller routines, LCC($F2B0).</p>
</td></tr>
				<tr><td></td><td class="fit">FE79</td>
				<td>0A</td>
				<td class="fit">ASL</td></tr>
				<tr><td></td><td class="fit">FE7A</td>
				<td>10 03</td>
				<td class="fit">BPL $FE7F</td></tr>
				<tr><td></td><td class="fit">FE7C</td>
				<td>20 B0 F2</td>
				<td class="fit">JSR $F2B0</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">IRQ20</td><td class="fit">FE7F</td>
				<td>68</td>
				<td class="fit">PLA</td><td rowspan="6"><p>Pull .A, .X, and .Y from the stack and
do an RTI.</p>
</td></tr>
				<tr><td></td><td class="fit">FE80</td>
				<td>A8</td>
				<td class="fit">TAY</td></tr>
				<tr><td></td><td class="fit">FE81</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">FE82</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">FE83</td>
				<td>68</td>
				<td class="fit">PLA</td></tr>
				<tr><td></td><td class="fit">FE84</td>
				<td>40</td>
				<td class="fit">RTI</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE85</td>
				<td>12</td>
				<td class="fit"></td><td rowspan="1"><p>Directory track number (18)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE86</td>
				<td>04</td>
				<td class="fit"></td><td rowspan="1"><p>Number of bytes/ track in BAM</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE87</td>
				<td>04</td>
				<td class="fit"></td><td rowspan="1"><p>Offset of BAM in the sector</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE88</td>
				<td>90</td>
				<td class="fit"></td><td rowspan="1"><p>Offset of disk name in BAM sector</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Command Search Table</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE89</td>
				<td>56</td>
				<td class="fit"></td><td rowspan="1"><p>V = Validate or collect disk</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE8A</td>
				<td>49</td>
				<td class="fit"></td><td rowspan="1"><p>I = Initialize BAM &amp; directory</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE8B</td>
				<td>44</td>
				<td class="fit"></td><td rowspan="1"><p>D = Duplicate or backup disk (N.A.)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE8C</td>
				<td>4D</td>
				<td class="fit"></td><td rowspan="1"><p>M = Memory operation (M-R,M-W r M-E)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE8D</td>
				<td>42</td>
				<td class="fit"></td><td rowspan="1"><p>B = Block operation (B-R,B-A,B-W,etc)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE8E</td>
				<td>55</td>
				<td class="fit"></td><td rowspan="1"><p>U = User jump commands (except U + &amp; U-)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE8F</td>
				<td>50</td>
				<td class="fit"></td><td rowspan="1"><p>P = Position (for REL files)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE90</td>
				<td>26</td>
				<td class="fit"></td><td rowspan="1"><p>&amp; = Utility loader</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE91</td>
				<td>43</td>
				<td class="fit"></td><td rowspan="1"><p>C = Copy file (copy disk N.A. on 1541)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE92</td>
				<td>52</td>
				<td class="fit"></td><td rowspan="1"><p>R = Rename file</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE93</td>
				<td>53</td>
				<td class="fit"></td><td rowspan="1"><p>S = Scratch file</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE94</td>
				<td>4E</td>
				<td class="fit"></td><td rowspan="1"><p>N = New or format a diskette</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Command Jump Table</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FE95</td>
				<td>84 05 C1 F8 1B 5C 07 A3 F0 88 23 0D ED D0 C8 CA CC CB E2 E7 C8 CA C8 EE</td>
				<td class="fit"></td><td rowspan="1"><pre><code>(Lo Byte) |  (Hi Byte) | Command
----------|------------|-----------------------
$FE95 $84 |  $FEA1 $ED | V = Validate
$FE96 $05 |  $FEA1 $D0 | I = Initialize BAM
$FE97 $C1 |  $FEA1 $C8 | D = Duplicate (NA)
$FE98 $F8 |  $FEA1 $CA | M = Memory Operation
$FE99 $1B |  $FEA1 $CC | B = Block Operation
$FE9A $5C |  $FEA1 $CB | U = User jump commands
$FE9B $07 |  $FEA1 $E2 | P = Position (for REL)
$FE9C $A3 |  $FEA1 $E7 | &amp; = Utility loader
$FE9D $F0 |  $FEA1 $C8 | C = Copy file
$FE9E $88 |  $FEA1 $CA | R = Rename File
$FE9F $23 |  $FEA1 $C8 | S = Scratch file
$FEA0 $0D |  $FEA1 $EE | N = New a diskette</code></pre>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Structure images for commands</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEAD</td>
				<td>51</td>
				<td class="fit"></td><td rowspan="1"><p>%01010001 disk copy</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEAE</td>
				<td>DD</td>
				<td class="fit"></td><td rowspan="1"><p>%11011101 rename a file (not parsed)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEAF</td>
				<td>1C</td>
				<td class="fit"></td><td rowspan="1"><p>%00011100 scratch a file (not parsed)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEB0</td>
				<td>9E</td>
				<td class="fit"></td><td rowspan="1"><p>%10011110 new a diskette (not parsed)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEB1</td>
				<td>1C</td>
				<td class="fit"></td><td rowspan="1"><p>%00011100 load a file</p>
<pre><code>%PGDRPGDR Not greater than one file
 FS1 FS2  Not default drive (s)
          Required filename</code></pre>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Mode table (R/W/A/M)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEB2</td>
				<td>52</td>
				<td class="fit"></td><td rowspan="1"><p>Read mode</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEB3</td>
				<td>57</td>
				<td class="fit"></td><td rowspan="1"><p>Write mode</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEB4</td>
				<td>41</td>
				<td class="fit"></td><td rowspan="1"><p>Append</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEB5</td>
				<td>4D</td>
				<td class="fit"></td><td rowspan="1"><p>Modify (read improperly closed file)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Miscellaneous constants &amp; tables in ROM</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEB6</td>
				<td>44 53 50 55 4C 44 53 50 55 52 45 45 52 53 45 4C 51 47 52 4C</td>
				<td class="fit"></td><td rowspan="1"><pre><code>(1st Byte)   (Hi Byte)   File type table
$FEB6 $44 D  $FEBB $44 D  $FEC0 $45 E  $FEC5 $4C L  DEL
$FEB7 $53 S  $FEBC $53 S  $FEC1 $45 E  $FEC6 $51 Q  SQR
$FEB8 $50 P  $FEBD $50 P  $FEC2 $52 R  $FEC7 $47 G  PRG
$FEB9 $55 U  $FEBE $55 U  $FEC3 $53 S  $FEC8 $52 R  USR
$FEBA $4C L  $FEBF $52 R  $FEC4 $45 E  $FEC9 $4C L  REL</code></pre>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FECA</td>
				<td>08</td>
				<td class="fit"></td><td rowspan="1"><p>LED mask for drive</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FECB</td>
				<td>00</td>
				<td class="fit"></td><td rowspan="1"><p>LED mask for drive 1 (N.A. on 1541)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Error flag variables for use by bit</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FECC</td>
				<td>00</td>
				<td class="fit"></td><td rowspan="1"><p>ER00</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FECD</td>
				<td>3F</td>
				<td class="fit"></td><td rowspan="1"><p>ER0</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FECE</td>
				<td>7F</td>
				<td class="fit"></td><td rowspan="1"><p>ER1</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FECF</td>
				<td>BF</td>
				<td class="fit"></td><td rowspan="1"><p>ER2</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED0</td>
				<td>FF</td>
				<td class="fit"></td><td rowspan="1"><p>ER3</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Number of sectors/track in each zone</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED1</td>
				<td>11</td>
				<td class="fit"></td><td rowspan="1"><p>17 sectors/track in</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED2</td>
				<td>12</td>
				<td class="fit"></td><td rowspan="1"><p>18 sectors/track in</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED3</td>
				<td>13</td>
				<td class="fit"></td><td rowspan="1"><p>19 sectors/track in</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED4</td>
				<td>15</td>
				<td class="fit"></td><td rowspan="1"><p>21 sectors/track in</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED5</td>
				<td>41</td>
				<td class="fit"></td><td rowspan="1"><p>DOS version number (65)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED6</td>
				<td>04</td>
				<td class="fit"></td><td rowspan="1"><p>Number of different zones</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Zone boundaries (highest track# + 1)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED7</td>
				<td>24</td>
				<td class="fit"></td><td rowspan="1"><p>Track #36 - end of zone 4 (31-35)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED8</td>
				<td>1F</td>
				<td class="fit"></td><td rowspan="1"><p>Track #31 - end of zone 3 (25-30)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FED9</td>
				<td>19</td>
				<td class="fit"></td><td rowspan="1"><p>Track #25 - end of zone 2 (18-24)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEDA</td>
				<td>12</td>
				<td class="fit"></td><td rowspan="1"><p>Track #18 - end of zone 1 (01-17)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEDB</td>
				<td>01 FF FF 01 00</td>
				<td class="fit"></td><td rowspan="1"><p>Offsets for error recovery</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Hi byte of pointers to data buffers</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEE0</td>
				<td>03</td>
				<td class="fit"></td><td rowspan="1"><p>Data buffer #0 ($0300-03FF)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEE1</td>
				<td>04</td>
				<td class="fit"></td><td rowspan="1"><p>Data buffer #1 ($0400-04FF)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEE2</td>
				<td>05</td>
				<td class="fit"></td><td rowspan="1"><p>Data buffer #2 ($0500-05FF)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEE3</td>
				<td>06</td>
				<td class="fit"></td><td rowspan="1"><p>Data buffer #3 ($0600-06FF)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEE4</td>
				<td>07</td>
				<td class="fit"></td><td rowspan="1"><p>Data buffer #4 ($0700-07FF)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEE5</td>
				<td>07</td>
				<td class="fit"></td><td rowspan="1"><p>Data buffer #5 ($0700-07FF)</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEE6</td>
				<td>FD</td>
				<td class="fit"></td><td rowspan="1"><p>Checksum for $E and $F ROMs</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>NMI vector points here</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NMI</td><td class="fit">FEE7</td>
				<td>6C 65 00</td>
				<td class="fit">JMP ($0065)</td><td rowspan="1"><p>Do indirect jump to the address stored
in VNMI ($0065). This vector points to
XXXXXX ($XXXX)</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Patch for power-on errors</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">PEA7A</td><td class="fit">FEEA</td>
				<td>8D 00 1C</td>
				<td class="fit">STA $1C00</td><td rowspan="3"><p>Store the value that is in .A on entry
into the 6522' s data port 2, LEDPRT
($1C00; also called DSKCNT) and in the
data direction register, LEDOUT ($1C02;
also called DDRB2). Exit with a JMP to
REA7D ($EA7D) to return to the LED blink
routine .</p>
</td></tr>
				<tr><td></td><td class="fit">FEED</td>
				<td>8D 02 1C</td>
				<td class="fit">STA $1C02</td></tr>
				<tr><td></td><td class="fit">FEF0</td>
				<td>4C 7D EA</td>
				<td class="fit">JMP $EA7D</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Patch for 1541 disk with slow serial receive</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">SLOWD</td><td class="fit">FEF3</td>
				<td>8A</td>
				<td class="fit">TXA</td><td rowspan="6"><p>Produce a 40 microseconds delay with a
loop that counts .X down from 5 to 1.
Exit with an RTS.</p>
</td></tr>
				<tr><td></td><td class="fit">FEF4</td>
				<td>A2 05</td>
				<td class="fit">LDX #$05</td></tr>
				<tr><td></td><td class="fit">FEF6</td>
				<td>CA</td>
				<td class="fit">DEX</td></tr>
				<tr><td></td><td class="fit">FEF7</td>
				<td>D0 FD</td>
				<td class="fit">BNE $FEF6</td></tr>
				<tr><td></td><td class="fit">FEF9</td>
				<td>AA</td>
				<td class="fit">TAX</td></tr>
				<tr><td></td><td class="fit">FEFA</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEFB</td>
				<td>20 AE E9</td>
				<td class="fit"></td><td rowspan="1"><p>Unused junk</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FEFE</td>
				<td>4C 9C E9</td>
				<td class="fit"></td><td rowspan="1"><p>Unused junk</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Patch to nmi routine to check for U+ and U- commands</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NNMI</td><td class="fit">FF01</td>
				<td>AD 02 02</td>
				<td class="fit">LDA $0202</td><td rowspan="6"><p>Load .A with the second character in the
command buffer CMDBUF+2 ($0202), Compare
it with &quot;-&quot; and, if equal, branch to
NNMI10 ($FF0D). If not a &quot;-&quot;. subtract
a &quot; + &quot; from it. If not zero, command must-
be a real UI command so branch back to
NMI ($FEE7) to do normal NMI.</p>
</td></tr>
				<tr><td></td><td class="fit">FF04</td>
				<td>C9 2D</td>
				<td class="fit">CMP #$2D</td></tr>
				<tr><td></td><td class="fit">FF06</td>
				<td>F0 05</td>
				<td class="fit">BEQ $FF0D</td></tr>
				<tr><td></td><td class="fit">FF08</td>
				<td>38</td>
				<td class="fit">SEC</td></tr>
				<tr><td></td><td class="fit">FF09</td>
				<td>E9 2B</td>
				<td class="fit">SBC #$2B</td></tr>
				<tr><td></td><td class="fit">FF0B</td>
				<td>D0 DA</td>
				<td class="fit">BNE $FEE7</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit">NNMI10</td><td class="fit">FF0D</td>
				<td>85 23</td>
				<td class="fit">STA $23</td><td rowspan="2"><p>Store .A (contains zero or a &quot;-&quot;) into
DRVTRK+1 ($23) and do an RTS to continue</p>
</td></tr>
				<tr><td></td><td class="fit">FF0F</td>
				<td>60</td>
				<td class="fit">RTS</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FF10</td>
				<td>AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA</td>
				<td class="fit"></td><td rowspan="1"><p>Unused garbage</p>
</td></tr>
		</tbody>
		<tbody class="header">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><h1>Table of jump vectors to routines (lo byte/hi byte)</h1>
</td>
			</tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFE6</td>
				<td>C6 C8</td>
				<td class="fit"></td><td rowspan="1"><p>FORMAT ROM routine $C8C6</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFE8</td>
				<td>8F F9</td>
				<td class="fit"></td><td rowspan="1"><p>TRNOFF ROM routine $F98F</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFEA</td>
				<td>5F CD</td>
				<td class="fit"></td><td rowspan="1"><p>UBLKRD ROM routine $CD5F</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFEC</td>
				<td>97 CD</td>
				<td class="fit"></td><td rowspan="1"><p>UBLKWT ROM routine $CD97</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFEE</td>
				<td>00 05</td>
				<td class="fit"></td><td rowspan="1"><p>Link to buffer #2 $0500</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFF0</td>
				<td>03 05</td>
				<td class="fit"></td><td rowspan="1"><p>Link to buffer #2 $0503</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFF2</td>
				<td>06 05</td>
				<td class="fit"></td><td rowspan="1"><p>Link to buffer #2 $0506</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFF4</td>
				<td>09 05</td>
				<td class="fit"></td><td rowspan="1"><p>Link to buffer #2 $0509</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFF6</td>
				<td>0C 05</td>
				<td class="fit"></td><td rowspan="1"><p>Link to buffer #2 $050C</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFF8</td>
				<td>0F 05</td>
				<td class="fit"></td><td rowspan="1"><p>Link to buffer #2 $050F</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFFA</td>
				<td>01 FF</td>
				<td class="fit"></td><td rowspan="1"><p>NNMI ROM routine $FF01</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFFC</td>
				<td>A0 EA</td>
				<td class="fit"></td><td rowspan="1"><p>DSKINT ROM routine $EAA0</p>
</td></tr>
		</tbody>
			<tbody class="code">
			
				<tr><td class="fit"></td><td class="fit">FFFE</td>
				<td>67 FE</td>
				<td class="fit"></td><td rowspan="1"><p>SYSIRQ ROM routine $FE67</p>
</td></tr>
		</tbody>
	</table>
</body>
</html>
